===== ./functions/python/main.py =====
import functions_framework
import requests
from bs4 import BeautifulSoup
import json
import hashlib
from urllib.parse import urljoin, urlparse
from datetime import datetime
import time
import random
from google.cloud import firestore
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging

# Initialize Firestore
db = firestore.Client()

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Request settings
REQUEST_DELAY = 2
MAX_RETRIES = 3
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
]

def safe_request(url, retries=MAX_RETRIES):
    """Make HTTP request with retries and error handling"""
    headers = {
        'User-Agent': random.choice(USER_AGENTS),
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1'
    }
    
    for attempt in range(retries):
        try:
            time.sleep(REQUEST_DELAY + random.uniform(0, 2))
            response = requests.get(url, headers=headers, timeout=15)
            response.raise_for_status()
            return response
        except requests.exceptions.RequestException as e:
            logger.warning(f"Attempt {attempt + 1}/{retries} failed for {url}: {e}")
            if attempt == retries - 1:
                logger.error(f"All retries failed for {url}")
                return None
            time.sleep(5 * (attempt + 1))
    return None

def scrape_greenhouse(url, company_name, company_id):
    """Scrape Greenhouse job boards"""
    jobs = []
    response = safe_request(url)
    
    if not response:
        return jobs
    
    try:
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Find all job sections
        job_sections = (
            soup.find_all('div', class_='opening') or
            soup.find_all('section', class_='level-0') or
            []
        )
        
        # Fallback: find job links
        if not job_sections:
            all_links = soup.find_all('a', href=True)
            job_sections = [
                link.parent for link in all_links 
                if '/jobs/' in link.get('href', '') or '/job/' in link.get('href', '')
            ]
        
        for job in job_sections:
            title_tag = job.find('a') if job.name != 'a' else job
            
            if not title_tag:
                continue
            
            title = title_tag.get_text(strip=True)
            
            if not title or len(title) < 3:
                continue
            
            link = title_tag.get('href', '')
            if not link:
                continue
            
            if not link.startswith('http'):
                link = urljoin(url, link)
            
            # Extract location
            location_tag = (
                job.find('span', class_='location') or 
                job.find('div', class_='location') or
                job.find('span', string=lambda t: t and 'remote' in t.lower())
            )
            location = location_tag.get_text(strip=True) if location_tag else "Location not specified"
            
            # Extract department (if available)
            dept_tag = job.find('span', class_='department')
            department = dept_tag.get_text(strip=True) if dept_tag else None
            
            # Create unique ID
            job_id = hashlib.md5(link.encode()).hexdigest()
            
            jobs.append({
                'jobId': job_id,
                'title': title,
                'company': company_name,
                'companyId': company_id,
                'location': location,
                'department': department,
                'url': link,
                'remote': 'remote' in location.lower(),
                'source': 'greenhouse',
                'status': 'active',
                'scrapedAt': firestore.SERVER_TIMESTAMP,
                'postedAt': firestore.SERVER_TIMESTAMP,
            })
        
        # Remove duplicates
        seen_links = set()
        unique_jobs = []
        for job in jobs:
            if job['url'] not in seen_links:
                seen_links.add(job['url'])
                unique_jobs.append(job)
        
        logger.info(f"Greenhouse scraper found {len(unique_jobs)} jobs for {company_name}")
        return unique_jobs
        
    except Exception as e:
        logger.error(f"Greenhouse scrape failed for {company_name}: {e}")
        return jobs

def scrape_lever(url, company_name, company_id):
    """Scrape Lever.co job boards"""
    jobs = []
    response = safe_request(url)
    
    if not response:
        return jobs
    
    try:
        soup = BeautifulSoup(response.text, 'html.parser')
        job_postings = soup.find_all('div', class_='posting')
        
        for job in job_postings:
            title_tag = job.find('h5') or job.find('a', class_='posting-title')
            
            if not title_tag:
                continue
            
            title = title_tag.get_text(strip=True)
            
            link_tag = job.find('a', class_='posting-btn-submit') or title_tag
            link = link_tag.get('href', '') if link_tag else ''
            
            if not link.startswith('http'):
                link = urljoin(url, link)
            
            location_tag = job.find('span', class_='location')
            location = location_tag.get_text(strip=True) if location_tag else "Location not specified"
            
            team_tag = job.find('span', class_='posting-categories-team')
            department = team_tag.get_text(strip=True) if team_tag else None
            
            job_id = hashlib.md5(link.encode()).hexdigest()
            
            jobs.append({
                'jobId': job_id,
                'title': title,
                'company': company_name,
                'companyId': company_id,
                'location': location,
                'department': department,
                'url': link,
                'remote': 'remote' in location.lower(),
                'source': 'lever',
                'status': 'active',
                'scrapedAt': firestore.SERVER_TIMESTAMP,
                'postedAt': firestore.SERVER_TIMESTAMP,
            })
        
        logger.info(f"Lever scraper found {len(jobs)} jobs for {company_name}")
        return jobs
        
    except Exception as e:
        logger.error(f"Lever scrape failed for {company_name}: {e}")
        return jobs

def scrape_workable(url, company_name, company_id):
    """Scrape Workable job boards"""
    jobs = []
    response = safe_request(url)
    
    if not response:
        return jobs
    
    try:
        soup = BeautifulSoup(response.text, 'html.parser')
        job_items = soup.find_all('li', class_='job')
        
        for job in job_items:
            title_tag = job.find('a')
            
            if not title_tag:
                continue
            
            title = title_tag.get_text(strip=True)
            link = title_tag.get('href', '')
            
            if not link.startswith('http'):
                link = urljoin(url, link)
            
            location_tag = job.find('span', class_='location')
            location = location_tag.get_text(strip=True) if location_tag else "Location not specified"
            
            job_id = hashlib.md5(link.encode()).hexdigest()
            
            jobs.append({
                'jobId': job_id,
                'title': title,
                'company': company_name,
                'companyId': company_id,
                'location': location,
                'url': link,
                'remote': 'remote' in location.lower(),
                'source': 'workable',
                'status': 'active',
                'scrapedAt': firestore.SERVER_TIMESTAMP,
                'postedAt': firestore.SERVER_TIMESTAMP,
            })
        
        logger.info(f"Workable scraper found {len(jobs)} jobs for {company_name}")
        return jobs
        
    except Exception as e:
        logger.error(f"Workable scrape failed for {company_name}: {e}")
        return jobs

def get_scraper(url):
    """Determine which scraper to use based on URL"""
    url_lower = url.lower()
    
    if 'greenhouse.io' in url_lower or 'greenhouse' in url_lower:
        return scrape_greenhouse
    elif 'lever.co' in url_lower or 'lever' in url_lower:
        return scrape_lever
    elif 'workable.com' in url_lower or 'apply.workable' in url_lower:
        return scrape_workable
    else:
        return None

def store_jobs(jobs):
    """Store jobs in Firestore, avoiding duplicates"""
    batch = db.batch()
    new_jobs = []
    
    for job in jobs:
        job_ref = db.collection('jobs').document(job['jobId'])
        
        # Check if job already exists
        job_doc = job_ref.get()
        
        if not job_doc.exists:
            batch.set(job_ref, job)
            new_jobs.append(job)
        else:
            # Update scrape timestamp
            batch.update(job_ref, {
                'scrapedAt': firestore.SERVER_TIMESTAMP,
                'status': 'active'
            })
    
    batch.commit()
    logger.info(f"Stored {len(new_jobs)} new jobs, updated {len(jobs) - len(new_jobs)} existing jobs")
    
    return new_jobs

def scrape_company(company_data):
    """Scrape a single company"""
    company_id = company_data['companyId']
    company_name = company_data['name']
    careers_url = company_data['careersUrl']
    
    logger.info(f"Scraping {company_name}...")
    
    scraper = get_scraper(careers_url)
    
    if not scraper:
        logger.warning(f"No scraper found for {company_name} URL: {careers_url}")
        return []
    
    jobs = scraper(careers_url, company_name, company_id)
    
    if jobs:
        new_jobs = store_jobs(jobs)
        
        # Update company stats
        db.collection('companies').document(company_id).update({
            'lastScraped': firestore.SERVER_TIMESTAMP,
            'jobCount': len(jobs)
        })
        
        return new_jobs
    
    return []

@functions_framework.http
def scrape_all_companies(request):
    """HTTP Cloud Function to scrape all active companies"""
    try:
        # Get all active companies
        companies_ref = db.collection('companies').where('active', '==', True)
        companies = [doc.to_dict() | {'companyId': doc.id} for doc in companies_ref.stream()]
        
        logger.info(f"Starting scrape for {len(companies)} companies")
        
        # Scrape companies in parallel (max 10 concurrent)
        all_new_jobs = []
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_company = {
                executor.submit(scrape_company, company): company 
                for company in companies
            }
            
            for future in as_completed(future_to_company):
                company = future_to_company[future]
                try:
                    new_jobs = future.result()
                    all_new_jobs.extend(new_jobs)
                    logger.info(f"Completed {company['name']}: {len(new_jobs)} new jobs")
                except Exception as e:
                    logger.error(f"Error scraping {company['name']}: {e}")
        
        logger.info(f"Scraping complete! Found {len(all_new_jobs)} new jobs total")
        
        return {
            'success': True,
            'companiesScraped': len(companies),
            'newJobs': len(all_new_jobs),
            'timestamp': datetime.utcnow().isoformat()
        }, 200
        
    except Exception as e:
        logger.error(f"Scraping error: {e}")
        return {'error': str(e)}, 500

@functions_framework.http
def scrape_single_company(request):
    """HTTP Cloud Function to scrape a single company"""
    try:
        request_json = request.get_json(silent=True)
        
        if not request_json or 'companyId' not in request_json:
            return {'error': 'companyId is required'}, 400
        
        company_id = request_json['companyId']
        
        # Get company data
        company_doc = db.collection('companies').document(company_id).get()
        
        if not company_doc.exists:
            return {'error': 'Company not found'}, 404
        
        company_data = company_doc.to_dict()
        company_data['companyId'] = company_id
        
        new_jobs = scrape_company(company_data)
        
        return {
            'success': True,
            'company': company_data['name'],
            'newJobs': len(new_jobs),
            'jobs': new_jobs[:10]  # Return first 10 jobs
        }, 200
        
    except Exception as e:
        logger.error(f"Single company scraping error: {e}")
        return {'error': str(e)}, 500

@functions_framework.http
def fetch_job_details(request):
    """Fetch detailed job description from URL"""
    try:
        request_json = request.get_json(silent=True)
        
        if not request_json or 'url' not in request_json:
            return {'error': 'url is required'}, 400
        
        url = request_json['url']
        response = safe_request(url)
        
        if not response:
            return {'error': 'Failed to fetch job page'}, 500
        
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Extract job description
        description = None
        
        # Try common selectors
        desc_selectors = [
            {'class': 'content'},
            {'class': 'description'},
            {'class': 'job-description'},
            {'id': 'content'},
        ]
        
        for selector in desc_selectors:
            desc_elem = soup.find('div', selector)
            if desc_elem:
                description = desc_elem.get_text(strip=True, separator='\n')
                break
        
        # Extract requirements
        requirements = []
        req_section = soup.find(['h2', 'h3', 'h4'], string=lambda t: t and 'requirement' in t.lower())
        
        if req_section:
            req_list = req_section.find_next(['ul', 'ol'])
            if req_list:
                requirements = [li.get_text(strip=True) for li in req_list.find_all('li')]
        
        return {
            'success': True,
            'description': description,
            'requirements': requirements
        }, 200
        
    except Exception as e:
        logger.error(f"Job details fetch error: {e}")
        return {'error': str(e)}, 500
===== ./functions/src/index.ts =====
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import { stripe, constructWebhookEvent, getTierFromPriceId, isSubscriptionActive } from './lib/stripe';
import { deepseek } from './lib/deepseek';
import { sendEmail } from './lib/email';
import Stripe from 'stripe';

admin.initializeApp();

const db = admin.firestore();

// ==================== STRIPE WEBHOOKS ====================

export const stripeWebhook = functions.https.onRequest(async (req, res) => {
  const signature = req.headers['stripe-signature'] as string;

  if (!signature) {
    res.status(400).send('Missing stripe-signature header');
    return;
  }

  try {
    const event = await constructWebhookEvent(req.rawBody, signature);

    switch (event.type) {
      case 'checkout.session.completed':
        await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);
        break;

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;

      case 'invoice.payment_succeeded':
        await handlePaymentSucceeded(event.data.object as Stripe.Invoice);
        break;

      case 'invoice.payment_failed':
        await handlePaymentFailed(event.data.object as Stripe.Invoice);
        break;
    }

    res.json({ received: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(400).send(`Webhook Error: ${error}`);
  }
});

async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const userId = session.metadata?.userId;
  const tier = session.metadata?.tier;

  if (!userId || !tier) {
    console.error('Missing metadata in checkout session');
    return;
  }

  const subscription = await stripe.subscriptions.retrieve(session.subscription as string);

  await db.collection('users').doc(userId).update({
    tier,
    stripeCustomerId: session.customer as string,
    subscriptionId: subscription.id,
    subscriptionStatus: subscription.status,
    currentPeriodEnd: admin.firestore.Timestamp.fromDate(
      new Date(subscription.current_period_end * 1000)
    ),
  });

  // Send welcome email
  const userDoc = await db.collection('users').doc(userId).get();
  const userData = userDoc.data();

  if (userData?.email) {
    await sendEmail({
      to: userData.email,
      subject: 'Welcome to JobHunt AI Pro! ðŸŽ‰',
      html: `
        <h1>Welcome to JobHunt AI ${tier.charAt(0).toUpperCase() + tier.slice(1)}!</h1>
        <p>Thank you for subscribing. Your account is now active with ${tier} features.</p>
        <p>Here's what you can do now:</p>
        <ul>
          <li>Track up to ${tier === 'pro' ? '50' : tier === 'premium' ? 'unlimited' : '500+'} companies</li>
          <li>Get AI-powered job matching</li>
          <li>Generate personalized cover letters</li>
          <li>Receive instant job alerts</li>
        </ul>
        <p><a href="${process.env.NEXT_PUBLIC_APP_URL}/dashboard">Go to Dashboard â†’</a></p>
      `,
    });
  }
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.userId;

  if (!userId) return;

  const tier = getTierFromPriceId(subscription.items.data[0].price.id);

  await db.collection('users').doc(userId).update({
    tier: tier || 'free',
    subscriptionStatus: subscription.status,
    currentPeriodEnd: admin.firestore.Timestamp.fromDate(
      new Date(subscription.current_period_end * 1000)
    ),
  });
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.userId;

  if (!userId) return;

  await db.collection('users').doc(userId).update({
    tier: 'free',
    subscriptionStatus: 'canceled',
    subscriptionId: admin.firestore.FieldValue.delete(),
    currentPeriodEnd: admin.firestore.FieldValue.delete(),
  });

  // Send cancellation email
  const userDoc = await db.collection('users').doc(userId).get();
  const userData = userDoc.data();

  if (userData?.email) {
    await sendEmail({
      to: userData.email,
      subject: 'Subscription Canceled',
      html: `
        <h2>Sorry to see you go!</h2>
        <p>Your subscription has been canceled. You'll retain access until the end of your billing period.</p>
        <p>We'd love to hear your feedback on how we can improve.</p>
        <p><a href="${process.env.NEXT_PUBLIC_APP_URL}/settings">Reactivate Subscription â†’</a></p>
      `,
    });
  }
}

async function handlePaymentSucceeded(invoice: Stripe.Invoice) {
  console.log('Payment succeeded:', invoice.id);
  // Additional logging or analytics can go here
}

async function handlePaymentFailed(invoice: Stripe.Invoice) {
  const subscription = invoice.subscription;
  if (!subscription) return;

  const subObj = await stripe.subscriptions.retrieve(subscription as string);
  const userId = subObj.metadata?.userId;

  if (!userId) return;

  const userDoc = await db.collection('users').doc(userId).get();
  const userData = userDoc.data();

  if (userData?.email) {
    await sendEmail({
      to: userData.email,
      subject: 'Payment Failed - Action Required',
      html: `
        <h2>Payment Failed</h2>
        <p>We couldn't process your payment. Please update your payment method to continue using JobHunt AI.</p>
        <p><a href="${process.env.NEXT_PUBLIC_APP_URL}/settings/billing">Update Payment Method â†’</a></p>
      `,
    });
  }
}

// ==================== AI MATCHING ====================

export const analyzeResume = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'Must be logged in');
  }

  const { resumeText } = data;

  if (!resumeText) {
    throw new functions.https.HttpsError('invalid-argument', 'Resume text is required');
  }

  try {
    const analysis = await deepseek.analyzeResume(resumeText);

    // Store analysis in user document
    await db.collection('users').doc(context.auth.uid).update({
      resumeAnalysis: analysis,
      'aiSettings.resumeAnalyzed': true,
      'aiSettings.lastResumeUpdate': admin.firestore.FieldValue.serverTimestamp(),
    });

    return { success: true, analysis };
  } catch (error) {
    console.error('Resume analysis error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to analyze resume');
  }
});

export const matchJobToUser = functions.firestore
  .document('jobs/{jobId}')
  .onCreate(async (snap, context) => {
    const job = snap.data();
    const jobId = context.params.jobId;

    // Get all active users
    const usersSnapshot = await db
      .collection('users')
      .where('subscriptionStatus', '==', 'active')
      .get();

    const matchPromises = usersSnapshot.docs.map(async (userDoc) => {
      const userData = userDoc.data();
      const userId = userDoc.id;

      // Quick filter - check basic criteria
      if (!matchesBasicCriteria(job, userData.preferences)) {
        return null;
      }

      try {
        // Calculate AI match score
        const matchResult = await deepseek.calculateMatchScore(
          userData.resumeAnalysis || {},
          job
        );

        const matchThreshold = userData.aiSettings?.matchThreshold || 70;

        // Only create match if score is above threshold
        if (matchResult.score >= matchThreshold) {
          const matchRef = db.collection('user_job_matches').doc();

          await matchRef.set({
            userId,
            jobId,
            matchScore: matchResult.score,
            matchReasons: matchResult.reasons,
            weaknesses: matchResult.weaknesses,
            notified: false,
            viewed: false,
            applied: false,
            saved: false,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
          });

          // Send notification
          await notifyUserAboutJob(userId, jobId, matchResult.score);

          return matchRef.id;
        }

        return null;
      } catch (error) {
        console.error(`Error matching job to user ${userId}:`, error);
        return null;
      }
    });

    await Promise.all(matchPromises);
  });

function matchesBasicCriteria(job: any, preferences: any): boolean {
  if (!preferences) return true;

  // Check keywords
  if (preferences.keywords && preferences.keywords.length > 0) {
    const titleLower = job.title.toLowerCase();
    const hasKeyword = preferences.keywords.some((kw: string) =>
      titleLower.includes(kw.toLowerCase())
    );
    if (!hasKeyword) return false;
  }

  // Check exclude keywords
  if (preferences.excludeKeywords && preferences.excludeKeywords.length > 0) {
    const titleLower = job.title.toLowerCase();
    const hasExclude = preferences.excludeKeywords.some((kw: string) =>
      titleLower.includes(kw.toLowerCase())
    );
    if (hasExclude) return false;
  }

  // Check location
  if (preferences.locations && preferences.locations.length > 0) {
    const hasLocation = preferences.locations.some((loc: string) =>
      job.location?.toLowerCase().includes(loc.toLowerCase())
    );
    if (!hasLocation && !job.remote) return false;
  }

  return true;
}

async function notifyUserAboutJob(userId: string, jobId: string, matchScore: number) {
  const userDoc = await db.collection('users').doc(userId).get();
  const userData = userDoc.data();

  if (!userData?.email) return;

  const jobDoc = await db.collection('jobs').doc(jobId).get();
  const jobData = jobDoc.data();

  if (!jobData) return;

  await sendEmail({
    to: userData.email,
    subject: `New Job Match: ${jobData.title} at ${jobData.company} (${matchScore}% match)`,
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; text-align: center; color: white;">
          <h1 style="margin: 0;">ðŸŽ¯ ${matchScore}% Match!</h1>
          <p style="margin: 10px 0 0 0; font-size: 18px;">New job opportunity for you</p>
        </div>
        
        <div style="padding: 30px; background: #f8fafc;">
          <h2 style="color: #1e293b; margin-top: 0;">${jobData.title}</h2>
          <p style="color: #64748b; font-size: 16px; margin: 10px 0;">
            <strong>${jobData.company}</strong> â€¢ ${jobData.location}
          </p>
          
          <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="color: #2563eb; margin-top: 0;">Why this is a great match:</h3>
            <ul style="color: #475569; line-height: 1.8;">
              ${(jobData.matchReasons || ['Strong skills alignment', 'Experience level fits']).map((reason: string) => 
                `<li>${reason}</li>`
              ).join('')}
            </ul>
          </div>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="${process.env.NEXT_PUBLIC_APP_URL}/jobs/${jobId}" 
               style="background: #2563eb; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px; display: inline-block; font-weight: bold;">
              View Full Job Details â†’
            </a>
          </div>
          
          <p style="color: #94a3b8; font-size: 14px; text-align: center; margin-top: 30px;">
            Apply within 24 hours for the best chance of getting noticed!
          </p>
        </div>
      </div>
    `,
  });

  // Mark as notified
  await db.collection('user_job_matches')
    .where('userId', '==', userId)
    .where('jobId', '==', jobId)
    .limit(1)
    .get()
    .then(snapshot => {
      if (!snapshot.empty) {
        snapshot.docs[0].ref.update({
          notified: true,
          notifiedAt: admin.firestore.FieldValue.serverTimestamp(),
        });
      }
    });
}

// ==================== COVER LETTER GENERATION ====================

export const generateCoverLetter = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'Must be logged in');
  }

  const { jobId, tone = 'professional' } = data;

  // Check subscription
  const userDoc = await db.collection('users').doc(context.auth.uid).get();
  const userData = userDoc.data();

  if (!userData || !['pro', 'premium', 'enterprise'].includes(userData.tier)) {
    throw new functions.https.HttpsError('permission-denied', 'Pro subscription required');
  }

  try {
    const jobDoc = await db.collection('jobs').doc(jobId).get();
    const jobData = jobDoc.data();

    if (!jobData) {
      throw new functions.https.HttpsError('not-found', 'Job not found');
    }

    const coverLetter = await deepseek.generateCoverLetter(
      userData.resumeAnalysis || {},
      jobData,
      tone
    );

    // Store generation
    await db.collection('ai_generations').add({
      userId: context.auth.uid,
      jobId,
      type: 'cover_letter',
      content: coverLetter,
      tone,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    return { success: true, coverLetter };
  } catch (error) {
    console.error('Cover letter generation error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to generate cover letter');
  }
});

// ==================== INTERVIEW PREP ====================

export const generateInterviewQuestions = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'Must be logged in');
  }

  const { jobId } = data;

  const userDoc = await db.collection('users').doc(context.auth.uid).get();
  const userData = userDoc.data();

  if (!userData || !['premium', 'enterprise'].includes(userData.tier)) {
    throw new functions.https.HttpsError('permission-denied', 'Premium subscription required');
  }

  try {
    const jobDoc = await db.collection('jobs').doc(jobId).get();
    const jobData = jobDoc.data();

    if (!jobData) {
      throw new functions.https.HttpsError('not-found', 'Job not found');
    }

    const questions = await deepseek.generateInterviewQuestions(
      jobData,
      userData.resumeAnalysis || {}
    );

    return { success: true, questions };
  } catch (error) {
    console.error('Interview questions generation error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to generate questions');
  }
});

// ==================== USER STATS ====================

export const updateUserStats = functions.pubsub
  .schedule('every 24 hours')
  .onRun(async () => {
    const usersSnapshot = await db.collection('users').get();

    const updatePromises = usersSnapshot.docs.map(async (userDoc) => {
      const userId = userDoc.id;

      const matchesSnapshot = await db
        .collection('user_job_matches')
        .where('userId', '==', userId)
        .get();

      const applicationsSnapshot = await db
        .collection('applications')
        .where('userId', '==', userId)
        .get();

      const interviewsCount = applicationsSnapshot.docs.filter(
        doc => doc.data().status === 'interviewing'
      ).length;

      await userDoc.ref.update({
        'stats.jobsFound': matchesSnapshot.size,
        'stats.jobsApplied': applicationsSnapshot.size,
        'stats.interviews': interviewsCount,
      });
    });

    await Promise.all(updatePromises);
  });
===== ./next-env.d.ts =====
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

===== ./python-service/autonomous_applier.py =====
#!/usr/bin/env python3
"""
=============================================================================
FILE 4: python-service/autonomous_applier.py
FULLY AUTONOMOUS APPLICATION ENGINE
- LinkedIn Easy Apply (1-click)
- Smart form detection with DeepSeek
- Visual verification
- Zero human intervention
=============================================================================
"""

import asyncio
import os
import httpx
import base64
import logging
from pathlib import Path
from typing import Dict, Optional, List
from datetime import datetime, timezone

from playwright.async_api import async_playwright, Page, TimeoutError as PlaywrightTimeout
from dotenv import load_dotenv
import firebase_admin
from firebase_admin import firestore

logger = logging.getLogger(__name__)

# Load environment
env_path = Path(__file__).parent.parent / '.env.local'
load_dotenv(dotenv_path=env_path)

DEEPSEEK_API_KEY = os.getenv('DEEPSEEK_API_KEY')
DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions'

if not firebase_admin._apps:
    from firebase_admin import credentials
    cred = credentials.Certificate('serviceAccountKey.json')
    firebase_admin.initialize_app(cred)

db = firestore.client()


class AutonomousApplier:
    """
    Fully autonomous job application system
    Handles: LinkedIn Easy Apply, ATS forms, custom portals
    """
    
    def __init__(self):
        self.browser = None
        self.context = None
        self.linkedin_session = None
    
    async def initialize(self, headless: bool = True):
        """Initialize browser"""
        playwright = await async_playwright().start()
        
        self.browser = await playwright.chromium.launch(
            headless=headless,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--disable-dev-shm-usage',
                '--no-sandbox'
            ]
        )
        
        self.context = await self.browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36'
        )
        
        logger.info("âœ… Autonomous applier initialized")
    
    async def close(self):
        """Close browser"""
        if self.browser:
            await self.browser.close()
    
    async def apply_autonomous(
        self, 
        job_url: str, 
        user_profile: Dict,
        app_id: str
    ) -> Dict:
        """
        Apply to job with ZERO human intervention
        
        Returns:
            {
                'success': bool,
                'method': str,  # 'linkedin_easy', 'ats_form', 'custom'
                'confirmation_code': str,
                'screenshot': str (base64),
                'error': str (if failed)
            }
        """
        page = await self.context.new_page()
        
        try:
            await self._update_progress(app_id, 'processing', 30, 'Opening application...')
            
            # Navigate to job
            await page.goto(job_url, wait_until='domcontentloaded', timeout=60000)
            await page.wait_for_timeout(3000)
            
            # Detect application type
            app_type = await self._detect_application_type(page)
            logger.info(f"ðŸ“‹ Application type: {app_type}")
            
            await self._update_progress(app_id, 'processing', 40, f'Detected: {app_type}')
            
            # Route to appropriate handler
            if app_type == 'linkedin_easy':
                result = await self._apply_linkedin_easy(page, user_profile, app_id)
            
            elif app_type == 'greenhouse':
                result = await self._apply_greenhouse(page, user_profile, app_id)
            
            elif app_type == 'lever':
                result = await self._apply_lever(page, user_profile, app_id)
            
            elif app_type == 'ashby':
                result = await self._apply_ashby(page, user_profile, app_id)
            
            else:
                # Fallback: Smart AI-driven application
                result = await self._apply_with_ai_vision(page, user_profile, app_id)
            
            return result
            
        except Exception as e:
            logger.error(f"âŒ Autonomous application failed: {e}")
            return {
                'success': False,
                'error': str(e)
            }
        
        finally:
            await page.close()
    
    async def _detect_application_type(self, page: Page) -> str:
        """Detect which ATS or platform is being used"""
        url = page.url.lower()
        
        # LinkedIn Easy Apply
        if 'linkedin.com/jobs' in url:
            easy_apply_btn = await page.locator('button:has-text("Easy Apply")').count()
            if easy_apply_btn > 0:
                return 'linkedin_easy'
        
        # Greenhouse
        if 'greenhouse.io' in url or 'boards.greenhouse.io' in url:
            return 'greenhouse'
        
        # Check for embedded Greenhouse iframe
        greenhouse_iframe = await page.locator('iframe[src*="greenhouse"]').count()
        if greenhouse_iframe > 0:
            return 'greenhouse'
        
        # Lever
        if 'lever.co' in url or 'jobs.lever.co' in url:
            return 'lever'
        
        # Ashby
        if 'ashbyhq.com' in url or 'jobs.ashbyhq.com' in url:
            return 'ashby'
        
        # Workday (usually requires login - skip for now)
        if 'myworkday.com' in url or 'workday.com' in url:
            return 'workday'
        
        return 'unknown'
    
    # =========================================================================
    # LinkedIn Easy Apply Handler
    # =========================================================================
    
    async def _apply_linkedin_easy(
        self, 
        page: Page, 
        profile: Dict,
        app_id: str
    ) -> Dict:
        """Handle LinkedIn Easy Apply (multi-step modal)"""
        try:
            logger.info("ðŸ”µ Starting LinkedIn Easy Apply...")
            
            await self._update_progress(app_id, 'processing', 50, 'LinkedIn Easy Apply detected')
            
            # Click "Easy Apply" button
            easy_apply_btn = page.locator('button:has-text("Easy Apply")').first
            await easy_apply_btn.click()
            await page.wait_for_timeout(2000)
            
            step = 1
            max_steps = 10  # Prevent infinite loops
            
            while step <= max_steps:
                logger.info(f"  Step {step}...")
                
                await self._update_progress(
                    app_id, 
                    'processing', 
                    50 + (step * 4), 
                    f'LinkedIn step {step}'
                )
                
                # Fill current page
                await self._fill_linkedin_modal_page(page, profile)
                
                # Wait for page to process
                await page.wait_for_timeout(1500)
                
                # Check for buttons
                next_btn = page.locator('button:has-text("Next"), button[aria-label="Continue to next step"]')
                review_btn = page.locator('button:has-text("Review")')
                submit_btn = page.locator('button:has-text("Submit application"), button[aria-label="Submit application"]')
                
                # Priority: Submit > Review > Next
                if await submit_btn.count() > 0:
                    logger.info("  âœ… Submitting application...")
                    await submit_btn.first.click()
                    await page.wait_for_timeout(3000)
                    
                    # Verify submission
                    success = await self._verify_linkedin_success(page)
                    
                    if success:
                        screenshot = await page.screenshot()
                        
                        await self._update_progress(app_id, 'applied', 100, 'Success!')
                        
                        return {
                            'success': True,
                            'method': 'linkedin_easy',
                            'confirmation_code': 'LinkedIn Application Submitted',
                            'screenshot': base64.b64encode(screenshot).decode()
                        }
                    else:
                        return {'success': False, 'error': 'No confirmation detected'}
                
                elif await review_btn.count() > 0:
                    await review_btn.first.click()
                    await page.wait_for_timeout(1500)
                    step += 1
                
                elif await next_btn.count() > 0:
                    await next_btn.first.click()
                    await page.wait_for_timeout(1500)
                    step += 1
                
                else:
                    logger.warning("  âš ï¸ No action button found")
                    break
            
            return {'success': False, 'error': f'Stuck at step {step}'}
            
        except Exception as e:
            logger.error(f"âŒ LinkedIn Easy Apply error: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _fill_linkedin_modal_page(self, page: Page, profile: Dict):
        """Fill fields on current LinkedIn modal page"""
        try:
            # Text inputs
            text_inputs = await page.locator('input[type="text"]:visible, input[type="email"]:visible').all()
            
            for input_field in text_inputs:
                try:
                    label_text = await self._get_field_label(page, input_field)
                    if not label_text:
                        continue
                    
                    label_lower = label_text.lower()
                    
                    # Determine value based on label
                    value = None
                    
                    if 'first name' in label_lower or label_lower == 'first':
                        value = profile.get('firstName', '')
                    elif 'last name' in label_lower or label_lower == 'last':
                        value = profile.get('lastName', '')
                    elif 'email' in label_lower:
                        value = profile.get('email', '')
                    elif 'phone' in label_lower or 'mobile' in label_lower:
                        value = self._format_phone(profile.get('phone', ''))
                    elif 'city' in label_lower or 'location' in label_lower:
                        value = profile.get('location', '')
                    elif 'linkedin' in label_lower or 'profile' in label_lower:
                        value = profile.get('linkedinUrl', '')
                    
                    if value:
                        await input_field.fill(value)
                        await page.wait_for_timeout(300)
                
                except:
                    continue
            
            # Dropdowns/Selects
            selects = await page.locator('select:visible').all()
            
            for select in selects:
                try:
                    label_text = await self._get_field_label(page, select)
                    if not label_text:
                        continue
                    
                    label_lower = label_text.lower()
                    
                    # Handle common dropdowns
                    if 'experience' in label_lower or 'years' in label_lower:
                        years = profile.get('yearsOfExperience', 10)
                        # Select closest option
                        options = await select.locator('option').all()
                        for option in options:
                            text = await option.inner_text()
                            if str(years) in text or f'{years}+' in text:
                                await select.select_option(value=await option.get_attribute('value'))
                                break
                    
                    elif 'authorized' in label_lower or 'work in' in label_lower:
                        eligible = profile.get('eligibleToWorkInUS', True)
                        await select.select_option(label='Yes' if eligible else 'No')
                    
                    elif 'sponsorship' in label_lower:
                        requires = profile.get('requiresSponsorship', False)
                        await select.select_option(label='No' if not requires else 'Yes')
                    
                except:
                    continue
            
            # File uploads (resume)
            file_inputs = await page.locator('input[type="file"]:visible').all()
            
            resume_url = profile.get('resumeUrl')
            if resume_url and file_inputs:
                resume_path = await self._download_resume(
                    resume_url, 
                    f"{profile.get('firstName', 'Resume')}_{profile.get('lastName', '')}"
                )
                
                if resume_path and len(file_inputs) > 0:
                    try:
                        await file_inputs[0].set_input_files(resume_path)
                        await page.wait_for_timeout(2000)
                        logger.info("  âœ… Resume uploaded")
                    except:
                        pass
        
        except Exception as e:
            logger.error(f"Error filling LinkedIn modal: {e}")
    
    async def _verify_linkedin_success(self, page: Page) -> bool:
        """Verify LinkedIn application was submitted"""
        try:
            # Wait for confirmation message
            await page.wait_for_timeout(2000)
            
            # Check for success indicators
            success_selectors = [
                'text="Application sent"',
                'text="Your application was sent"',
                'text="Application submitted"',
                '[data-test-modal-id="application-sent-confirmation"]',
                '.artdeco-inline-feedback--success'
            ]
            
            for selector in success_selectors:
                if await page.locator(selector).count() > 0:
                    logger.info("âœ… LinkedIn confirmation detected")
                    return True
            
            # Check page content
            content = await page.content()
            if any(phrase in content.lower() for phrase in [
                'application sent', 'application submitted', 'your application was sent'
            ]):
                return True
            
            return False
            
        except:
            return False
    
    # =========================================================================
    # Greenhouse Handler
    # =========================================================================
    
    async def _apply_greenhouse(
        self, 
        page: Page, 
        profile: Dict,
        app_id: str
    ) -> Dict:
        """Handle Greenhouse applications"""
        try:
            logger.info("ðŸŒ¿ Starting Greenhouse application...")
            
            await self._update_progress(app_id, 'processing', 50, 'Filling Greenhouse form')
            
            # Fill basic fields
            await self._fill_basic_form(page, profile)
            
            # Upload resume
            resume_url = profile.get('resumeUrl')
            if resume_url:
                await self._upload_resume_to_form(page, resume_url, profile)
            
            # Handle custom questions with DeepSeek
            await self._handle_custom_questions_ai(page, profile)
            
            # Submit
            submit_btn = await self._find_submit_button(page)
            if submit_btn:
                await submit_btn.click()
                await page.wait_for_timeout(3000)
                
                success = await self._verify_generic_success(page)
                
                if success:
                    screenshot = await page.screenshot()
                    await self._update_progress(app_id, 'applied', 100, 'Success!')
                    
                    return {
                        'success': True,
                        'method': 'greenhouse',
                        'screenshot': base64.b64encode(screenshot).decode()
                    }
            
            return {'success': False, 'error': 'Could not submit'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    # =========================================================================
    # AI Vision-Driven Application (Fallback)
    # =========================================================================
    
    async def _apply_with_ai_vision(
        self, 
        page: Page, 
        profile: Dict,
        app_id: str
    ) -> Dict:
        """
        Use DeepSeek to visually understand and fill the form
        """
        try:
            logger.info("ðŸ¤– Using AI vision to fill form...")
            
            await self._update_progress(app_id, 'processing', 60, 'AI analyzing form')
            
            # Take screenshot
            screenshot = await page.screenshot()
            screenshot_b64 = base64.b64encode(screenshot).decode()
            
            # Ask DeepSeek to analyze the form
            form_analysis = await self._analyze_form_with_deepseek(screenshot_b64, page.url)
            
            if not form_analysis:
                return {'success': False, 'error': 'AI could not analyze form'}
            
            logger.info(f"  AI detected {len(form_analysis.get('fields', []))} fields")
            
            # Fill fields based on AI instructions
            await self._execute_ai_fill_instructions(page, form_analysis, profile)
            
            # Upload resume if needed
            if form_analysis.get('needs_resume'):
                resume_url = profile.get('resumeUrl')
                if resume_url:
                    await self._upload_resume_to_form(page, resume_url, profile)
            
            # Submit
            submit_selector = form_analysis.get('submit_button')
            if submit_selector:
                try:
                    await page.locator(submit_selector).click()
                    await page.wait_for_timeout(3000)
                    
                    success = await self._verify_generic_success(page)
                    
                    if success:
                        final_screenshot = await page.screenshot()
                        await self._update_progress(app_id, 'applied', 100, 'Success!')
                        
                        return {
                            'success': True,
                            'method': 'ai_vision',
                            'screenshot': base64.b64encode(final_screenshot).decode()
                        }
                except:
                    pass
            
            return {'success': False, 'error': 'Could not submit'}
            
        except Exception as e:
            logger.error(f"AI vision application error: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _analyze_form_with_deepseek(self, screenshot_b64: str, url: str) -> Optional[Dict]:
        """
        Use DeepSeek to understand form structure
        Note: DeepSeek doesn't support vision yet, so we'll use text-based analysis
        For vision, you'd need to switch to GPT-4V or Claude
        """
        try:
            # Get page HTML instead (DeepSeek workaround)
            # In production, use GPT-4V for actual vision analysis
            
            # For now, return a basic structure
            return {
                'fields': [],
                'needs_resume': True,
                'submit_button': 'button[type="submit"], input[type="submit"]'
            }
            
        except Exception as e:
            logger.error(f"Form analysis error: {e}")
            return None
    
    async def _execute_ai_fill_instructions(
        self, 
        page: Page, 
        instructions: Dict,
        profile: Dict
    ):
        """Execute AI-generated fill instructions"""
        # This would contain AI-driven field filling
        # Fallback to basic filling for now
        await self._fill_basic_form(page, profile)
    
    # =========================================================================
    # Helper Functions
    # =========================================================================
    
    async def _fill_basic_form(self, page: Page, profile: Dict):
        """Fill standard form fields"""
        # First name
        await self._fill_field_by_selectors(
            page,
            ['input[name*="first" i]', 'input[id*="first" i]', 'input[placeholder*="first" i]'],
            profile.get('firstName', '')
        )
        
        # Last name
        await self._fill_field_by_selectors(
            page,
            ['input[name*="last" i]', 'input[id*="last" i]'],
            profile.get('lastName', '')
        )
        
        # Email
        await self._fill_field_by_selectors(
            page,
            ['input[type="email"]', 'input[name*="email" i]'],
            profile.get('email', '')
        )
        
        # Phone
        await self._fill_field_by_selectors(
            page,
            ['input[type="tel"]', 'input[name*="phone" i]'],
            self._format_phone(profile.get('phone', ''))
        )
    
    async def _fill_field_by_selectors(
        self, 
        page: Page, 
        selectors: List[str], 
        value: str
    ):
        """Try multiple selectors to fill a field"""
        if not value:
            return
        
        for selector in selectors:
            try:
                field = page.locator(selector).first
                if await field.count() > 0 and await field.is_visible():
                    await field.fill(value)
                    return
            except:
                continue
    
    async def _upload_resume_to_form(
        self, 
        page: Page, 
        resume_url: str,
        profile: Dict
    ):
        """Download and upload resume"""
        try:
            resume_path = await self._download_resume(
                resume_url,
                f"{profile.get('firstName', 'Resume')}_{profile.get('lastName', '')}"
            )
            
            if not resume_path:
                return
            
            # Find resume upload field
            file_inputs = await page.locator('input[type="file"]').all()
            
            for file_input in file_inputs:
                try:
                    # Check if it's resume field (not cover letter)
                    input_id = await file_input.get_attribute('id') or ''
                    input_name = await file_input.get_attribute('name') or ''
                    
                    if 'cover' in input_id.lower() or 'cover' in input_name.lower():
                        continue
                    
                    await file_input.set_input_files(resume_path)
                    await page.wait_for_timeout(2000)
                    logger.info("  âœ… Resume uploaded")
                    return
                except:
                    continue
        
        except Exception as e:
            logger.error(f"Resume upload error: {e}")
    
    async def _download_resume(self, url: str, filename_prefix: str) -> Optional[str]:
        """Download resume from URL"""
        try:
            temp_dir = Path("temp_resumes")
            temp_dir.mkdir(exist_ok=True)
            
            async with httpx.AsyncClient() as client:
                response = await client.get(url, timeout=60.0, follow_redirects=True)
                
                if response.status_code == 200:
                    ext = '.pdf' if 'pdf' in url.lower() else '.docx'
                    safe_name = "".join(c for c in filename_prefix if c.isalnum() or c in "_-")
                    file_path = temp_dir / f"{safe_name}{ext}"
                    
                    file_path.write_bytes(response.content)
                    return str(file_path)
            
            return None
        
        except Exception as e:
            logger.error(f"Resume download error: {e}")
            return None
    
    async def _handle_custom_questions_ai(self, page: Page, profile: Dict):
        """Handle custom questions using DeepSeek"""
        # Implementation similar to your existing greenhouse_applier.py
        pass
    
    async def _find_submit_button(self, page: Page):
        """Find the submit button"""
        selectors = [
            'button[type="submit"]',
            'input[type="submit"]',
            'button:has-text("Submit")',
            'button:has-text("Apply")',
            'button#submit_app'
        ]
        
        for selector in selectors:
            btn = page.locator(selector).first
            if await btn.count() > 0:
                return btn
        
        return None
    
    async def _verify_generic_success(self, page: Page) -> bool:
        """Verify application submission"""
        try:
            await page.wait_for_timeout(2000)
            
            content = await page.content()
            content_lower = content.lower()
            
            success_phrases = [
                'application submitted',
                'thank you for applying',
                'application received',
                'successfully submitted',
                'your application has been sent'
            ]
            
            return any(phrase in content_lower for phrase in success_phrases)
        
        except:
            return False
    
    async def _get_field_label(self, page: Page, field) -> Optional[str]:
        """Get label text for a form field"""
        try:
            field_id = await field.get_attribute('id')
            if field_id:
                label = await page.locator(f'label[for="{field_id}"]').first
                if await label.count() > 0:
                    return await label.inner_text()
            
            # Try parent
            parent = await field.evaluate_handle('el => el.closest("div, label")')
            if parent:
                text = await parent.inner_text()
                return text.strip()
        
        except:
            pass
        
        return None
    
    def _format_phone(self, phone: str) -> str:
        """Format phone number"""
        if not phone:
            return ""
        
        import re
        digits = re.sub(r'\D', '', phone)
        
        if len(digits) == 10:
            return f"({digits[:3]}) {digits[3:6]}-{digits[6:]}"
        elif len(digits) == 11 and digits[0] == '1':
            return f"({digits[1:4]}) {digits[4:7]}-{digits[7:]}"
        
        return phone
    
    async def _update_progress(
        self, 
        app_id: str, 
        status: str, 
        progress: int,
        message: str
    ):
        """Update application progress in Firebase"""
        try:
            db.collection('applications').document(app_id).update({
                'status': status,
                'progress': progress,
                'progressMessage': message,
                'updatedAt': firestore.SERVER_TIMESTAMP
            })
        except:
            pass


# =========================================================================
# Main execution function
# =========================================================================

async def process_autonomous_applications():
    """Main function to process pending auto-apply jobs"""
    applier = AutonomousApplier()
    
    try:
        await applier.initialize(headless=True)  # Set to False for debugging
        
        # Get pending applications
        apps_ref = db.collection('applications')
        pending = apps_ref.where('method', '==', 'auto-apply').where('status', '==', 'queued').limit(5).stream()
        
        for app_doc in pending:
            app_data = app_doc.to_dict()
            app_data['id'] = app_doc.id
            
            logger.info(f"\n{'='*70}")
            logger.info(f"ðŸ“‹ Processing: {app_data.get('jobTitle')}")
            logger.info(f"ðŸ¢ Company: {app_data.get('company')}")
            logger.info(f"{'='*70}")
            
            # Get user profile
            user_id = app_data.get('userId')
            user_doc = db.collection('users').document(user_id).get()
            
            if not user_doc.exists:
                logger.error(f"âŒ User not found: {user_id}")
                continue
            
            user_profile = user_doc.to_dict()
            
            # Apply
            result = await applier.apply_autonomous(
                job_url=app_data.get('jobUrl'),
                user_profile=user_profile,
                app_id=app_data['id']
            )
            
            if result['success']:
                logger.info(f"âœ… Application successful!")
                db.collection('applications').document(app_data['id']).update({
                    'status': 'applied',
                    'appliedAt': firestore.SERVER_TIMESTAMP,
                    'confirmationCode': result.get('confirmation_code', ''),
                    'applicationMethod': result.get('method', 'autonomous')
                })
            else:
                logger.error(f"âŒ Application failed: {result.get('error')}")
                db.collection('applications').document(app_data['id']).update({
                    'status': 'failed',
                    'errorMessage': result.get('error')
                })
            
            # Wait between applications
            await asyncio.sleep(10)
    
    finally:
        await applier.close()


if __name__ == "__main__":
    asyncio.run(process_autonomous_applications())
===== ./python-service/greenhouse_applier.py =====
#!/usr/bin/env python3
"""
=============================================================================
JOBHUNT AI - SMART APPLICATION ENGINE V2.0 (FULLY FIXED)
- FIXED: Resume upload now avoids cover letter fields
- FIXED: Enhanced fuzzy matching for dropdowns
- FIXED: Phone number formatting
- FIXED: Safe frame iteration
- FIXED: AI response caching
- Handles Greenhouse, Lever, Ashby, and custom forms
- Auto-renames resume to Candidate Name
- REVIEW MODE: Fills form, highlights button, pauses for manual submit
- REAL-TIME: Progress tracking and status updates
=============================================================================
"""

import asyncio
import logging
import os
import sys
import httpx
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional, List
from difflib import SequenceMatcher

# Load environment variables
from dotenv import load_dotenv

import firebase_admin
from firebase_admin import credentials, firestore
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout

def cleanup_old_screenshots(days_old: int = 7):
    """Delete screenshot files older than specified days"""
    import os
    from datetime import datetime
    from pathlib import Path

    screenshot_dir = Path.cwd()  # Screenshots are saved in current directory
    for screenshot_file in screenshot_dir.glob("screenshot_*.png"):
        try:
            file_stat = screenshot_file.stat()
            file_age = datetime.now() - datetime.fromtimestamp(file_stat.st_mtime)
            if file_age.days > days_old:
                os.remove(screenshot_file)
                logger.debug(f"Deleted old screenshot: {screenshot_file.name}")
        except Exception as e:
            logger.debug(f"Failed to delete screenshot {screenshot_file}: {e}")

# ============================================================================
# Configuration
# ============================================================================

env_path = Path(__file__).parent.parent / '.env.local'
load_dotenv(dotenv_path=env_path)

DEEPSEEK_API_KEY = os.getenv('DEEPSEEK_API_KEY')
DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions'

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Firebase initialization
if not firebase_admin._apps:
    cred_path = os.getenv('FIREBASE_CREDENTIALS_PATH', 'serviceAccountKey.json')
    if not os.path.exists(cred_path):
        logger.error(f"âŒ Firebase credentials not found at: {cred_path}")
        sys.exit(1)
    cred = credentials.Certificate(cred_path)
    firebase_admin.initialize_app(cred)
db = firestore.client()

# AI Cache to prevent redundant API calls
AI_CACHE = {}

# AI Cache with Firestore persistence
async def get_cached_answer(cache_key: str) -> Optional[str]:
    """Get cached answer from Firestore"""
    try:
        cached_ref = db.collection('ai_cache').document(cache_key)
        doc = await asyncio.to_thread(cached_ref.get)
        if doc.exists:
            data = doc.to_dict()
            # Optional: check timestamp if we want expiration
            return data.get('answer')
    except Exception as e:
        logger.debug(f"Cache read error: {e}")
    return None

async def set_cached_answer(cache_key: str, answer: str):
    """Save answer to Firestore cache"""
    try:
        cached_ref = db.collection('ai_cache').document(cache_key)
        await asyncio.to_thread(cached_ref.set, {
            'answer': answer,
            'cachedAt': firestore.SERVER_TIMESTAMP,
            'question': cache_key[:200]  # store truncated question
        })
    except Exception as e:
        logger.debug(f"Cache write error: {e}")

# ============================================================================
# Real-time Progress Updates
# ============================================================================

async def update_application_progress(app_id: str, status: str, progress: int, message: str = ""):
    """Update application progress in real-time"""
    try:
        update_data = {
            'status': status,
            'progress': progress,  # 0-100
            'progressMessage': message,
            'updatedAt': firestore.SERVER_TIMESTAMP
        }
        
        if status == 'applied':
            update_data['appliedAt'] = firestore.SERVER_TIMESTAMP
        
        db.collection('applications').document(app_id).update(update_data)
        logger.info(f"ðŸ“Š Progress: {progress}% - {message}")
    
    except Exception as e:
        logger.error(f"Error updating progress: {e}")


# ============================================================================
# AI Question Answering (with Caching & Retry)
# ============================================================================

async def answer_question_with_ai(question: str, user_profile: Dict, max_retries: int = 3) -> str:
    """Use DeepSeek AI to answer custom application questions (ENHANCED with retry)"""
    
    # 1. Check Cache
    cache_key = question.lower().strip()[:100]  # Use first 100 chars as key
    if cache_key in AI_CACHE:
        logger.info(f"  ðŸ’¾ Cached Answer (memory): {AI_CACHE[cache_key]}")
        return AI_CACHE[cache_key]

    # Check Firestore persistent cache
    cached_answer = await get_cached_answer(cache_key)
    if cached_answer:
        logger.info(f"  ðŸ’¾ Cached Answer (firestore): {cached_answer}")
        AI_CACHE[cache_key] = cached_answer
        return cached_answer

    if not DEEPSEEK_API_KEY:
        logger.error("âŒ DeepSeek API Key is missing! Check .env.local")
        return "Not specified"

    profile_summary = f"""
Candidate: {user_profile.get('firstName', '')} {user_profile.get('lastName', '')}
Current Title: {user_profile.get('currentTitle', 'Senior Product Manager')}
Experience: {user_profile.get('yearsOfExperience', 10)} years
Location: {user_profile.get('location', '')}
Email: {user_profile.get('email', '')}
Eligible to work in US: {user_profile.get('eligibleToWorkInUS', True)}
Requires Sponsorship: {user_profile.get('requiresSponsorship', False)}
Education: {user_profile.get('educationSummary', 'MBA from Indiana University')}
Key Skills: ML Engineering, Product Management, Python, Azure ML, Connected Vehicles
"""

    prompt = f"""You are filling out a job application form. Answer this question based on the candidate's profile.

CANDIDATE PROFILE:
{profile_summary}

QUESTION: {question}

INSTRUCTIONS:
- For yes/no questions, answer ONLY "Yes" or "No"
- For work authorization: Answer "Yes" if eligible to work in US
- For sponsorship: Answer "No" if does not require sponsorship
- For experience questions: Use the years of experience from profile
- For dropdowns asking for options: Choose the most appropriate single option
- Keep answers concise (1-3 words for short answers, 1-2 sentences for open-ended)
- Be professional and confident

ANSWER (no explanation, just the answer):"""

    # Retry logic with exponential backoff
    for attempt in range(max_retries):
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    DEEPSEEK_API_URL,
                    headers={
                        'Authorization': f'Bearer {DEEPSEEK_API_KEY}',
                        'Content-Type': 'application/json'
                    },
                    json={
                        'model': 'deepseek-chat',
                        'messages': [{'role': 'user', 'content': prompt}],
                        'temperature': 0.1,
                        'max_tokens': 100
                    },
                    timeout=30.0
                )
                
                if response.status_code == 200:
                    result = response.json()
                    answer = result['choices'][0]['message']['content'].strip()
                    answer = answer.replace('"', '').replace("'", '')
                    if answer.lower().startswith('answer:'):
                        answer = answer[7:].strip()
                    
                    logger.info(f"  ðŸ¤– AI Answer: {answer}")
                    # Update Cache
                    AI_CACHE[cache_key] = answer
                    # Update Firestore cache (fire and forget)
                    asyncio.create_task(set_cached_answer(cache_key, answer))
                    return answer
                elif response.status_code == 429:
                    # Rate limited - wait and retry
                    wait_time = 2 ** attempt  # Exponential backoff: 1s, 2s, 4s
                    logger.warning(f"  â³ Rate limited, retrying in {wait_time}s...")
                    await asyncio.sleep(wait_time)
                    continue
                else:
                    logger.error(f"DeepSeek API error: {response.status_code}")
                    return "Not specified"
        
        except asyncio.TimeoutError:
            if attempt < max_retries - 1:
                logger.warning(f"  â±ï¸  Timeout, retrying ({attempt + 1}/{max_retries})...")
                await asyncio.sleep(2 ** attempt)
                continue
            logger.error("AI request timed out after retries")
            return "Not specified"
        except Exception as e:
            logger.error(f"Error calling AI: {e}")
            if attempt < max_retries - 1:
                await asyncio.sleep(2 ** attempt)
                continue
            return "Not specified"
    
    return "Not specified"


# ============================================================================
# Resume Management
# ============================================================================

async def download_resume(resume_url: str, filename_prefix: str) -> Optional[str]:
    """Download resume and save with professional filename"""
    try:
        temp_dir = Path("temp_resumes")
        temp_dir.mkdir(exist_ok=True)
        
        logger.info(f"  ðŸ“¥ Downloading resume from Firebase...")
        
        async with httpx.AsyncClient() as client:
            response = await client.get(resume_url, timeout=60.0, follow_redirects=True)
            
            if response.status_code == 200:
                file_ext = '.pdf'
                if 'docx' in resume_url.lower():
                    file_ext = '.docx'
                
                # Sanitize filename
                safe_name = "".join(x for x in filename_prefix if x.isalnum() or x in "_-")
                file_path = temp_dir / f"{safe_name}{file_ext}"
                
                file_path.write_bytes(response.content)
                
                file_size = len(response.content) / 1024
                logger.info(f"  âœ… Resume saved as: {file_path.name} ({file_size:.1f} KB)")
                return str(file_path)
            else:
                logger.error(f"Failed to download resume: HTTP {response.status_code}")
                return None
    
    except Exception as e:
        logger.error(f"Error downloading resume: {e}")
        return None


# ============================================================================
# Helper Functions
# ============================================================================

def format_phone_number(phone: str) -> str:
    """Format phone to (XXX) XXX-XXXX"""
    if not phone:
        return ""
    digits = re.sub(r'\D', '', phone)  # Remove non-digits
    if len(digits) == 10:
        return f"({digits[:3]}) {digits[3:6]}-{digits[6:]}"
    elif len(digits) == 11 and digits[0] == '1':
        return f"({digits[1:4]}) {digits[4:7]}-{digits[7:]}"
    return phone  # Return as-is if format unknown

def safe_frames(page) -> List:
    """Safely iterate frames, skipping detached ones"""
    frames = []
    for frame in page.frames:
        try:
            # Test if frame is still attached
            _ = frame.url
            frames.append(frame)
        except:
            continue
    return frames

async def get_pending_applications():
    """Fetch applications that need processing"""
    try:
        applications = (
            db.collection('applications')
            .where('method', '==', 'auto-apply')
            .where('status', 'in', ['pending', 'queued'])
            .order_by('appliedAt', direction=firestore.Query.DESCENDING)
            .limit(10)
            .stream()
        )
        
        results = []
        for app in applications:
            data = app.to_dict()
            data['id'] = app.id
            results.append(data)
        
        logger.info(f"Found {len(results)} pending applications")
        return results
    
    except Exception as e:
        logger.error(f"Error fetching applications: {e}")
        return []


async def get_user_profile(user_id: str) -> Dict:
    """Fetch user profile matching YOUR Firebase schema"""
    try:
        user_doc = db.collection('users').document(user_id).get()
        
        if not user_doc.exists:
            logger.error(f"User {user_id} not found")
            return {}
        
        data = user_doc.to_dict()
        
        display_name = data.get('displayName', 'Chandra Talluri')
        name_parts = display_name.strip().split()
        
        if len(name_parts) >= 2:
            data['firstName'] = name_parts[0]
            data['lastName'] = ' '.join(name_parts[1:])
        else:
            data['firstName'] = name_parts[0] if name_parts else 'Chandra'
            data['lastName'] = 'Talluri'
        
        work_history = data.get('workHistory', [])
        if work_history and len(work_history) > 0:
            current_job = work_history[0]
            data['yearsOfExperience'] = current_job.get('yearsOfExperience', 10)
        else:
            data['yearsOfExperience'] = 10
        
        education = data.get('education', [])
        if education:
            edu = education[0]
            data['educationSummary'] = f"{edu.get('degree', 'MBA')} from {edu.get('school', 'Indiana University')}"
        else:
            data['educationSummary'] = 'MBA from Indiana University'
        
        data['currentTitle'] = data.get('currentTitle', 'Senior Product Manager')
        data['email'] = data.get('email', '')
        data['phone'] = data.get('phone', '')
        data['location'] = data.get('location', 'Detroit')
        data['resumeUrl'] = data.get('resumeUrl', '')
        data['eligibleToWorkInUS'] = data.get('eligibleToWorkInUS', True)
        data['requiresSponsorship'] = data.get('requiresSponsorship', False)
        data['autoSubmitEnabled'] = data.get('autoSubmitEnabled', False)
        
        # Load Custom Questions from Dashboard
        data['custom_rules'] = {}
        if 'customQuestions' in data and isinstance(data['customQuestions'], list):
            for q in data['customQuestions']:
                if q.get('keyword') and q.get('answer'):
                    key = q['keyword'].lower().strip()
                    data['custom_rules'][key] = q['answer']
            logger.info(f"  ðŸ“‹ Loaded {len(data['custom_rules'])} custom Q&A rules")
        
        logger.info(f"âœ… Profile loaded: {data.get('firstName')} {data.get('lastName')}")
        
        return data
    
    except Exception as e:
        logger.error(f"Error fetching user profile: {e}")
        return {}


async def update_application_status(app_id: str, status: str, error_msg: str = None):
    """Update application status in Firebase"""
    try:
        update_data = {
            'status': status,
            'updatedAt': firestore.SERVER_TIMESTAMP
        }
        
        if error_msg:
            update_data['errorMessage'] = error_msg
        
        if status == 'applied':
            update_data['appliedAt'] = firestore.SERVER_TIMESTAMP
        
        db.collection('applications').document(app_id).update(update_data)
        logger.info(f"ðŸ“ Firebase updated: {status}")
    
    except Exception as e:
        logger.error(f"Error updating application: {e}")


# ============================================================================
# Application Automation
# ============================================================================

class SmartApplier:
    def __init__(self):
        self.browser = None
        self.context = None
        self.stats = {'processed': 0, 'successful': 0, 'failed': 0}
    
    async def initialize(self):
        """Initialize browser"""
        playwright = await async_playwright().start()
        
        self.browser = await playwright.chromium.launch(
            headless=False,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--disable-dev-shm-usage',
                '--no-sandbox'
            ]
        )
        
        self.context = await self.browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        )
        
        logger.info("ðŸŒ Browser initialized")
    
    async def close(self):
        """Close browser"""
        if self.browser:
            await self.browser.close()
            logger.info("ðŸŒ Browser closed")
    
    async def human_delay(self, min_ms: int = 500, max_ms: int = 1500):
        """Simulate human typing delay"""
        import random
        delay = random.uniform(min_ms, max_ms) / 1000
        await asyncio.sleep(delay)
    
    async def find_and_navigate_to_application_form(self, page) -> bool:
        """Smart navigation to find the actual application form"""
        try:
            logger.info(f"  ðŸ” Looking for application form...")
            
            # 1. Check for embedded iframes
            iframe_selectors = [
                'iframe[id="grnhse_iframe"]', 
                'iframe[src*="greenhouse"]',
                'iframe[src*="ashby"]',       
                'iframe[src*="lever"]',
                'iframe[id="gnewton_iframe"]'
            ]
            
            for selector in iframe_selectors:
                if await page.locator(selector).count() > 0:
                    logger.info(f"  âœ… Found embedded ATS form ({selector})")
                    return True

            async def is_form_present():
                if await page.locator('form:visible').count() > 0: return True
                if await page.locator('input[name="first_name"]').count() > 0: return True 
                if await page.locator('input[name="name"]').count() > 0: return True       
                for frame in safe_frames(page):
                    if await frame.locator('input[type="file"]').count() > 0: return True
                return False

            if await is_form_present():
                logger.info(f"  âœ… Found application form on page")
                return True
            
            # 2. Click "Apply" buttons
            apply_selectors = [
                'a[data-mapped="true"]',        
                'a:has-text("Apply to Job")',
                'a:has-text("Apply Now")',
                'button:has-text("Apply")',
                'a:has-text("Apply")',
                '[aria-label="Apply for this job"]',
                '#apply_button'
            ]
            
            for selector in apply_selectors:
                try:
                    if await page.locator(selector).count() > 0:
                        btn = page.locator(selector).first
                        if await btn.is_visible():
                            logger.info(f"  ðŸ‘† Clicking: {selector}")
                            
                            try:
                                async with page.expect_navigation(timeout=3000):
                                    await btn.click()
                            except:
                                await btn.click()
                            
                            # Wait for form or iframe
                            try:
                                await page.wait_for_selector(
                                    'input[type="file"], iframe[src*="greenhouse"], iframe[src*="lever"]',
                                    timeout=5000
                                )
                            except:
                                await page.wait_for_timeout(2000)
                            
                            if await is_form_present():
                                logger.info(f"  âœ… Application form loaded")
                                return True
                            
                            for frame_sel in iframe_selectors:
                                if await page.locator(frame_sel).count() > 0:
                                    logger.info(f"  âœ… Found embedded form after click")
                                    return True
                except:
                    continue
            
            logger.warning(f"  âš ï¸  No application form found")
            return False
        
        except Exception as e:
            logger.error(f"  âŒ Error finding form: {e}")
            return False
    
    async def upload_resume(self, page, resume_path: str):
        """Upload resume (FIXED: Avoids cover letter fields)"""
        try:
            # Gather all file inputs
            all_file_inputs = await page.query_selector_all('input[type="file"]')
            for frame in safe_frames(page):
                try:
                    all_file_inputs.extend(await frame.query_selector_all('input[type="file"]'))
                except: continue

            if not all_file_inputs:
                logger.warning("  âš ï¸  No file upload field found")
                return False
            
            # Strategy 1: Find RESUME-specific fields (strict keywords)
            resume_keywords = ['resume', 'cv', 'attach_resume', 'curriculum']
            cover_letter_keywords = ['cover', 'letter', 'motivation']
            
            resume_fields = []
            for file_input in all_file_inputs:
                name_attr = (await file_input.get_attribute('name') or '').lower()
                id_attr = (await file_input.get_attribute('id') or '').lower()
                combined = name_attr + id_attr
                
                # Skip cover letter fields explicitly
                if any(k in combined for k in cover_letter_keywords):
                    logger.debug(f"  â­ï¸  Skipping cover letter field: {name_attr or id_attr}")
                    continue
                
                # Match resume fields
                if any(k in combined for k in resume_keywords):
                    resume_fields.append((file_input, name_attr or id_attr))
            
            # Upload to first resume-specific field
            if resume_fields:
                field, field_name = resume_fields[0]
                await field.set_input_files(resume_path)
                await self.human_delay(2000, 3000)
                logger.info(f"  âœ… Resume uploaded to: {field_name}")
                return True
            
            # Strategy 2: Fallback to first non-cover-letter field
            for file_input in all_file_inputs:
                name_attr = (await file_input.get_attribute('name') or '').lower()
                id_attr = (await file_input.get_attribute('id') or '').lower()
                combined = name_attr + id_attr
                
                # Skip cover letter fields
                if any(k in combined for k in cover_letter_keywords):
                    continue
                
                # Upload here
                await file_input.set_input_files(resume_path)
                await self.human_delay(2000, 3000)
                logger.info(f"  âœ… Resume uploaded to generic field (avoided cover letter)")
                return True
            
            # Strategy 3: Last resort - use first field (warn user)
            if all_file_inputs:
                logger.warning("  âš ï¸  Could not identify resume field, using first available")
                await all_file_inputs[0].set_input_files(resume_path)
                await self.human_delay(2000, 3000)
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"  âŒ Error uploading resume: {e}")
            return False
    
    async def fill_basic_fields(self, page, user_data: Dict):
        """Fill basic application fields"""
        try:
            logger.info("  ðŸ“ Filling basic fields...")
            
            async def fill_anywhere(selectors, value):
                contexts = [page] + safe_frames(page)
                for ctx in contexts:
                    for selector in selectors:
                        try:
                            elements = await ctx.locator(selector).all()
                            for el in elements:
                                if await el.is_visible():
                                    type_attr = (await el.get_attribute('type') or 'text').lower()
                                    if type_attr in ['checkbox', 'radio', 'hidden', 'file', 'submit', 'button']:
                                        continue
                                    
                                    await el.fill(value)
                                    await self.human_delay()
                                    return True
                        except: continue
                return False

            await fill_anywhere([
                'input[name*="first" i][name*="name" i]', 'input[id*="first" i]', 
                '[autocomplete="given-name"]', 'input[name="name" i]'
            ], user_data.get('firstName', ''))

            await fill_anywhere([
                'input[name*="last" i]', 'input[id*="last" i]', 
                '[autocomplete="family-name"]'
            ], user_data.get('lastName', ''))

            await fill_anywhere([
                'input[type="email"]', 'input[name*="email" i]', '[autocomplete="email"]'
            ], user_data.get('email', ''))

            phone_formatted = format_phone_number(user_data.get('phone', ''))
            await fill_anywhere([
                'input[type="tel"]', 'input[name*="phone" i]', '[autocomplete="tel"]'
            ], phone_formatted)

            return True
        
        except Exception as e:
            logger.error(f"  âŒ Error filling basic fields: {e}")
            return False
    
    async def handle_custom_questions(self, page, user_data: Dict):
        """Handle custom application questions (Enhanced Fuzzy Matching)"""
        try:
            await page.wait_for_timeout(2000)
            
            all_fields = await page.query_selector_all('input:visible, select, textarea:visible')
            for frame in safe_frames(page):
                try:
                    frame_fields = await frame.query_selector_all('input:visible, select, textarea:visible')
                    all_fields.extend(frame_fields)
                except: continue
            
            logger.info(f"  ðŸ” Analyzing {len(all_fields)} form fields...")
            questions_answered = 0
            
            # Merge dashboard rules with defaults
            linkedin_url = user_data.get('linkedinUrl', 'https://linkedin.com/in/chandratalluri')
            if '/in/' not in linkedin_url:
                username = linkedin_url.split('/')[-1] or 'chandratalluri'
                linkedin_url = f'https://linkedin.com/in/{username}'

            rules = {
                'gender': 'Male', 
                'race': 'Asian', 
                'veteran': 'I am not a protected veteran',
                'disability': 'No',
                'authorized': 'Yes',
                'sponsorship': 'No',
                'relocate': 'Yes',
                'remote': 'Yes',
                'linkedin': linkedin_url,
                'website': 'https://chandratalluri.com',
                'portfolio': 'https://chandratalluri.com',
                'github': 'https://github.com/chandratalluri',
                'hear about': 'LinkedIn',
            }
            
            if 'custom_rules' in user_data:
                rules.update(user_data['custom_rules'])

            for field in all_fields: 
                try:
                    tag_name = await field.evaluate('el => el.tagName.toLowerCase()')
                    if tag_name != 'select':
                        if not await field.is_visible(): continue

                    try:
                        val = await field.input_value()
                        if val and len(val) > 0 and val != "0": continue
                    except: pass
                    
                    # Find Label
                    field_id = await field.get_attribute('id')
                    label_text = ""
                    
                    if field_id:
                        try:
                            label_elem = await page.query_selector(f'label[for="{field_id}"]')
                            if not label_elem:
                                for frame in safe_frames(page):
                                    label_elem = await frame.query_selector(f'label[for="{field_id}"]')
                                    if label_elem: break
                            if label_elem: label_text = await label_elem.inner_text()
                        except: pass
                    
                    if not label_text:
                        try:
                            parent = await field.evaluate_handle('el => el.closest("div, fieldset, label")')
                            if parent:
                                label_text = await parent.inner_text()
                                val_text = await field.evaluate('el => el.value')
                                label_text = label_text.replace(val_text, '')
                        except: pass
                    
                    if not label_text or len(label_text.strip()) < 3: continue
                    
                    label_clean = label_text.lower().strip()
                    logger.info(f"  â“ Question: {label_text[:60]}...")

                    # Match Answer
                    answer = None
                    for keyword, rule_answer in rules.items():
                        if keyword in label_clean:
                            logger.info(f"    âš¡ Fast-Matched '{keyword}': {rule_answer}")
                            answer = rule_answer
                            break
                    
                    if not answer:
                        answer = await answer_question_with_ai(label_text, user_data)

                    # Fill Field
                    if tag_name == 'select':
                        try:
                            options = await field.query_selector_all('option')
                            best_match = None
                            best_score = 0
                            
                            def similarity(a, b): return SequenceMatcher(None, a.lower(), b.lower()).ratio()

                            for opt in options:
                                opt_text = (await opt.inner_text()).strip()
                                opt_val = await opt.get_attribute('value')
                                if not opt_text or "select" in opt_text.lower(): continue
                                
                                score = similarity(answer, opt_text)
                                
                                if answer.lower() in opt_text.lower(): score += 0.3
                                if opt_text.lower() in answer.lower(): score += 0.3

                                if answer.lower() == 'yes' and any(w in opt_text.lower() for w in ['yes', 'authorized', 'eligible']): score = 1.0
                                if answer.lower() == 'no' and any(w in opt_text.lower() for w in ['no', 'not', 'none']): score = 1.0

                                if score > best_score:
                                    best_score = score
                                    best_match = opt_val

                            if best_match and best_score > 0.4:
                                await field.select_option(value=best_match, force=True)
                            else:
                                await field.select_option(index=1, force=True) 
                            
                            # Fire JS events
                            await field.evaluate("""
                                (el) => {
                                    el.dispatchEvent(new Event('change', { bubbles: true }));
                                    el.dispatchEvent(new Event('input', { bubbles: true }));
                                    el.dispatchEvent(new Event('blur', { bubbles: true }));
                                }
                            """)
                            
                            await self.human_delay(500, 1000)
                            questions_answered += 1
                        except: pass
                    
                    elif tag_name == 'input' and (await field.get_attribute('type')) in ['radio', 'checkbox']:
                        val = await field.get_attribute('value')
                        should_click = False
                        if answer.lower() in ['yes', 'true'] and ('yes' in label_clean or (val and 'yes' in val.lower())): should_click = True
                        elif answer.lower() in ['no', 'false'] and ('no' in label_clean or (val and 'no' in val.lower())): should_click = True
                        
                        if should_click:
                            await field.click(force=True)
                            questions_answered += 1
                    
                    else:
                        await field.fill(str(answer))
                        await field.dispatch_event('change')
                        await self.human_delay()
                        questions_answered += 1
                
                except Exception as inner_e:
                    continue
            
            logger.info(f"  âœ… Answered {questions_answered} custom questions")
            return True
        
# Continuation of handle_custom_questions error handler
        except Exception as e:
            logger.error(f"  âš ï¸  Error handling custom questions: {e}")
            return False

    async def find_submit_button(self, page):
        """Find submit button"""
        submit_selectors = [
            'button#submit_app', 'input[type="submit"]', 'button[type="submit"]',
            'button:has-text("Submit Application")', 'button:has-text("Submit")'
        ]
        
        for selector in submit_selectors:
            if await page.locator(selector).count() > 0: return page.locator(selector).first
        
        for frame in safe_frames(page):
            for selector in submit_selectors:
                try:
                    if await frame.locator(selector).count() > 0: return frame.locator(selector).first
                except: continue
        return None

    async def submit_application_auto(self, page, app_id: str):
        """Fully automatic submission"""
        try:
            submit_button = await self.find_submit_button(page)
            if not submit_button:
                logger.error("  âŒ Submit button not found")
                return False
            
            await submit_button.click()
            await page.wait_for_timeout(3000)
            
            # Verify
            confirmation_texts = ['submitted', 'thank you', 'received', 'success']
            content = (await page.content()).lower()
            if any(t in content for t in confirmation_texts):
                logger.info(f"  âœ… CONFIRMED: Application submitted!")
                await page.screenshot(path=f"screenshot_confirmed_{app_id}.png")
                return True
            
            logger.warning("  âš ï¸ Submitted but no confirmation found")
            return True
        except Exception as e:
            logger.error(f"Error in submission: {e}")
            return False

    async def submit_application_manual(self, page, app_id: str):
        """Manual review mode"""
        try:
            submit_button = await self.find_submit_button(page)
            if submit_button:
                await submit_button.scroll_into_view_if_needed()
                await submit_button.evaluate("el => el.style.border = '5px solid red'")
                logger.info("  âœ‹ PAUSED for manual review")
            
            print("\n" + "!"*60)
            print(f"  âš ï¸  FORM FILLED! Review and submit manually.")
            print("!"*60)
            await asyncio.to_thread(input, "  >> Press ENTER after submitting...")
            return True
        except Exception as e:
            logger.error(f"Error in manual submission: {e}")
            return False
    
    async def process_application(self, app_data: Dict):
        """Process a single job application"""
        app_id = app_data['id']
        resume_path = None
        
        try:
            job_url = app_data.get('jobUrl', '')
            job_title = app_data.get('jobTitle', 'Unknown')
            company = app_data.get('company', 'Unknown')
            user_id = app_data.get('userId', '')
            
            logger.info("\n" + "="*70)
            logger.info(f"ðŸ“‹ JOB: {job_title}")
            logger.info(f"ðŸ¢ COMPANY: {company}")
            logger.info("="*70)
            
            # 1. Profile
            await update_application_progress(app_id, 'processing', 10, 'Loading profile...')
            user_data = await get_user_profile(user_id)
            if not user_data.get('email'): return False
            
            # 2. Resume
            resume_url = user_data.get('resumeUrl')
            if resume_url:
                await update_application_progress(app_id, 'processing', 20, 'Downloading resume...')
                clean_name = f"{user_data.get('firstName', 'Candidate')}_{user_data.get('lastName', 'Resume')}"
                resume_path = await download_resume(resume_url, clean_name)
            
            # 3. Open Page
            await update_application_progress(app_id, 'processing', 30, f'Opening application...')
            page = await self.context.new_page()
            
            try:
                await page.goto(job_url, wait_until='domcontentloaded', timeout=60000)
                await page.wait_for_timeout(3000)
                
                # 4. Find Form
                await update_application_progress(app_id, 'processing', 40, 'Finding form...')
                if not await self.find_and_navigate_to_application_form(page):
                    await update_application_status(app_id, 'failed', 'Form not found')
                    self.stats['failed'] += 1
                    return False
                
                # 5. Basic Info
                await update_application_progress(app_id, 'processing', 50, 'Filling info...')
                await self.fill_basic_fields(page, user_data)
                
                # 6. Upload Resume
                if resume_path:
                    await update_application_progress(app_id, 'processing', 60, 'Uploading resume...')
                    await self.upload_resume(page, resume_path)
                
                # 7. Questions
                await update_application_progress(app_id, 'processing', 70, 'Answering questions...')
                await self.handle_custom_questions(page, user_data)
                
                # 8. Submit
                auto_submit = user_data.get('autoSubmitEnabled', False)
                if auto_submit:
                    await update_application_progress(app_id, 'processing', 90, 'Submitting...')
                    submitted = await self.submit_application_auto(page, app_id)
                else:
                    await update_application_progress(app_id, 'review_required', 90, 'Ready for review')
                    submitted = await self.submit_application_manual(page, app_id)
                
                if submitted:
                    await update_application_progress(app_id, 'applied', 100, 'Success!')
                    await update_application_status(app_id, 'applied')
                    self.stats['successful'] += 1
                    return True
                else:
                    await update_application_status(app_id, 'failed', 'Submission failed')
                    self.stats['failed'] += 1
                    return False
            
            finally:
                await page.close()
        
        except Exception as e:
            await update_application_status(app_id, 'failed', str(e))
            self.stats['failed'] += 1
            return False
        
        finally:
            if resume_path and os.path.exists(resume_path):
                try: os.remove(resume_path)
                except: pass
    
    async def run(self):
        """Main execution loop"""
        try:
            await self.initialize()
            applications = await get_pending_applications()
            
            if not applications:
                logger.info("â„¹ï¸  No pending applications")
                return
            
            for i, app in enumerate(applications, 1):
                self.stats['processed'] += 1
                await self.process_application(app)
                if i < len(applications):
                    logger.info("\nâ³ Waiting 5 seconds...")
                    await asyncio.sleep(5)
            
            logger.info("\n" + "="*70)
            logger.info(f"ðŸ“Š Stats: {self.stats['successful']} Success / {self.stats['failed']} Failed")
            logger.info("="*70)
        
        finally:
            await self.close()

async def main():
    logger.info("ðŸš€ JOBHUNT AI ENGINE STARTED V2.0 (FULLY FIXED)")
    # Clean up old screenshot files
    cleanup_old_screenshots(days_old=7)
    applier = SmartApplier()
    await applier.run()

if __name__ == "__main__":
    if asyncio.sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    asyncio.run(main())
===== ./scripts/api_routes_package.ts =====
// ============================================================================
// FILE 1: app/api/sync-jobs/route.ts
// Main job scraping and sync endpoint
// ============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import { open } from 'sqlite';
import sqlite3 from 'sqlite3';
import { adminDb } from '@/lib/firebase-admin';
import { deepseek } from '@/lib/deepseek';

const execAsync = promisify(exec);

export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    // Verify authorization
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ðŸš€ Starting job sync pipeline...');

    // 1. Run Python scraper
    console.log('ðŸ“¡ Running Python job scraper...');
    try {
      const { stdout } = await execAsync(
        'cd scripts && python3 job_scraper.py --no-email',
        { timeout: 600000 } // 10 minutes
      );
      console.log('Scraper output:', stdout);
    } catch (error) {
      console.error('Scraper error:', error);
      // Continue anyway - we might have cached data
    }

    // 2. Read jobs from SQLite
    const db = await open({
      filename: './data/job_intelligence.db',
      driver: sqlite3.Database,
      mode: sqlite3.OPEN_READONLY
    });

    const jobs = await db.all(`
      SELECT * FROM jobs 
      WHERE found_at > datetime('now', '-2 hours')
      ORDER BY score DESC
      LIMIT 500
    `);

    await db.close();

    if (jobs.length === 0) {
      return NextResponse.json({ 
        success: true, 
        message: 'No new jobs to sync',
        stats: { jobsScraped: 0, jobsSynced: 0, matchesCreated: 0 }
      });
    }

    // 3. Sync to Firestore
    const jobIds: string[] = [];
    const batch = adminDb.batch();

    for (const job of jobs) {
      const jobRef = adminDb.collection('jobs').doc();
      batch.set(jobRef, {
        title: job.title,
        company: job.company,
        location: job.location,
        url: job.url,
        source: job.ats_source,
        seniority: job.seniority,
        scraperScore: job.score,
        postedAt: new Date(job.found_at),
        createdAt: new Date(),
        indexed: false,
      });
      jobIds.push(jobRef.id);
    }

    await batch.commit();

    // 4. Match with users (simplified for demo)
    let matchCount = 0;
    const usersSnapshot = await adminDb
      .collection('users')
      .where('active', '==', true)
      .limit(10)
      .get();

    for (const userDoc of usersSnapshot.docs) {
      for (const jobId of jobIds.slice(0, 5)) {
        const matchRef = adminDb.collection('user_job_matches').doc();
        await matchRef.set({
          userId: userDoc.id,
          jobId: jobId,
          matchScore: 85, // Would be calculated by AI
          matchReasons: ['Strong skills match', 'Experience level fits'],
          viewed: false,
          applied: false,
          notifiedAt: new Date(),
        });
        matchCount++;
      }
    }

    const duration = Date.now() - startTime;

    return NextResponse.json({ 
      success: true,
      stats: {
        jobsScraped: jobs.length,
        jobsSynced: jobIds.length,
        matchesCreated: matchCount,
        duration
      }
    });

  } catch (error: any) {
    console.error('Job sync failed:', error);
    return NextResponse.json({ 
      success: false, 
      error: error.message 
    }, { status: 500 });
  }
}

// ============================================================================
// FILE 2: app/api/test-email/route.ts
// Test email sending functionality
// ============================================================================

import { NextResponse } from 'next/server';
import nodemailer from 'nodemailer';

export async function GET() {
  try {
    const transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST || 'smtp.gmail.com',
      port: 587,
      secure: false,
      auth: {
        user: process.env.SENDER_EMAIL,
        pass: process.env.SENDER_PASSWORD,
      },
    });

    const info = await transporter.sendMail({
      from: `"JobHunt AI" <${process.env.SENDER_EMAIL}>`,
      to: process.env.SENDER_EMAIL, // Send to yourself for testing
      subject: 'âœ… Email Test - JobHunt AI',
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2>Email Configuration Test</h2>
          <p>If you're reading this, your email configuration is working correctly! ðŸŽ‰</p>
          <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <p><strong>Test Details:</strong></p>
            <ul>
              <li>SMTP Host: ${process.env.SMTP_HOST}</li>
              <li>From: ${process.env.SENDER_EMAIL}</li>
              <li>Time: ${new Date().toLocaleString()}</li>
            </ul>
          </div>
          <p>You're ready to send job notifications!</p>
        </div>
      `,
    });

    return NextResponse.json({ 
      success: true, 
      message: 'Email sent successfully!',
      messageId: info.messageId 
    });
  } catch (error: any) {
    console.error('Email test failed:', error);
    return NextResponse.json({ 
      success: false, 
      error: error.message 
    }, { status: 500 });
  }
}

// ============================================================================
// FILE 3: app/api/user/profile/route.ts
// Get and update user profile
// ============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { adminDb } from '@/lib/firebase-admin';
import { adminAuth } from '@/lib/firebase-admin';

export async function GET(request: NextRequest) {
  try {
    const token = request.headers.get('authorization')?.split('Bearer ')[1];
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const decodedToken = await adminAuth.verifyIdToken(token);
    const userId = decodedToken.uid;

    const userDoc = await adminDb.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    return NextResponse.json({ success: true, profile: userDoc.data() });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    const token = request.headers.get('authorization')?.split('Bearer ')[1];
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const decodedToken = await adminAuth.verifyIdToken(token);
    const userId = decodedToken.uid;

    const updates = await request.json();

    await adminDb.collection('users').doc(userId).update({
      ...updates,
      updatedAt: new Date(),
    });

    return NextResponse.json({ success: true });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// ============================================================================
// FILE 4: app/api/matches/route.ts
// Get user's job matches
// ============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { adminDb } from '@/lib/firebase-admin';
import { adminAuth } from '@/lib/firebase-admin';

export async function GET(request: NextRequest) {
  try {
    const token = request.headers.get('authorization')?.split('Bearer ')[1];
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const decodedToken = await adminAuth.verifyIdToken(token);
    const userId = decodedToken.uid;

    const matchesSnapshot = await adminDb
      .collection('user_job_matches')
      .where('userId', '==', userId)
      .orderBy('matchScore', 'desc')
      .limit(50)
      .get();

    const matches = await Promise.all(
      matchesSnapshot.docs.map(async (doc) => {
        const matchData = doc.data();
        const jobDoc = await adminDb.collection('jobs').doc(matchData.jobId).get();
        
        return {
          id: doc.id,
          ...matchData,
          job: jobDoc.exists ? jobDoc.data() : null,
        };
      })
    );

    return NextResponse.json({ success: true, matches });
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// ============================================================================
// FILE 5: app/api/webhooks/stripe/route.ts
// Stripe webhook handler (for subscription management)
// ============================================================================

import { NextRequest, NextResponse } from 'next/server';
import { stripe, constructWebhookEvent } from '@/lib/stripe';
import { adminDb } from '@/lib/firebase-admin';

export async function POST(request: NextRequest) {
  try {
    const body = await request.text();
    const signature = request.headers.get('stripe-signature')!;

    const event = await constructWebhookEvent(body, signature);

    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object;
        const userId = session.metadata?.userId;
        const tier = session.metadata?.tier;

        if (userId && tier) {
          await adminDb.collection('users').doc(userId).update({
            tier,
            stripeCustomerId: session.customer,
            subscriptionId: session.subscription,
            subscriptionStatus: 'active',
            updatedAt: new Date(),
          });
        }
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object;
        const userId = subscription.metadata?.userId;

        if (userId) {
          await adminDb.collection('users').doc(userId).update({
            tier: 'free',
            subscriptionStatus: 'canceled',
            updatedAt: new Date(),
          });
        }
        break;
      }
    }

    return NextResponse.json({ received: true });
  } catch (error: any) {
    console.error('Webhook error:', error);
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}

// ============================================================================
// USAGE INSTRUCTIONS
// ============================================================================

/*
1. Create these files in your project:
   - app/api/sync-jobs/route.ts
   - app/api/test-email/route.ts
   - app/api/user/profile/route.ts
   - app/api/matches/route.ts
   - app/api/webhooks/stripe/route.ts

2. Test each endpoint:
   - GET  /api/test-email          â†’ Test email sending
   - POST /api/sync-jobs           â†’ Trigger job sync (requires auth header)
   - GET  /api/user/profile        â†’ Get user profile (requires JWT)
   - PUT  /api/user/profile        â†’ Update user profile (requires JWT)
   - GET  /api/matches             â†’ Get user's job matches (requires JWT)
   - POST /api/webhooks/stripe     â†’ Handle Stripe events

3. Authentication headers:
   For cron jobs:
     Authorization: Bearer {CRON_SECRET}
   
   For user requests:
     Authorization: Bearer {firebase_jwt_token}
   
   For Stripe webhooks:
     stripe-signature: {signature_from_stripe}

4. Environment variables required:
   - CRON_SECRET
   - SENDER_EMAIL
   - SENDER_PASSWORD
   - SMTP_HOST
   - FIREBASE_ADMIN_* variables
   - STRIPE_* variables (optional)
*/
===== ./scripts/clean_firebase.py =====
import firebase_admin
from firebase_admin import credentials, firestore
import os

# 1. Setup Firebase (Same as your scraper)
cred_path = 'serviceAccountKey.json'  # Make sure this points to your key file
if not os.path.exists(cred_path):
    print(f"Error: {cred_path} not found!")
    exit()

cred = credentials.Certificate(cred_path)
firebase_admin.initialize_app(cred)
db = firestore.client()

# 2. The User ID to target
TARGET_USER_ID = "JQtDxYNwJyTRrMu9EsA3H19ql1Q2"

def delete_user_matches():
    print(f"ðŸ” Searching for matches for user: {TARGET_USER_ID}...")
    
    # Get all documents where userId matches
    docs = db.collection('user_job_matches')\
             .where('userId', '==', TARGET_USER_ID)\
             .stream()

    batch = db.batch()
    count = 0
    deleted_total = 0
    
    for doc in docs:
        print(f"   Marking for deletion: {doc.id}")
        batch.delete(doc.reference)
        count += 1
        
        # Firestore batches can only hold 500 ops
        if count >= 400:
            batch.commit()
            print(f"   ðŸ”¥ Committed batch of {count} deletions...")
            deleted_total += count
            batch = db.batch()
            count = 0

    # Commit any remaining
    if count > 0:
        batch.commit()
        deleted_total += count
        
    print(f"âœ… DONE! Deleted {deleted_total} documents.")

if __name__ == "__main__":
    delete_user_matches()
===== ./scripts/complete_targets_list.py =====

COMPLETE_TARGETS = [
    # ===== TIER S: MEGA-CAPS & ELITE AI =====
    {"name": "OpenAI", "ats": "greenhouse", "id": "openai", "priority": 1},
    {"name": "Anthropic", "ats": "ashby", "id": "anthropic", "priority": 1},
    {"name": "Google", "ats": "workday", "id": "google", "priority": 1},
    {"name": "Meta", "ats": "workday", "id": "meta", "priority": 1},
    {"name": "Apple", "ats": "workday", "id": "apple", "priority": 1},
    {"name": "Microsoft", "ats": "workday", "id": "microsoft", "priority": 1},
    {"name": "Amazon", "ats": "workday", "id": "amazon", "priority": 1},
    {"name": "Nvidia", "ats": "workday", "id": "nvidia", "priority": 1},
    {"name": "Tesla", "ats": "greenhouse", "id": "tesla", "priority": 1},
    {"name": "SpaceX", "ats": "greenhouse", "id": "spacex", "priority": 1},
    
    # ===== TIER A: TOP UNICORNS & GROWTH =====
    {"name": "Stripe", "ats": "greenhouse", "id": "stripe", "priority": 1},
    {"name": "Airbnb", "ats": "greenhouse", "id": "airbnb", "priority": 1},
    {"name": "Databricks", "ats": "greenhouse", "id": "databricks", "priority": 1},
    {"name": "Figma", "ats": "ashby", "id": "figma", "priority": 1},
    {"name": "Notion", "ats": "ashby", "id": "notion", "priority": 1},
    {"name": "Canva", "ats": "greenhouse", "id": "canva", "priority": 1},
    {"name": "Uber", "ats": "greenhouse", "id": "uberats", "priority": 1},
    {"name": "Lyft", "ats": "greenhouse", "id": "lyft", "priority": 1},
    {"name": "DoorDash", "ats": "greenhouse", "id": "doordash", "priority": 1},
    {"name": "Instacart", "ats": "greenhouse", "id": "instacart", "priority": 1},
    {"name": "Coinbase", "ats": "greenhouse", "id": "coinbase", "priority": 1},
    {"name": "Robinhood", "ats": "greenhouse", "id": "robinhood", "priority": 1},
    {"name": "Snowflake", "ats": "greenhouse", "id": "snowflakecomputerservices", "priority": 1},
    {"name": "Datadog", "ats": "greenhouse", "id": "datadog", "priority": 1},
    
    # ===== AI COMPANIES (2024 HOT) =====
    {"name": "Scale AI", "ats": "ashby", "id": "scaleai", "priority": 1},
    {"name": "Hugging Face", "ats": "ashby", "id": "huggingface", "priority": 1},
    {"name": "Cohere", "ats": "ashby", "id": "cohere", "priority": 1},
    {"name": "Mistral", "ats": "ashby", "id": "mistralai", "priority": 2},
    {"name": "Perplexity", "ats": "ashby", "id": "perplexity", "priority": 2},
    {"name": "Cursor", "ats": "ashby", "id": "cursor", "priority": 1},
    {"name": "Replit", "ats": "ashby", "id": "replit", "priority": 2},
    {"name": "Runway", "ats": "ashby", "id": "runwayml", "priority": 2},
    {"name": "Midjourney", "ats": "ashby", "id": "midjourney", "priority": 2},
    {"name": "Character.ai", "ats": "ashby", "id": "character", "priority": 2},
    {"name": "Harvey", "ats": "ashby", "id": "harvey", "priority": 2},
    {"name": "Glean", "ats": "ashby", "id": "glean", "priority": 2},
    {"name": "Adept", "ats": "ashby", "id": "adept", "priority": 2},
    {"name": "Inflection", "ats": "ashby", "id": "inflection", "priority": 2},
    {"name": "Jasper", "ats": "ashby", "id": "jasper", "priority": 2},
    {"name": "Copy.ai", "ats": "ashby", "id": "copyai", "priority": 3},
    
    # ===== CLOUD & INFRASTRUCTURE =====
    {"name": "Cloudflare", "ats": "greenhouse", "id": "cloudflare", "priority": 1},
    {"name": "HashiCorp", "ats": "greenhouse", "id": "hashicorp", "priority": 2},
    {"name": "MongoDB", "ats": "greenhouse", "id": "mongodb", "priority": 2},
    {"name": "Elastic", "ats": "greenhouse", "id": "elastic", "priority": 2},
    {"name": "Confluent", "ats": "greenhouse", "id": "confluent", "priority": 2},
    {"name": "GitLab", "ats": "greenhouse", "id": "gitlab", "priority": 2},
    {"name": "Vercel", "ats": "ashby", "id": "vercel", "priority": 1},
    {"name": "Supabase", "ats": "ashby", "id": "supabase", "priority": 2},
    {"name": "PlanetScale", "ats": "greenhouse", "id": "planetscale", "priority": 3},
    
    # ===== FINTECH =====
    {"name": "Plaid", "ats": "greenhouse", "id": "plaid", "priority": 2},
    {"name": "Affirm", "ats": "greenhouse", "id": "affirm", "priority": 2},
    {"name": "SoFi", "ats": "greenhouse", "id": "sofi", "priority": 2},
    {"name": "Chime", "ats": "greenhouse", "id": "chime", "priority": 2},
    {"name": "Brex", "ats": "greenhouse", "id": "brex", "priority": 2},
    {"name": "Ramp", "ats": "ashby", "id": "ramp", "priority": 2},
    {"name": "Mercury", "ats": "greenhouse", "id": "mercury", "priority": 2},
    {"name": "Carta", "ats": "greenhouse", "id": "carta", "priority": 2},
    {"name": "Chainalysis", "ats": "greenhouse", "id": "chainalysis", "priority": 2},
    {"name": "Kraken", "ats": "lever", "id": "kraken", "priority": 2},
    
    # ===== ENTERPRISE SAAS =====
    {"name": "Salesforce", "ats": "workday", "id": "salesforce", "priority": 2},
    {"name": "Workday", "ats": "workday", "id": "workday", "priority": 2},
    {"name": "ServiceNow", "ats": "workday", "id": "servicenow", "priority": 2},
    {"name": "Atlassian", "ats": "lever", "id": "atlassian", "priority": 2},
    {"name": "Asana", "ats": "greenhouse", "id": "asana", "priority": 2},
    {"name": "Monday.com", "ats": "greenhouse", "id": "monday", "priority": 3},
    {"name": "Airtable", "ats": "greenhouse", "id": "airtable", "priority": 2},
    {"name": "Retool", "ats": "ashby", "id": "retool", "priority": 2},
    {"name": "Webflow", "ats": "greenhouse", "id": "webflow", "priority": 2},
    
    # ===== COLLABORATION & PRODUCTIVITY =====
    {"name": "Slack", "ats": "greenhouse", "id": "slack", "priority": 2},
    {"name": "Zoom", "ats": "greenhouse", "id": "zoomvideo", "priority": 2},
    {"name": "Dropbox", "ats": "greenhouse", "id": "dropbox", "priority": 2},
    {"name": "Box", "ats": "greenhouse", "id": "box", "priority": 2},
    {"name": "Miro", "ats": "greenhouse", "id": "miro", "priority": 2},
    {"name": "Linear", "ats": "ashby", "id": "linear", "priority": 2},
    {"name": "Coda", "ats": "greenhouse", "id": "coda", "priority": 3},
    {"name": "ClickUp", "ats": "greenhouse", "id": "clickup", "priority": 3},
    {"name": "Loom", "ats": "greenhouse", "id": "loom", "priority": 3},
    {"name": "Zapier", "ats": "greenhouse", "id": "zapier", "priority": 2},
    
    # ===== SECURITY & DEVTOOLS =====
    {"name": "CrowdStrike", "ats": "greenhouse", "id": "crowdstrike", "priority": 2},
    {"name": "Snyk", "ats": "greenhouse", "id": "snyk", "priority": 2},
    {"name": "Vanta", "ats": "ashby", "id": "vanta", "priority": 2},
    {"name": "Drata", "ats": "greenhouse", "id": "drata", "priority": 3},
    {"name": "Wiz", "ats": "greenhouse", "id": "wiz", "priority": 2},
    {"name": "Lacework", "ats": "greenhouse", "id": "lacework", "priority": 3},
    {"name": "Checkr", "ats": "greenhouse", "id": "checkr", "priority": 3},
    {"name": "Postman", "ats": "greenhouse", "id": "postman", "priority": 2},
    
    # ===== MEDIA & CONTENT =====
    {"name": "Spotify", "ats": "lever", "id": "spotify", "priority": 1},
    {"name": "Netflix", "ats": "lever", "id": "netflix", "priority": 1},
    {"name": "Twitch", "ats": "greenhouse", "id": "twitch", "priority": 2},
    {"name": "Reddit", "ats": "greenhouse", "id": "reddit", "priority": 2},
    {"name": "Pinterest", "ats": "greenhouse", "id": "pinterest", "priority": 2},
    {"name": "Snap", "ats": "greenhouse", "id": "snapchat", "priority": 2},
    {"name": "Discord", "ats": "greenhouse", "id": "discord", "priority": 2},
    {"name": "Substack", "ats": "ashby", "id": "substack", "priority": 3},
    {"name": "Patreon", "ats": "greenhouse", "id": "patreon", "priority": 3},
    
    # ===== E-COMMERCE & MARKETPLACES =====
    {"name": "Shopify", "ats": "greenhouse", "id": "shopify", "priority": 2},
    {"name": "Etsy", "ats": "greenhouse", "id": "etsy", "priority": 2},
    {"name": "Wayfair", "ats": "greenhouse", "id": "wayfair", "priority": 2},
    {"name": "Zillow", "ats": "greenhouse", "id": "zillow", "priority": 2},
    {"name": "Redfin", "ats": "greenhouse", "id": "redfin", "priority": 3},
    {"name": "OpenDoor", "ats": "greenhouse", "id": "opendoor", "priority": 3},
    
    # ===== HR TECH =====
    {"name": "Rippling", "ats": "lever", "id": "rippling", "priority": 2},
    {"name": "Deel", "ats": "ashby", "id": "deel", "priority": 2},
    {"name": "Remote", "ats": "greenhouse", "id": "remote", "priority": 3},
    {"name": "Gusto", "ats": "greenhouse", "id": "gusto", "priority": 3},
    {"name": "Lattice", "ats": "greenhouse", "id": "lattice", "priority": 3},
    
    # ===== GAMING =====
    {"name": "Roblox", "ats": "greenhouse", "id": "roblox", "priority": 2},
    {"name": "Unity", "ats": "greenhouse", "id": "unity-technologies", "priority": 2},
    {"name": "Epic Games", "ats": "greenhouse", "id": "epicgames", "priority": 2},
    {"name": "Riot Games", "ats": "greenhouse", "id": "riotgames", "priority": 2},
    
    # ===== AUTONOMOUS VEHICLES & ROBOTICS =====
    {"name": "Waymo", "ats": "greenhouse", "id": "waymo", "priority": 2},
    {"name": "Cruise", "ats": "greenhouse", "id": "getcruise", "priority": 2},
    {"name": "Aurora", "ats": "greenhouse", "id": "aurora", "priority": 2},
    {"name": "Nuro", "ats": "greenhouse", "id": "nuro", "priority": 2},
    {"name": "Zoox", "ats": "greenhouse", "id": "zoox", "priority": 2},
    {"name": "Rivian", "ats": "greenhouse", "id": "rivian", "priority": 2},
    {"name": "Lucid Motors", "ats": "greenhouse", "id": "lucidmotors", "priority": 3},
    
    # ===== DEFENSE & SPACE =====
    {"name": "Anduril", "ats": "greenhouse", "id": "andurilindustries", "priority": 2},
    {"name": "Shield AI", "ats": "greenhouse", "id": "shieldai", "priority": 2},
    {"name": "Palantir", "ats": "lever", "id": "palantir", "priority": 1},
    
    # ===== HEALTHCARE & BIOTECH =====
    {"name": "Oscar Health", "ats": "greenhouse", "id": "oscarhealth", "priority": 3},
    {"name": "Ro", "ats": "greenhouse", "id": "ro", "priority": 3},
    {"name": "Hims", "ats": "greenhouse", "id": "hims", "priority": 3},
    {"name": "Zocdoc", "ats": "greenhouse", "id": "zocdoc", "priority": 3},
    
    # ===== TRADITIONAL TECH =====
    {"name": "Adobe", "ats": "workday", "id": "adobe", "priority": 2},
    {"name": "Intuit", "ats": "greenhouse", "id": "intuit", "priority": 2},
    {"name": "Oracle", "ats": "workday", "id": "oracle", "priority": 2},
    {"name": "SAP", "ats": "workday", "id": "sap", "priority": 3},
    {"name": "IBM", "ats": "workday", "id": "ibm", "priority": 3},
    {"name": "Cisco", "ats": "workday", "id": "cisco", "priority": 3},
    {"name": "VMware", "ats": "workday", "id": "vmware", "priority": 3},
    
    # ===== ADDITIONAL HIGH-GROWTH (Priority 2-3) =====
    {"name": "Grammarly", "ats": "greenhouse", "id": "grammarly", "priority": 2},
    {"name": "Duolingo", "ats": "greenhouse", "id": "duolingo", "priority": 2},
    {"name": "Peloton", "ats": "greenhouse", "id": "peloton", "priority": 3},
    {"name": "Roku", "ats": "greenhouse", "id": "roku", "priority": 3},
    {"name": "DocuSign", "ats": "greenhouse", "id": "docusign1", "priority": 2},
    {"name": "Twilio", "ats": "greenhouse", "id": "twilio", "priority": 2},
    {"name": "Splunk", "ats": "greenhouse", "id": "splunk1", "priority": 2},
    {"name": "Yelp", "ats": "greenhouse", "id": "yelp1", "priority": 3},
    {"name": "Zendesk", "ats": "greenhouse", "id": "zendesk1", "priority": 3},
    {"name": "HubSpot", "ats": "greenhouse", "id": "hubspot1", "priority": 2},
    {"name": "PagerDuty", "ats": "greenhouse", "id": "pagerduty", "priority": 3},
    {"name": "Okta", "ats": "greenhouse", "id": "okta", "priority": 2},
    {"name": "Block", "ats": "greenhouse", "id": "block", "priority": 2},
    
    # ===== FINANCE & TRADING =====
    {"name": "Jane Street", "ats": "greenhouse", "id": "janestreet", "priority": 1},
    {"name": "Two Sigma", "ats": "greenhouse", "id": "twosigma", "priority": 1},
    {"name": "Citadel", "ats": "greenhouse", "id": "citadel", "priority": 1},
    {"name": "Bridgewater", "ats": "greenhouse", "id": "bridgewater", "priority": 2},
    {"name": "BlackRock", "ats": "workday", "id": "blackrock", "priority": 2},
    {"name": "Goldman Sachs", "ats": "workday", "id": "goldmansachs", "priority": 2},
    {"name": "JP Morgan", "ats": "workday", "id": "jpmorgan", "priority": 2},
    
    # ===== CONSULTING & PROFESSIONAL SERVICES =====
    {"name": "McKinsey", "ats": "workday", "id": "mckinsey", "priority": 2},
    {"name": "BCG", "ats": "workday", "id": "bcg", "priority": 2},
    {"name": "Bain", "ats": "workday", "id": "bain", "priority": 2},
    {"name": "Deloitte", "ats": "workday", "id": "deloitte", "priority": 3},
]

===== ./scripts/job_scraper.py =====
#!/usr/bin/env python3
"""
=============================================================================
   JOBHUNT AI - ENTERPRISE PRODUCTION ENGINE V3.3 (STRICT FILTERING)
   - INTEGRATED: Enhanced Salary Extraction
   - INTEGRATED: Complete Target List
   - FIXED: Strict USA location filtering
   - FIXED: Enhanced negative keyword detection
   - FIXED: Company ID corrections to eliminate 404 errors
   - FIXED: Date parsing for Greenhouse API
   - OPTIMIZED: Rate limits and performance tuning
   - ANALYTICS: Enhanced market intelligence
   - DATABASE: Full Firestore integration
   - NEW: Strict Keyword Enforcement (No matches = Automatic Rejection)
=============================================================================
"""

import asyncio
import threading
import aiohttp
import logging
import sys
import re
import hashlib
import time
import os
from datetime import datetime, timedelta, timezone
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from collections import defaultdict
import random
from pathlib import Path
from difflib import SequenceMatcher
from urllib.parse import urlparse

# --- NEW IMPORTS FOR INTEGRATION ---
from salary_extractor import EnhancedSalaryExtractor, extract_salary_from_job
from complete_targets_list import COMPLETE_TARGETS

# --- LOAD ENVIRONMENT VARIABLES ---
from dotenv import load_dotenv
env_path = Path(__file__).parent / '.env.local'
load_dotenv(dotenv_path=env_path)

# --- WINDOWS ENCODING FIX ---
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

# --- FIREBASE SETUP ---
import firebase_admin
from firebase_admin import credentials, firestore, auth

# --- LOGGING SETUP ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s',
    handlers=[
        logging.FileHandler('scraper.log', encoding='utf-8', mode='a'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# ===========================================================================
#                            GLOBAL FIREBASE INSTANCE
# ===========================================================================

class FirebaseSingleton:
    """Singleton pattern for Firebase to avoid multiple initializations"""
    _instance = None
    _db = None
    _initialized = False
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(FirebaseSingleton, cls).__new__(cls)
        return cls._instance
    
    def initialize(self):
        """Initialize Firebase once"""
        if not self._initialized:
            with self.__class__._lock:
                if not self._initialized:
                    try:
                        if not firebase_admin._apps:
                            cred_path = os.getenv('FIREBASE_CREDENTIALS_PATH', 'serviceAccountKey.json')
                            if not os.path.exists(cred_path):
                                logger.error(f"âŒ Firebase credentials not found at: {cred_path}")
                                return False

                            cred = credentials.Certificate(cred_path)
                            firebase_admin.initialize_app(cred)

                        self._db = firestore.client()
                        self._initialized = True
                        logger.info("âœ… Connected to Firebase Firestore successfully!")
                        return True
                    except Exception as e:
                        logger.critical(f"âŒ Error connecting to Firebase: {e}")
                        return False
        return True
    
    @property
    def db(self):
        """Get Firestore database instance"""
        if not self._initialized:
            self.initialize()
        return self._db

# Create global Firebase instance
firebase_singleton = FirebaseSingleton()

# ===========================================================================
#                            CONFIGURATION
# ===========================================================================

class Config:
    # Environment variables with defaults
    REQUEST_TIMEOUT = int(os.getenv('REQUEST_TIMEOUT', '30'))
    MAX_CONCURRENCY = int(os.getenv('MAX_CONCURRENCY', '15'))
    RETRY_ATTEMPTS = int(os.getenv('RETRY_ATTEMPTS', '3'))
    RETRY_DELAY = float(os.getenv('RETRY_DELAY', '2.0'))
    JOB_EXPIRATION_DAYS = int(os.getenv('JOB_EXPIRATION_DAYS', '30'))
    
    # Rate limiting (requests per second per ATS)
    GREENHOUSE_RATE = float(os.getenv('GREENHOUSE_RATE', '5')) 
    ASHBY_RATE = float(os.getenv('ASHBY_RATE', '3'))           
    LEVER_RATE = float(os.getenv('LEVER_RATE', '4'))           
    WORKDAY_RATE = float(os.getenv('WORKDAY_RATE', '2'))       
    
    # Batch processing
    FIREBASE_BATCH_SIZE = 500
    MAX_JOBS_PER_COMPANY = 1000
    
    # Content limits
    MAX_DESCRIPTION_LENGTH = 2000
    MAX_REQUIREMENTS = 15

# User agents for rotation
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
]

# ===========================================================================
#                        COMPANY VALIDATION & HEALTH CHECK
# ===========================================================================

class CompanyValidator:
    """Validate company URLs and track health status"""
    
    @staticmethod
    def get_known_corrections() -> dict:
        """Manual corrections for known problematic companies"""
        return {
            # Greenhouse corrections
            'Uber': 'uberats',
            'Snap': 'snapchat',
            'Zoom': 'zoomvideo',
            'DocuSign': 'docusign1',
            'Splunk': 'splunk1',
            'Yelp': 'yelp1',
            'Zendesk': 'zendesk1',
            'HubSpot': 'hubspot1',
            'Snowflake': 'snowflakecomputerservices',
            
            # Lever corrections
            'Netflix': 'netflix1',
            'Atlassian': 'atlassian1',
            
            # Ashby corrections
            'Scale AI': 'scaleai',
            'Mistral': 'mistralai',
        }

    @staticmethod
    async def _validate_workday_url(session: aiohttp.ClientSession, target: dict) -> bool:
        """Validate Workday company URL by trying common subdomains with proper headers"""
        import socket
        import re
        company_id = target['id']
        company_name = target['name']

        # Alternative company IDs for Workday (common patterns)
        def get_alternative_ids(base_id: str) -> list:
            suffixes = ['inc', 'careers', 'jobs', 'career', 'global', 'worldwide']
            alternatives = [base_id]
            for suffix in suffixes:
                alternatives.append(f"{base_id}{suffix}")
                alternatives.append(f"{base_id}_{suffix}")
            # Remove duplicates while preserving order
            seen = set()
            unique = []
            for alt in alternatives:
                if alt not in seen:
                    seen.add(alt)
                    unique.append(alt)
            return unique

        candidate_ids = get_alternative_ids(company_id)
        # Try both domain patterns: myworkdayjobs.com (modern) and myworkday.com (legacy)
        domains = ['myworkdayjobs.com', 'myworkday.com']
        subdomains = ['', 'wd1', 'wd2', 'wd3', 'wd4', 'wd5']
        # Path patterns - try with candidate_id and generic, including locale variants
        path_templates = [
            f"/{{id}}/jobs",
            f"/{{id}}/careers/jobs",
            f"/jobs",
            f"/careers/jobs",
            f"/en-US/{{id}}/jobs",
            f"/en/{{id}}/jobs",
            f"/en-US/jobs",
            f"/en/jobs",
            f"/careers",
            f"/en-US/careers",
            f"/en/careers",
        ]

        # Headers to avoid HTTP 500 errors
        default_headers = {
            'User-Agent': random.choice(USER_AGENTS),
            'Accept': 'application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Sec-Fetch-User': '?1',
            'Referer': 'https://www.google.com/',
        }

        # Cache for resolved hosts to avoid repeated DNS lookups
        resolved_hosts = set()
        attempt_count = 0

        for candidate_id in candidate_ids:
            for domain in domains:
                for subdomain in subdomains:
                    if subdomain:
                        host = f"{candidate_id}.{subdomain}.{domain}"
                    else:
                        host = f"{candidate_id}.{domain}"

                    # Skip if host already failed to resolve
                    if host in resolved_hosts:
                        continue

                    # First, check if host resolves to avoid gaierror
                    try:
                        socket.gethostbyname(host)
                        resolved_hosts.add(host)
                    except socket.gaierror:
                        logger.debug(f"  ðŸ” Host does not resolve: {host}")
                        continue
                    except Exception as e:
                        logger.debug(f"  ðŸ” DNS error for {host}: {e}")
                        continue

                    # Host resolves, try each path pattern
                    for template in path_templates:
                        path = template.format(id=candidate_id)
                        url = f"https://{host}{path}"
                        attempt_count += 1

                        # Add delay between attempts to avoid rate limiting
                        if attempt_count > 1:
                            await asyncio.sleep(0.5 + random.uniform(0, 0.5))

                        try:
                            logger.debug(f"Testing Workday URL: {url}")
                            async with session.get(url, headers=default_headers, timeout=10) as resp:
                                # Only accept status 200 and verify it's actually a jobs page
                                if resp.status == 200:
                                    html = await resp.text()
                                    # Basic check to ensure it's not an error or maintenance page
                                    html_lower = html.lower()
                                    # Reject maintenance pages and suspicious redirects
                                    if 'maintenance-page' in html_lower or 'community.workday.com' in html_lower:
                                        logger.debug(f"  âš ï¸  Maintenance page detected for {url}")
                                        continue

                                    # Reject error pages (unless very short, which could be false positive)
                                    if 'error' in html_lower and len(html) > 1000:
                                        logger.debug(f"  âš ï¸  Error page detected for {url}")
                                        continue

                                    # Reject very small pages that don't look like job listings
                                    if len(html) < 1000 and not ('job' in html_lower or 'career' in html_lower):
                                        logger.debug(f"  âš ï¸  Page too small ({len(html)} chars) and no job keywords for {url}")
                                        continue

                                    # Accept if page contains job-related keywords
                                    if ('job' in html_lower or 'career' in html_lower or 'workday' in html_lower):
                                        logger.info(f"âœ… Workday URL validated: {url} (status {resp.status})")
                                        # Store the validated URL pattern for later use
                                        target['_validated_workday_url'] = url
                                        # Update company ID if we used an alternative
                                        if candidate_id != company_id:
                                            logger.info(f"ðŸ”§ Auto-corrected Workday ID for {company_name}: {company_id} â†’ {candidate_id}")
                                            target['id'] = candidate_id
                                        return True
                                    else:
                                        logger.debug(f"  âš ï¸  Page appears to be error or not jobs page: {url}")
                                else:
                                    logger.debug(f"  âš ï¸  Status {resp.status} for {url}")
                        except asyncio.TimeoutError:
                            logger.debug(f"  â° Timeout for {url}")
                        except aiohttp.ClientConnectorError as e:
                            logger.debug(f"  ðŸ”Œ Connection error for {url}: {e}")
                        except Exception as e:
                            logger.debug(f"  âŒ Error for {url}: {e}")
                            continue

        logger.warning(f"âŒ No valid Workday subdomain found for {company_name}")
        return False

    @staticmethod
    async def validate_and_correct(session: aiohttp.ClientSession, target: dict) -> bool:
        """Validate and auto-correct company ID if needed"""
        
        # Apply known corrections
        corrections = CompanyValidator.get_known_corrections()
        if target['name'] in corrections:
            original_id = target['id']
            target['id'] = corrections[target['name']]
            if original_id != target['id']:
                logger.info(f"ðŸ”§ Auto-corrected {target['name']}: {original_id} â†’ {target['id']}")
        
        # Validate the URL
        ats_urls = {
            'greenhouse': f"https://boards-api.greenhouse.io/v1/boards/{target['id']}/jobs",
            'ashby': f"https://api.ashbyhq.com/posting-api/job-board/{target['id']}",
            'lever': f"https://api.lever.co/v0/postings/{target['id']}",
            'workday': None,  # Special handling
        }

        url = ats_urls.get(target['ats'])
        if not url:
            # Handle Workday validation separately
            if target['ats'] == 'workday':
                return await CompanyValidator._validate_workday_url(session, target)
            return False
        
        try:
            headers = {
                'User-Agent': random.choice(USER_AGENTS),
                'Accept': 'application/json',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
            }
            async with session.head(url, headers=headers, timeout=10) as resp:
                return resp.status == 200
        except:
            return False

# ===========================================================================
#                            TARGET COMPANIES
# ===========================================================================

# INTEGRATED: Replaced local list with imported complete list
TARGETS = COMPLETE_TARGETS

# Sort targets by priority for better resource allocation
TARGETS.sort(key=lambda x: x.get('priority', 3))

COMPANY_TIERS = {
    "tier_s": ["OpenAI", "Anthropic", "Google", "Meta", "Apple", "Stripe", "Airbnb", "Netflix", "Nvidia", "SpaceX", "Databricks"],
    "tier_a": ["Scale AI", "Figma", "Notion", "Uber", "Lyft", "Coinbase", "Rippling", "DoorDash", "Snowflake", "Datadog", "Spotify"],
}

# ===========================================================================
#                        RATE LIMITER
# ===========================================================================

class RateLimiter:
    """Enhanced rate limiting with adaptive backoff"""
    
    def __init__(self, calls_per_second: float):
        self.delay = 1.0 / calls_per_second
        self.last_call = 0
        self.consecutive_errors = 0
    
    async def wait(self):
        now = asyncio.get_event_loop().time()
        time_since_last = now - self.last_call
        if time_since_last < self.delay:
            wait_time = self.delay - time_since_last
            # Add jitter to avoid thundering herd
            wait_time *= random.uniform(0.9, 1.1)
            await asyncio.sleep(wait_time)
        self.last_call = asyncio.get_event_loop().time()
    
    def record_error(self):
        self.consecutive_errors += 1
        if self.consecutive_errors > 3:
            # Adaptive backoff for repeated errors
            self.delay = min(self.delay * 1.5, 10.0)
    
    def record_success(self):
        if self.consecutive_errors > 0:
            self.consecutive_errors = 0
            # Gradually return to normal rate
            self.delay = max(self.delay * 0.9, 1.0 / 2)

rate_limiters = {
    'greenhouse': RateLimiter(Config.GREENHOUSE_RATE),
    'ashby': RateLimiter(Config.ASHBY_RATE),
    'lever': RateLimiter(Config.LEVER_RATE),
    'workday': RateLimiter(Config.WORKDAY_RATE),
}

# ===========================================================================
#                        SALARY DETECTION
# ===========================================================================

class SalaryFinder:
    """
    Enhanced salary extraction utils. 
    NOTE: Primary extraction is now done via EnhancedSalaryExtractor (imported),
    but these utils are kept for Analytics and Scoring range parsing.
    """
    
    @staticmethod
    def extract(text: str) -> Optional[str]:
        # Fallback method if needed, but we prefer EnhancedSalaryExtractor
        if not text:
            return None
        
        patterns = [
            r'[\$Â£â‚¬]?\s*[0-9]{2,3}(?:,[0-9]{3}|[kK])?\s*-\s*[\$Â£â‚¬]?\s*[0-9]{2,3}(?:,[0-9]{3}|[kK])?',
            r'[0-9]{2,3}[kK]?\s*-\s*[0-9]{2,3}[kK]?\s*(?:USD|EUR|GBP|CAD)',
            r'\$[0-9]{2,3},[0-9]{3}\s*-\s*\$[0-9]{2,3},[0-9]{3}',
            r'[\$Â£â‚¬][0-9]{2,3}[kK]?\+?',
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                return matches[0].strip()
        
        return None
    
    @staticmethod
    def normalize_salary(salary_str: str) -> Optional[int]:
        if not salary_str:
            return None
        
        numbers = re.findall(r'[0-9]+', salary_str.replace(',', ''))
        if not numbers:
            return None
        
        base = int(numbers[0])
        
        if 'k' in salary_str.lower():
            return base * 1000
        
        return base if base > 1000 else base * 1000
    
    @staticmethod
    def extract_range(salary_str: str) -> Optional[Tuple[int, int]]:
        if not salary_str:
            return None
        
        numbers = re.findall(r'[0-9]+', salary_str.replace(',', ''))
        if len(numbers) < 2:
            return None
        
        nums = [int(n) for n in numbers[:2]]
        
        if 'k' in salary_str.lower():
            nums = [n * 1000 for n in nums]
        
        return (min(nums), max(nums))

# ===========================================================================
#                        JOB SCORING SYSTEM (FULLY FIXED)
# ===========================================================================

class JobScorer:
    """Enhanced job scoring with STRICT filtering"""
    
    # USA locations allow-list
    USA_LOCATIONS = [
        'united states', 'usa', 'us', 'remote', 'anywhere', 'distributed',
        'california', 'new york', 'texas', 'florida', 'washington',
        'san francisco', 'bay area', 'los angeles', 'seattle', 'austin',
        'boston', 'chicago', 'denver', 'portland', 'san diego',
        'miami', 'atlanta', 'philadelphia', 'detroit', 'phoenix',
        'north america', 'cambridge', 'palo alto', 'mountain view'
    ]
    
    # International locations to EXPLICITLY EXCLUDE
    EXCLUDED_LOCATIONS = [
        'berlin', 'germany', 'europe', 'uk', 'london', 'paris', 'france',
        'amsterdam', 'netherlands', 'spain', 'madrid', 'barcelona',
        'italy', 'rome', 'sweden', 'stockholm', 'denmark', 'copenhagen',
        'norway', 'oslo', 'switzerland', 'zurich', 'austria', 'vienna',
        'poland', 'warsaw', 'czech', 'prague', 'hungary', 'budapest',
        'asia', 'china', 'japan', 'singapore', 'india', 'bangalore',
        'canada', 'toronto', 'vancouver', 'montreal', 'australia', 'sydney',
        'latam', 'brazil', 'mexico', 'apac', 'emea', 'dubai', 'uae',
        'tel aviv', 'israel', 'auckland', 'new zealand', 'south africa'
    ]
    
    # US State Codes for validation
    US_STATE_CODES = [
        'al', 'ak', 'az', 'ar', 'ca', 'co', 'ct', 'de', 'fl', 'ga',
        'hi', 'id', 'il', 'in', 'ia', 'ks', 'ky', 'la', 'me', 'md',
        'ma', 'mi', 'mn', 'ms', 'mo', 'mt', 'ne', 'nv', 'nh', 'nj',
        'nm', 'ny', 'nc', 'nd', 'oh', 'ok', 'or', 'pa', 'ri', 'sc',
        'sd', 'tn', 'tx', 'ut', 'vt', 'va', 'wa', 'wv', 'wi', 'wy', 'dc'
    ]
    
    @staticmethod
    def _is_usa_location(location: str) -> bool:
        """Check if location is in the USA (STRICT MODE - FIXED)"""
        if not location:
            return True  # Empty = assume remote/flexible

        location_lower = location.lower().strip()

        # 0. Split by " or " and "/" to handle multiple location options
        segments = []
        for sep in [' or ', '/']:
            if sep in location_lower:
                segments.extend([seg.strip() for seg in location_lower.split(sep)])
                break  # Use first separator found
        if not segments:
            segments = [location_lower]

        # Helper to check a single segment
        def check_segment(seg: str) -> bool:
            # 1. Explicitly allow generic remote terms
            remote_terms = ['remote', 'anywhere', 'distributed', 'global', 'united states', 'usa', 'us', 'u.s.']
            if any(term == seg for term in remote_terms):
                return True

            # 2. CRITICAL: Check exclusion list first
            for excluded in JobScorer.EXCLUDED_LOCATIONS:
                if excluded in seg:
                    logger.debug(f"Segment rejected (excluded): {seg}")
                    return False

            # 3. Check allow list (USA states/cities)
            for usa_loc in JobScorer.USA_LOCATIONS:
                if usa_loc in seg:
                    return True

            # 4. Check for US state codes with word boundaries
            for state in JobScorer.US_STATE_CODES:
                pattern = rf'\b{state}\b'
                if re.search(pattern, seg):
                    return True

            # 5. STRICT FALLBACK: Reject if no positive match
            logger.debug(f"Segment rejected (no USA match): {seg}")
            return False

        # Check each segment; if any passes, location is acceptable
        for seg in segments:
            if check_segment(seg):
                logger.debug(f"Location accepted via segment: {seg} (original: {location})")
                return True

        logger.debug(f"Location rejected (no segment passed): {location}")
        return False
    
    @staticmethod
    def _safe_get_days_ago(job: dict) -> int:
        """Safely extract days_ago from job data"""
        days_ago = job.get('posted_days_ago', 999)
        if isinstance(days_ago, (int, float)):
            return int(days_ago)
        if isinstance(days_ago, str):
            try:
                if 'T' in days_ago:
                    date_str = days_ago.replace('Z', '+00:00')
                    posted_dt = datetime.fromisoformat(date_str)
                    current_time = datetime.now(timezone.utc)
                    return (current_time - posted_dt).days
                return int(float(days_ago))
            except (ValueError, TypeError) as e:
                logger.debug(f"Failed to parse days_ago '{days_ago[:50]}': {e}")
                return 999
        return 999
    
    @staticmethod
    def calculate_score(job: dict, profile: dict) -> dict:
        score = 0
        flags = []
        
        title_lower = job['title'].lower()
        location_lower = job.get('location', '').lower()
        description_lower = job.get('description', '').lower()
        company = job['company']
        
        detected_seniority = JobScorer._extract_seniority(title_lower)
        days_ago = JobScorer._safe_get_days_ago(job)
        
        # ðŸš¨ STEP 0: USA LOCATION FILTER (STRICT)
        if not JobScorer._is_usa_location(job.get('location', '')):
            return {
                'score': 0,
                'flags': ['âŒ Non-USA location'],
                'seniority': 'unknown',
                'matched_keywords': [],
                'location_match': False,
                'days_ago': 999,
                'rejected': True,
                'rejection_reason': f"Non-USA location: {job.get('location')}"
            }
        
        # 1. KEYWORD MATCH
        keyword_score = 0
        matched_keywords = []
        
        for kw in profile.get('keywords', []):
            kw_lower = kw.lower()

            # Check title - enhanced matching
            title_match = False
            desc_match = False

            # Exact phrase match (highest score)
            if kw_lower in title_lower:
                if ' ' in kw_lower:  # Multi-word exact phrase
                    keyword_score += 30
                else:  # Single word exact
                    keyword_score += 10
                matched_keywords.append(kw)
                title_match = True

            # If no exact match, try partial word matching for multi-word keywords
            elif ' ' in kw_lower and not title_match:
                words = kw_lower.split()
                matched_words = [word for word in words if word in title_lower]
                if matched_words:
                    # Partial match: some words from keyword phrase appear in title
                    keyword_score += 5 * len(matched_words)  # Reduced score for partial
                    matched_keywords.append(kw)
                    title_match = True
                    logger.debug(f"Partial keyword match: {kw} -> {matched_words} in '{job['title']}'")

            # Check description (only if not already matched in title)
            if not title_match and kw_lower in description_lower:
                requirements_text = ' '.join(job.get('requirements', []))
                if kw_lower in requirements_text.lower():
                    keyword_score += 12
                else:
                    keyword_score += 6
                matched_keywords.append(kw)
                desc_match = True
        
        # NEW: Debug Log to track scoring logic
        logger.info(f"ðŸ” Scoring: {job['title']} | Keywords: {profile.get('keywords', [])} | Matched: {matched_keywords}")

        # NEW: STRICT FILTER - Require at least one keyword match
        if not matched_keywords:
            return {
                'score': 0,
                'flags': ['âš ï¸ No keyword match'],
                'seniority': detected_seniority,
                'matched_keywords': [],
                'location_match': False,
                'days_ago': days_ago,
                'rejected': True,
                'rejection_reason': f"Strict filter: Title '{job['title']}' did not match any keywords."
            }
        
        score += min(keyword_score, 50)
        
        if matched_keywords:
            flags.append(f"Keywords: {', '.join(list(set(matched_keywords))[:3])}")
        
        # 2. SENIORITY MATCH
        target_seniority_levels = profile.get('seniority', [])
        
        if detected_seniority in target_seniority_levels:
            score += 25
            flags.append(f"Level: {detected_seniority.title()}")
        elif not target_seniority_levels:
            score += 15
        
        # 3. LOCATION MATCH
        target_locs = profile.get('locations', [])
        location_match = False
        
        for loc in target_locs:
            loc_lower = loc.lower()
            if (loc_lower in location_lower or 
                loc_lower in description_lower or
                JobScorer._is_location_match(loc_lower, location_lower)):
                score += 15
                flags.append(f"Location: {loc.title()}")
                location_match = True
                break
        
        if not location_match and not target_locs:
            score += 10
        
        # 4. COMPANY TIER
        if company in COMPANY_TIERS['tier_s']:
            score += 20
            flags.append("ðŸŒŸ Top Tier")
        elif company in COMPANY_TIERS['tier_a']:
            score += 15
            flags.append("â­ High Growth")
        else:
            score += 5
        
        # 5. SALARY TRANSPARENCY
        if job.get('salary'):
            score += 5
            flags.append(f"ðŸ’° {job['salary']}")
            
            salary_range = SalaryFinder.extract_range(job['salary'])
            if salary_range and salary_range[1] > 150000:
                score += 3
                flags.append("ðŸ’µ High Salary")
        
        # 6. FRESHNESS BONUS
        if days_ago <= 1:
            score += 8
            flags.append("ðŸ”¥ Just Posted")
        elif days_ago <= 3:
            score += 6
            flags.append("ðŸ†• Very Fresh")
        elif days_ago <= 7:
            score += 4
            flags.append("ðŸ†• Fresh")
        elif days_ago <= 14:
            score += 2
            flags.append("ðŸ“… Recent")
        
        # 7. REMOTE FRIENDLY
        if any(remote_term in location_lower or remote_term in description_lower 
               for remote_term in ['remote', 'anywhere', 'distributed', 'virtual']):
            score += 5
            flags.append("ðŸ  Remote Friendly")
        
        # 8. NEGATIVE KEYWORD FILTER (ENHANCED - FIXED)
        negative_keywords = profile.get('excludeKeywords', [
            'intern', 'internship', 'entry level', 'junior', 
            'designer', 'engineer', 'analyst', 'coordinator'
        ])
        
        # Check both title AND description
        full_text = (title_lower + ' ' + description_lower).strip()
        
        for neg_kw in negative_keywords:
            neg_kw_lower = neg_kw.lower().strip()
            
            # CRITICAL: Check title first (high confidence)
            if neg_kw_lower in title_lower:
                return {
                    'score': 0,
                    'flags': flags,
                    'seniority': detected_seniority,
                    'matched_keywords': matched_keywords,
                    'location_match': location_match,
                    'days_ago': days_ago,
                    'rejected': True,
                    'rejection_reason': f"Title contains negative keyword: {neg_kw}"
                }
            
            # NEW: Check description with word boundaries (avoid false positives)
            # E.g., "manager" shouldn't match "management"
            pattern = rf'\b{re.escape(neg_kw_lower)}\b'
            if re.search(pattern, description_lower):
                # Only reject if keyword appears multiple times or in prominent position
                occurrences = len(re.findall(pattern, description_lower))
                first_occurrence = description_lower.find(neg_kw_lower)
                
                # Reject if:
                # - Appears 3+ times in description
                # - Appears in first 200 chars (likely job title/summary)
                if occurrences >= 3 or first_occurrence < 200:
                    return {
                        'score': 0,
                        'flags': flags,
                        'seniority': detected_seniority,
                        'matched_keywords': matched_keywords,
                        'location_match': location_match,
                        'days_ago': days_ago,
                        'rejected': True,
                        'rejection_reason': f"Description emphasizes negative keyword: {neg_kw} ({occurrences}x)"
                    }

        # RELAXED REJECTION LOGIC (Now redundant due to strict filter, but kept for low scores with keywords)
        if score < 15:
            return {
                'score': 0,
                'flags': ['âš ï¸ Low relevance'],
                'seniority': detected_seniority,
                'matched_keywords': matched_keywords,
                'location_match': False,
                'days_ago': days_ago,
                'rejected': True,
                'rejection_reason': 'Low score'
            }
        
        return {
            'score': min(score, 100),
            'flags': flags,
            'seniority': detected_seniority,
            'matched_keywords': matched_keywords,
            'location_match': location_match,
            'days_ago': days_ago,
            'rejected': False
        }
    
    @staticmethod
    def _extract_seniority(title: str) -> str:
        title = title.lower()
        seniority_patterns = [
            (['vp', 'vice president', 'head of', 'director', 'chief', 'exec'], 'executive'),
            (['principal', 'distinguished', 'fellow'], 'principal'),
            (['staff', 'senior staff'], 'staff'),
            (['senior', 'sr.', 'sr '], 'senior'),
            (['lead', 'tech lead', 'engineering lead', 'manager'], 'lead'),
            (['mid', 'mid-level', 'experienced'], 'mid'),
            (['junior', 'jr.', 'entry', 'associate', 'new grad'], 'junior'),
            (['intern', 'internship'], 'intern'),
        ]
        
        for patterns, level in seniority_patterns:
            if any(pattern in title for pattern in patterns):
                return level
        return 'mid'
    
    @staticmethod
    def _is_location_match(target_loc: str, job_loc: str) -> bool:
        location_mappings = {
            'sf': 'san francisco',
            'bay area': 'san francisco',
            'nyc': 'new york',
            'la': 'los angeles',
            'austin': 'texas',
            'seattle': 'washington',
        }
        
        if target_loc in job_loc:
            return True
        
        for short, full in location_mappings.items():
            if (target_loc == short and full in job_loc) or (target_loc == full and short in job_loc):
                return True
        
        return False

# ===========================================================================
#                        CONTENT EXTRACTION
# ===========================================================================

class ContentExtractor:
    """Enhanced content extraction"""
    
    @staticmethod
    def clean_html(html_content: str) -> str:
        if not html_content:
            return ""
        
        html_content = re.sub(r'<(script|style)[^>]*>.*?</\1>', '', html_content, flags=re.DOTALL)
        
        replacements = {
            '&nbsp;': ' ', '&amp;': '&', '&lt;': '<', '&gt;': '>',
            '&quot;': '"', '&#39;': "'", '&ndash;': '-', '&mdash;': 'â€”',
        }
        
        for entity, replacement in replacements.items():
            html_content = html_content.replace(entity, replacement)
        
        html_content = re.sub(r'<br\s*/?>', '\n', html_content, flags=re.IGNORECASE)
        html_content = re.sub(r'</p>', '\n\n', html_content, flags=re.IGNORECASE)
        html_content = re.sub(r'<li>', '\nâ€¢ ', html_content, flags=re.IGNORECASE)
        
        clean_text = re.sub(r'<[^>]+>', ' ', html_content)
        
        clean_text = re.sub(r'\s+', ' ', clean_text)
        clean_text = re.sub(r'\n\s*\n', '\n\n', clean_text)
        clean_text = re.sub(r'[ \t]+', ' ', clean_text)
        
        return clean_text.strip()
    
    @staticmethod
    def extract_requirements(content: str) -> List[str]:
        if not content:
            return []
        
        patterns = [
            r'(?:Requirements?|Qualifications?|You Have|Must Have|Required Skills|You Will Need)[:\s]+(.*?)(?=\n\n|Requirements|Responsibilities|What You\'ll Do|$|Qualifications)',
            r'(?:What [Yy]ou\'ll [Bb]ring|What [Ww]e\'re [Ll]ooking [Ff]or|Ideal Candidate)[:\s]+(.*?)(?=\n\n|$|Qualifications)',
            r'(?:Minimum Qualifications|Basic Qualifications)[:\s]+(.*?)(?=\n\n|Preferred Qualifications|$|What We\'re Looking For)',
        ]
        
        all_requirements = []
        
        for pattern in patterns:
            matches = re.findall(pattern, content, re.IGNORECASE | re.DOTALL)
            for match in matches:
                bullets = re.findall(r'[â€¢\-\*â—¦â–ªâ–¶]\s*(.+?)(?=\n|$|[â€¢\-\*])', match)
                if not bullets:
                    bullets = re.findall(r'\d+\.\s*(.+?)(?=\n|$|\d+\.)', match)
                if not bullets:
                    bullets = re.findall(r'(?:^|\n)\s*[â€¢\-\*]?\s*([A-Z].+?[.!?])(?=\n|$)', match)
                
                if bullets:
                    cleaned = [b.strip() for b in bullets if len(b.strip()) > 10]
                    all_requirements.extend(cleaned)
        
        unique_reqs = []
        seen = set()
        for req in all_requirements:
            req_lower = req.lower()
            if req_lower not in seen and len(req) < 500:
                seen.add(req_lower)
                unique_reqs.append(req)
        
        return unique_reqs[:Config.MAX_REQUIREMENTS]
    
    @staticmethod
    def extract_description_summary(content: str, max_length: int = None) -> str:
        if max_length is None:
            max_length = Config.MAX_DESCRIPTION_LENGTH
            
        clean = ContentExtractor.clean_html(content)
        if len(clean) <= max_length:
            return clean
        
        truncated = clean[:max_length]
        last_period = truncated.rfind('.')
        last_exclamation = truncated.rfind('!')
        last_question = truncated.rfind('?')
        
        last_boundary = max(last_period, last_exclamation, last_question)
        
        if last_boundary > max_length * 0.7:
            return truncated[:last_boundary + 1]
        
        return truncated + "..."

# ===========================================================================
#                        ANALYTICS ENGINE (NEW)
# ===========================================================================

class AnalyticsEngine:
    """Enhanced analytics for job market insights"""
    
    def __init__(self):
        self.company_stats = defaultdict(lambda: {
            'total_jobs': 0,
            'avg_salary': 0,
            'salary_count': 0,
            'remote_ratio': 0,
            'seniority_dist': defaultdict(int),
            'role_dist': defaultdict(int),
            'locations': defaultdict(int)
        })
        
        self.role_stats = defaultdict(lambda: {
            'count': 0,
            'companies': set(),
            'avg_salary': 0,
            'salary_sum': 0,
            'salary_count': 0
        })
        
        self.salary_brackets = {
            'under_100k': 0,
            '100k_150k': 0,
            '150k_200k': 0,
            '200k_250k': 0,
            '250k_300k': 0,
            '300k_plus': 0,
            'not_specified': 0
        }
        
        self.location_stats = defaultdict(int)
        self.remote_count = 0
        self.total_jobs_analyzed = 0
    
    def analyze_job(self, job: dict):
        """Analyze a single job for insights"""
        self.total_jobs_analyzed += 1
        company = job['company']
        
        # Company stats
        self.company_stats[company]['total_jobs'] += 1
        
        # Role extraction and categorization
        title_lower = job['title'].lower()
        role_category = self._categorize_role(title_lower)
        self.company_stats[company]['role_dist'][role_category] += 1
        self.role_stats[role_category]['count'] += 1
        self.role_stats[role_category]['companies'].add(company)
        
        # Seniority analysis
        seniority = JobScorer._extract_seniority(title_lower)
        self.company_stats[company]['seniority_dist'][seniority] += 1
        
        # Location analysis
        location = job.get('location', '').lower()
        if 'remote' in location or 'anywhere' in location or 'distributed' in location:
            self.remote_count += 1
            self.company_stats[company]['remote_ratio'] += 1
        
        # Extract city/state from location
        primary_location = self._extract_primary_location(location)
        if primary_location:
            self.location_stats[primary_location] += 1
            self.company_stats[company]['locations'][primary_location] += 1
        
        # Salary analysis
        salary = job.get('salary')
        if salary:
            salary_range = SalaryFinder.extract_range(salary)
            if salary_range:
                avg_salary = sum(salary_range) / 2
                
                # Update company salary stats
                curr_avg = self.company_stats[company]['avg_salary']
                count = self.company_stats[company]['salary_count']
                
                # Standard running average formula
                self.company_stats[company]['avg_salary'] = (
                    (curr_avg * count + avg_salary) / (count + 1)
                )
                self.company_stats[company]['salary_count'] += 1
                
                # Update role salary stats
                self.role_stats[role_category]['salary_sum'] += avg_salary
                self.role_stats[role_category]['salary_count'] += 1
                self.role_stats[role_category]['avg_salary'] = (
                    self.role_stats[role_category]['salary_sum'] / 
                    self.role_stats[role_category]['salary_count']
                )
                
                # Update salary brackets
                self._update_salary_bracket(avg_salary)
    
    def _categorize_role(self, title: str) -> str:
        """Categorize job title into role categories"""
        title_lower = title.lower()
        
        categories = {
            'engineering': ['engineer', 'developer', 'architect', 'devops', 'sre', 'infrastructure', 'backend', 'frontend', 'full stack'],
            'product': ['product manager', 'pm', 'product owner', 'product lead', 'director of product', 'head of product'],
            'data': ['data scientist', 'data analyst', 'machine learning', 'ml', 'ai engineer', 'data engineer', 'analytics'],
            'design': ['designer', 'ux', 'ui', 'product design', 'creative', 'art director'],
            'marketing': ['marketing', 'growth', 'demand gen', 'brand', 'content', 'seo', 'sem'],
            'sales': ['sales', 'account executive', 'ae', 'business development', 'sdr', 'bdr', 'account manager'],
            'finance': ['finance', 'accounting', 'cfo', 'controller', 'analyst', 'treasury'],
            'hr': ['hr', 'recruiter', 'talent', 'people operations', 'human resources'],
            'operations': ['operations', 'ops', 'program manager', 'project manager', 'chief of staff'],
            'executive': ['director', 'vp', 'vice president', 'c-level', 'chief', 'head of', 'founder']
        }
        
        for category, keywords in categories.items():
            if any(keyword in title_lower for keyword in keywords):
                return category
        
        return 'other'
    
    def _extract_primary_location(self, location: str) -> Optional[str]:
        """Extract primary location from job location string"""
        if not location:
            return None
        
        # Common location patterns
        location_patterns = [
            ('san francisco', ['sf', 'san francisco', 'bay area', 'palo alto', 'mountain view', 'menlo park', 'redwood city']),
            ('new york', ['nyc', 'new york', 'manhattan', 'brooklyn']),
            ('seattle', ['seattle', 'bellevue', 'redmond', 'kirkland']),
            ('austin', ['austin', 'texas']),
            ('los angeles', ['la', 'los angeles', 'santa monica', 'culver city']),
            ('boston', ['boston', 'cambridge', 'massachusetts']),
            ('chicago', ['chicago', 'illinois']),
            ('denver', ['denver', 'colorado', 'boulder']),
            ('remote', ['remote', 'anywhere', 'distributed', 'virtual'])
        ]
        
        for primary_loc, patterns in location_patterns:
            if any(pattern in location for pattern in patterns):
                return primary_loc
        
        return None
    
    def _update_salary_bracket(self, salary: float):
        """Update salary bracket statistics"""
        if salary < 100000:
            self.salary_brackets['under_100k'] += 1
        elif salary < 150000:
            self.salary_brackets['100k_150k'] += 1
        elif salary < 200000:
            self.salary_brackets['150k_200k'] += 1
        elif salary < 250000:
            self.salary_brackets['200k_250k'] += 1
        elif salary < 300000:
            self.salary_brackets['250k_300k'] += 1
        else:
            self.salary_brackets['300k_plus'] += 1
    
    def get_top_hiring_companies(self, limit: int = 10) -> List[Tuple[str, dict]]:
        """Get top companies by number of jobs"""
        sorted_companies = sorted(
            self.company_stats.items(),
            key=lambda x: x[1]['total_jobs'],
            reverse=True
        )
        return sorted_companies[:limit]
    
    def get_highest_paying_companies(self, min_jobs: int = 5, limit: int = 10) -> List[Tuple[str, float]]:
        """Get companies with highest average salaries"""
        qualified_companies = [
            (company, data['avg_salary']) 
            for company, data in self.company_stats.items() 
            if data['salary_count'] >= min_jobs and data['avg_salary'] > 0
        ]
        
        sorted_companies = sorted(
            qualified_companies,
            key=lambda x: x[1],
            reverse=True
        )
        return sorted_companies[:limit]
    
    def get_most_popular_roles(self, limit: int = 10) -> List[Tuple[str, dict]]:
        """Get most popular job roles"""
        sorted_roles = sorted(
            self.role_stats.items(),
            key=lambda x: x[1]['count'],
            reverse=True
        )
        return sorted_roles[:limit]
    
    def get_location_insights(self, limit: int = 10) -> List[Tuple[str, int]]:
        """Get job distribution by location"""
        sorted_locations = sorted(
            self.location_stats.items(),
            key=lambda x: x[1],
            reverse=True
        )
        return sorted_locations[:limit]
    
    def print_analytics_summary(self):
        """Print comprehensive analytics summary"""
        print("\n" + "="*80)
        print("ðŸ“ˆ JOB MARKET ANALYTICS INSIGHTS")
        print("="*80)
        
        print(f"\nðŸ“Š Total Jobs Analyzed: {self.total_jobs_analyzed:,}")
        print(f"ðŸ  Remote Jobs: {self.remote_count:,} ({self.remote_count/max(self.total_jobs_analyzed,1)*100:.1f}%)")
        
        # Top hiring companies
        print(f"\nðŸ† TOP 10 HIRING COMPANIES:")
        top_hiring = self.get_top_hiring_companies(10)
        for rank, (company, stats) in enumerate(top_hiring, 1):
            remote_pct = (stats['remote_ratio']/max(stats['total_jobs'],1)*100)
            print(f"   {rank:2}. {company:25} â†’ {stats['total_jobs']:4} jobs | {remote_pct:5.1f}% remote")
        
        # Highest paying companies
        print(f"\nðŸ’° HIGHEST PAYING COMPANIES (avg salary):")
        top_paying = self.get_highest_paying_companies(min_jobs=3, limit=10)
        for rank, (company, avg_salary) in enumerate(top_paying, 1):
            print(f"   {rank:2}. {company:25} â†’ ${avg_salary:,.0f}")
        
        # Most popular roles
        print(f"\nðŸŽ¯ MOST IN-DEMAND ROLES:")
        popular_roles = self.get_most_popular_roles(10)
        for rank, (role, stats) in enumerate(popular_roles, 1):
            avg_salary = f"${stats['avg_salary']:,.0f}" if stats['avg_salary'] > 0 else "N/A"
            companies = len(stats['companies'])
            print(f"   {rank:2}. {role:20} â†’ {stats['count']:4} jobs | {avg_salary:10} | {companies:3} companies")
        
        # Salary distribution
        print(f"\nðŸ’µ SALARY DISTRIBUTION:")
        total_with_salary = sum(self.salary_brackets.values()) - self.salary_brackets['not_specified']
        if total_with_salary > 0:
            for bracket, count in self.salary_brackets.items():
                if bracket != 'not_specified':
                    pct = count/max(total_with_salary,1)*100
                    bracket_name = bracket.replace('_', '-').replace('k', 'K').title()
                    print(f"   ðŸ“Š {bracket_name:15} â†’ {count:4} jobs ({pct:5.1f}%)")
        
        # Location insights
        print(f"\nðŸ“ TOP JOB LOCATIONS:")
        top_locations = self.get_location_insights(10)
        for rank, (location, count) in enumerate(top_locations, 1):
            pct = count/max(self.total_jobs_analyzed,1)*100
            print(f"   {rank:2}. {location:20} â†’ {count:4} jobs ({pct:5.1f}%)")
        
        print("="*80)
    
    def save_analytics_to_firestore(self, db):
        """Save analytics data to Firestore for dashboard display"""
        try:
            analytics_id = f"analytics_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M')}"
            analytics_ref = db.collection('market_analytics').document(analytics_id)
            
            # Prepare data for Firestore
            analytics_data = {
                'timestamp': firestore.SERVER_TIMESTAMP,
                'total_jobs_analyzed': self.total_jobs_analyzed,
                'remote_count': self.remote_count,
                'salary_brackets': dict(self.salary_brackets),
                'top_companies': [
                    {
                        'company': company,
                        'total_jobs': stats['total_jobs'],
                        'avg_salary': stats['avg_salary'],
                        'remote_ratio': stats['remote_ratio']/max(stats['total_jobs'],1)*100,
                    }
                    for company, stats in self.get_top_hiring_companies(20)
                ],
                'top_roles': [
                    {
                        'role': role,
                        'count': stats['count'],
                        'avg_salary': stats['avg_salary'],
                        'company_count': len(stats['companies'])
                    }
                    for role, stats in self.get_most_popular_roles(15)
                ],
                'top_locations': [
                    {'location': loc, 'count': count}
                    for loc, count in self.get_location_insights(15)
                ],
                'salary_insights': {
                    'highest_paying_companies': [
                        {'company': company, 'avg_salary': salary}
                        for company, salary in self.get_highest_paying_companies(min_jobs=3, limit=10)
                    ],
                    'salary_distribution': dict(self.salary_brackets)
                }
            }
            
            analytics_ref.set(analytics_data)
            logger.info(f"ðŸ“ˆ Analytics saved to Firestore: {analytics_id}")
            
        except Exception as e:
            logger.error(f"âŒ Failed to save analytics: {e}")

# ===========================================================================
#                        METRICS TRACKING
# ===========================================================================

@dataclass
class ScraperMetrics:
    company: str
    jobs_found: int = 0
    jobs_matched: int = 0
    errors: int = 0
    duration: float = 0.0
    status: str = "pending"
    priority: int = 3
    avg_score: float = 0.0
    scraped_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

@dataclass
class GlobalMetrics:
    start_time: float = field(default_factory=time.time)
    total_jobs_scraped: int = 0
    total_matches_created: int = 0
    total_errors: int = 0
    companies_scraped: int = 0
    companies_failed: int = 0
    company_metrics: Dict[str, ScraperMetrics] = field(default_factory=dict)
    user_match_counts: Dict[str, int] = field(default_factory=lambda: defaultdict(int))
    ats_metrics: Dict[str, Dict] = field(default_factory=lambda: defaultdict(lambda: {'success': 0, 'failed': 0, 'jobs': 0}))
    
    def add_company_metrics(self, metrics: ScraperMetrics, ats_type: str):
        self.company_metrics[metrics.company] = metrics
        self.total_jobs_scraped += metrics.jobs_found
        self.total_matches_created += metrics.jobs_matched
        self.total_errors += metrics.errors
        self.companies_scraped += 1
        
        self.ats_metrics[ats_type]['jobs'] += metrics.jobs_found
        if metrics.status == "success":
            self.ats_metrics[ats_type]['success'] += 1
        else:
            self.ats_metrics[ats_type]['failed'] += 1
            self.companies_failed += 1
    
    def print_summary(self):
        duration = time.time() - self.start_time
        
        print("\n" + "="*80)
        print("ðŸ“Š JOBHUNT AI SCRAPER SUMMARY V3.1 (FIXED & OPTIMIZED)")
        print("="*80)
        print(f"â±ï¸  Total Runtime: {duration:.1f}s")
        print(f"ðŸ¢ Companies Scraped: {self.companies_scraped} ({self.companies_failed} failed)")
        print(f"ðŸ’¼ Total Jobs Found: {self.total_jobs_scraped}")
        print(f"âœ¨ Total Matches Created: {self.total_matches_created}")
        print(f"âŒ Total Errors: {self.total_errors}")
        print(f"ðŸ“ˆ Match Rate: {(self.total_matches_created/max(self.total_jobs_scraped,1)*100):.1f}%")
        
        if self.ats_metrics:
            print(f"\nðŸ”§ ATS Breakdown:")
            for ats, metrics in sorted(self.ats_metrics.items()):
                success_rate = (metrics['success']/max(metrics['success']+metrics['failed'],1)*100)
                print(f"   {ats.upper():10} â†’ {metrics['success']+metrics['failed']:3} companies, {metrics['jobs']:4} jobs, {success_rate:.0f}% success")
        
        if self.user_match_counts:
            print(f"\nðŸ‘¥ User Match Breakdown:")
            for email, count in sorted(self.user_match_counts.items(), key=lambda x: x[1], reverse=True):
                print(f"   {email:40} â†’ {count:3} matches")
        
        print(f"\nðŸ† Top Performing Companies:")
        sorted_metrics = sorted(
            [m for m in self.company_metrics.values() if m.status == "success"],
            key=lambda x: (x.jobs_found, -x.duration),
            reverse=True
        )[:15]
        
        for m in sorted_metrics:
            match_rate = (m.jobs_matched / m.jobs_found * 100) if m.jobs_found > 0 else 0
            print(f"   {m.company:25} â†’ {m.jobs_found:4} jobs | {m.jobs_matched:3} matches ({match_rate:.0f}%) | {m.duration:.1f}s")
        
        if self.companies_failed > 0:
            print(f"\nâš ï¸  Failed Companies:")
            failed = [m for m in self.company_metrics.values() if m.status == "failed"]
            for m in failed[:10]:
                print(f"   âŒ {m.company}")
        
        print("="*80 + "\n")
    
    def save_to_firestore(self, db):
        """Save metrics to Firestore for historical tracking"""
        try:
            metrics_id = f"scrape_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}"
            metrics_ref = db.collection('scraper_metrics').document(metrics_id)
            
            metrics_data = {
                'timestamp': firestore.SERVER_TIMESTAMP,
                'duration': time.time() - self.start_time,
                'total_jobs_scraped': self.total_jobs_scraped,
                'total_matches_created': self.total_matches_created,
                'total_errors': self.total_errors,
                'companies_scraped': self.companies_scraped,
                'companies_failed': self.companies_failed,
                'user_match_counts': dict(self.user_match_counts),
                'ats_metrics': dict(self.ats_metrics),
            }
            
            metrics_ref.set(metrics_data)
            logger.info(f"ðŸ“Š Metrics saved to Firestore: {metrics_id}")
        except Exception as e:
            logger.error(f"âŒ Failed to save metrics: {e}")

# ===========================================================================
#                        FIREBASE MANAGER
# ===========================================================================

class FirebaseManager:
    """Enhanced Firebase operations"""
    
    def __init__(self):
        self.user_cache = {}
        self.job_id_cache = set()
        self._db = None
        self._initialize_firebase()
    
    def _initialize_firebase(self):
        """Safe Firebase initialization"""
        try:
            # Use the singleton instance
            if firebase_singleton.initialize():
                self._db = firebase_singleton.db
                logger.info("âœ… Firebase Manager initialized successfully!")
                return True
            return False
        except Exception as e:
            logger.critical(f"âŒ Error initializing Firebase Manager: {e}")
            return False
    
    @property
    def db(self):
        """Get Firestore database instance"""
        if not self._db:
            self._initialize_firebase()
        return self._db
    
    async def get_user_id(self, email: str) -> Optional[str]:
        """Get Firebase UID from email with caching"""
        if not self._db:
            logger.error("Firebase not initialized in FirebaseManager")
            return None
            
        if email in self.user_cache:
            return self.user_cache[email]
        
        try:
            user = auth.get_user_by_email(email)
            self.user_cache[email] = user.uid
            return user.uid
        except auth.UserNotFoundError:
            logger.warning(f"âš ï¸  User not found: {email}")
            return None
        except Exception as e:
            logger.error(f"âŒ Error fetching user {email}: {e}")
            return None
    
    def generate_job_id(self, company: str, title: str) -> str:
        """Generate deterministic job ID"""
        unique_string = f"{company.lower()}:{title.lower()}"
        return hashlib.md5(unique_string.encode()).hexdigest()[:16]
    
    async def check_job_exists(self, job_id: str) -> bool:
        """Enhanced job existence check with cache"""
        if not self._db:
            return False
            
        if job_id in self.job_id_cache:
            return True
        
        try:
            job_ref = self.db.collection('jobs').document(job_id)
            doc = job_ref.get()
            
            if doc.exists:
                posted_at = doc.get('postedAt')
                if posted_at:
                    current_time = datetime.now(timezone.utc)
                    age_days = (current_time - posted_at).days
                    
                    if age_days < Config.JOB_EXPIRATION_DAYS:
                        self.job_id_cache.add(job_id)
                        return True
                else:
                    self.job_id_cache.add(job_id)
                    return True
            
            return False
        except Exception as e:
            logger.error(f"Error checking job existence: {e}")
            return False
    
    async def add_job_and_match_batch(
        self, 
        jobs_with_scores: List[Tuple[dict, dict, str]], 
        metrics: GlobalMetrics
    ) -> int:
        """Batch process jobs for better performance"""
        if not self._db:
            logger.error("Cannot add jobs: Firebase not initialized")
            return 0
            
        successful_matches = 0
        batch = self.db.batch()
        batch_count = 0
        
        for job, score_data, email in jobs_with_scores:
            try:
                user_id = await self.get_user_id(email)
                if not user_id:
                    continue
                
                job_id = self.generate_job_id(job['company'], job['title'])
                
                if await self.check_job_exists(job_id):
                    continue
                
                # Add job document
                job_ref = self.db.collection('jobs').document(job_id)
                batch.set(job_ref, {
                    'title': job['title'],
                    'company': job['company'],
                    'location': job.get('location', 'Not specified'),
                    'url': job['link'],
                    'postedAt': firestore.SERVER_TIMESTAMP,
                    'expiresAt': datetime.now(timezone.utc) + timedelta(days=Config.JOB_EXPIRATION_DAYS),
                    'source': job['source'],
                    'tags': score_data['flags'],
                    'salary': job.get('salary'),
                    'description': job.get('description', ''),
                    'requirements': job.get('requirements', []),
                    'seniority': score_data.get('seniority'),
                    'matchScore': score_data['score'],
                    'scrapedAt': firestore.SERVER_TIMESTAMP,
                }, merge=True)
                
                self.job_id_cache.add(job_id)
                
                # Create user match document
                match_id = f"{user_id}_{job_id}"
                match_ref = self.db.collection('user_job_matches').document(match_id)
                
                batch.set(match_ref, {
                    'userId': user_id,
                    'jobId': job_id,
                    'matchScore': score_data['score'],
                    'matchReasons': score_data['flags'],
                    'matchedKeywords': score_data.get('matched_keywords', []),
                    'notifiedAt': firestore.SERVER_TIMESTAMP,
                    'viewed': False,
                    'saved': False,
                    'applied': False,
                    'createdAt': firestore.SERVER_TIMESTAMP,
                }, merge=True)
                
                metrics.user_match_counts[email] += 1
                successful_matches += 1
                batch_count += 1
                
                # Commit batch when full
                if batch_count >= Config.FIREBASE_BATCH_SIZE:
                    batch.commit()
                    batch = self.db.batch()
                    batch_count = 0
                    logger.debug(f"  ðŸ’¾ Committed batch of {Config.FIREBASE_BATCH_SIZE} jobs")
                    
            except Exception as e:
                logger.error(f"âŒ Error in batch job processing: {e}")
                continue
        
        # Commit remaining batch
        if batch_count > 0:
            batch.commit()
            logger.debug(f"  ðŸ’¾ Committed final batch of {batch_count} jobs")
        
        return successful_matches

# ===========================================================================
#                        USER PROFILE LOADER (ENHANCED)
# ===========================================================================

async def load_active_profiles(firebase_manager: FirebaseManager) -> List[dict]:
    """Load all active user profiles from Firestore"""
    if not firebase_manager.db:
        logger.error("âŒ Firebase not available for loading profiles")
        return []
    
    try:
        users_ref = firebase_manager.db.collection('users')
        docs = users_ref.stream()
        
        profiles = []
        for doc in docs:
            data = doc.to_dict()
            email = data.get('email')
            
            if not email:
                continue
            
            profile = {
                'name': data.get('displayName', 'User'),
                'email': email,
                'keywords': data.get('searchKeywords', ['product manager', 'pm', 'product']),
                'seniority': data.get('seniorityLevels', ['senior', 'staff', 'lead']),
                'locations': data.get('preferredLocations', ['remote', 'san francisco', 'bay area', 'new york']),
                'min_score': data.get('minMatchScore', 40), # Default lower to catch more
                'preferred_companies': data.get('preferredCompanies', []),
                'avoid_companies': data.get('avoidCompanies', []),
                'industry_preferences': data.get('industryPreferences', ['tech', 'saas', 'ai']),
                'excludeKeywords': data.get('excludeKeywords', []),
            }
            profiles.append(profile)
        
        if not profiles:
            logger.warning("âš ï¸  No user profiles found in Firestore, using enhanced default profile")
            # FIX 3: Expanded Default Profile
            profiles = [{
                'name': 'Default User',
                'email': os.getenv('DEFAULT_USER_EMAIL', 'default@example.com'),
                'keywords': [
                    'product manager', 'product lead', 'pm', 'product management', 
                    'strategy', 'chief product officer', 'head of product', 
                    'group product manager', 'senior product manager', 'technical product manager'
                ],
                'seniority': ['senior', 'staff', 'principal', 'lead', 'executive', 'mid'],
                'locations': ['remote', 'san francisco', 'bay area', 'new york', 'austin', 'seattle'],
                'min_score': 30,
                'preferred_companies': [],
                'avoid_companies': [],
                'industry_preferences': ['tech', 'saas', 'ai', 'fintech'],
                'excludeKeywords': ['intern', 'internship', 'entry level', 'junior', 'designer', 'engineer', 'analyst'],
            }]
        
        logger.info(f"âœ… Loaded {len(profiles)} user profile(s) with enhanced settings")
        return profiles
    
    except Exception as e:
        logger.error(f"âŒ Error loading user profiles: {e}")
        return []

# ===========================================================================
#                        CLEANUP UTILITIES
# ===========================================================================

async def cleanup_expired_jobs(firebase_manager: FirebaseManager):
    """Cleanup expired jobs from Firestore"""
    if not firebase_manager.db:
        logger.error("âŒ Firebase not available for cleanup")
        return
    
    try:
        now = datetime.now(timezone.utc)
        expired_query = firebase_manager.db.collection('jobs').where('expiresAt', '<', now).stream()
        
        batch = firebase_manager.db.batch()
        count = 0
        start_time = time.time()
        
        for doc in expired_query:
            batch.delete(doc.reference)
            count += 1
            
            if count % Config.FIREBASE_BATCH_SIZE == 0:
                batch.commit()
                batch = firebase_manager.db.batch()
                elapsed = time.time() - start_time
                logger.info(f"ðŸ—‘ï¸  Deleted {count} expired jobs... ({elapsed:.1f}s)")
        
        if count % Config.FIREBASE_BATCH_SIZE != 0:
            batch.commit()
        
        if count > 0:
            elapsed = time.time() - start_time
            logger.info(f"âœ… Cleanup complete: {count} expired jobs removed in {elapsed:.1f}s")
        else:
            logger.info("âœ… No expired jobs to clean up")
            
    except Exception as e:
        logger.error(f"âŒ Error during cleanup: {e}")

# ===========================================================================
#                        SCRAPER FACTORY (FIXED & INTEGRATED)
# ===========================================================================

class ScraperFactory:
    """Multi-ATS scraper with better error handling and INTEGRATED SALARY EXTRACTION"""
    
    @staticmethod
    async def fetch_with_retry(
        session: aiohttp.ClientSession,
        target: dict,
        attempt: int = 1
    ) -> List[dict]:
        try:
            # NEW: Validate and auto-correct company ID
            is_valid = await CompanyValidator.validate_and_correct(session, target)
            if not is_valid:
                logger.warning(f"âš ï¸  {target['name']}: Invalid or inaccessible job board")
                return []
            
            limiter = rate_limiters.get(target['ats'])
            if limiter:
                await limiter.wait()
            
            jobs = await ScraperFactory._fetch_jobs(session, target)
            
            if limiter:
                limiter.record_success()
            
            return jobs
            
        except aiohttp.ClientError as e:
            logger.error(f"âŒ Network error for {target['name']} ({target['ats']}): {e}")
            
            limiter = rate_limiters.get(target['ats'])
            if limiter:
                limiter.record_error()
            
            if attempt < Config.RETRY_ATTEMPTS:
                delay = Config.RETRY_DELAY * attempt * random.uniform(0.8, 1.2)
                logger.info(f"ðŸ”„ Retrying {target['name']} in {delay:.1f}s (attempt {attempt + 1}/{Config.RETRY_ATTEMPTS})")
                await asyncio.sleep(delay)
                return await ScraperFactory.fetch_with_retry(session, target, attempt + 1)
            return []
            
        except Exception as e:
            logger.error(f"âŒ Unexpected error for {target['name']}: {e}")
            return []
    
    @staticmethod
    async def _fetch_jobs(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        jobs = []
        
        try:
            if target['ats'] == 'greenhouse':
                jobs = await ScraperFactory._fetch_greenhouse(session, target)
            elif target['ats'] == 'ashby':
                jobs = await ScraperFactory._fetch_ashby(session, target)
            elif target['ats'] == 'lever':
                jobs = await ScraperFactory._fetch_lever(session, target)
            elif target['ats'] == 'workday':
                jobs = await ScraperFactory._fetch_workday(session, target)
            else:
                logger.warning(f"âš ï¸  Unknown ATS type: {target['ats']}")
                
        except Exception as e:
            logger.error(f"Error fetching from {target['name']} ({target['ats']}): {e}")
        
        return jobs[:Config.MAX_JOBS_PER_COMPANY]
    
    @staticmethod
    async def _fetch_greenhouse(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        """Greenhouse ATS scraper - Integrated with EnhancedSalaryExtractor"""
        url = f"https://boards-api.greenhouse.io/v1/boards/{target['id']}/jobs?content=true"
        
        headers = {
            'User-Agent': random.choice(USER_AGENTS),
            'Accept': 'application/json',
        }
        
        try:
            async with session.get(url, headers=headers, timeout=Config.REQUEST_TIMEOUT) as resp:
                if resp.status != 200:
                    logger.warning(f"âš ï¸  {target['name']} returned status {resp.status}")
                    if resp.status == 429:
                        logger.warning(f"   âš ï¸ Rate limited by {target['name']}, backing off...")
                        await asyncio.sleep(5)
                    return []
                
                data = await resp.json()
                jobs = []
                
                for j in data.get('jobs', []):
                    try:
                        content = j.get('content', '')
                        description = ContentExtractor.extract_description_summary(content)
                        requirements = ContentExtractor.extract_requirements(content)
                        
                        # NEW: Enhanced salary extraction
                        job_data_for_salary = {
                            'description': content,
                            'content': content,
                            'title': j['title'],
                            'requirements': requirements
                        }
                        salary = extract_salary_from_job(job_data_for_salary)
                        
                        # Extract location - handle both formats
                        location_obj = j.get('location', {})
                        if isinstance(location_obj, dict):
                            location = location_obj.get('name', 'Remote')
                        else:
                            location = str(location_obj) if location_obj else 'Remote'
                        
                        # FIXED: Parse date correctly
                        posted_date_str = j.get('updated_at')
                        posted_days_ago = 0
                        
                        if posted_date_str:
                            try:
                                # Greenhouse date format: "2023-10-25T14:30:00Z"
                                date_str = posted_date_str.replace('Z', '+00:00')
                                posted_dt = datetime.fromisoformat(date_str)
                                current_time = datetime.now(timezone.utc)
                                posted_days_ago = (current_time - posted_dt).days
                            except Exception as date_error:
                                logger.debug(f"Could not parse date {posted_date_str}: {date_error}")
                                posted_days_ago = 0
                        
                        jobs.append({
                            'id': str(j['id']),
                            'title': j['title'],
                            'location': location,
                            'link': j.get('absolute_url', f"https://boards.greenhouse.io/{target['id']}/jobs/{j['id']}"),
                            'source': 'Greenhouse',
                            'company': target['name'],
                            'description': description,
                            'requirements': requirements,
                            'salary': salary,  # Now uses enhanced extractor
                            'posted_days_ago': posted_days_ago,
                        })
                    except Exception as e:
                        logger.error(f"Error processing Greenhouse job {j.get('id', 'unknown')}: {e}")
                        continue
                        
                return jobs
                
        except asyncio.TimeoutError:
            logger.warning(f"â° Timeout fetching from {target['name']}")
            return []
        except Exception as e:
            logger.error(f"Error in Greenhouse scraper for {target['name']}: {e}")
            return []
    
    @staticmethod
    async def _fetch_ashby(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        """Ashby ATS scraper - Integrated with EnhancedSalaryExtractor"""
        url = f"https://api.ashbyhq.com/posting-api/job-board/{target['id']}"
        
        headers = {
            'User-Agent': random.choice(USER_AGENTS),
            'Accept': 'application/json',
        }
        
        try:
            async with session.get(url, headers=headers, timeout=Config.REQUEST_TIMEOUT) as resp:
                if resp.status != 200:
                    logger.warning(f"âš ï¸  {target['name']} returned status {resp.status}")
                    return []
                
                data = await resp.json()
                jobs = []
                
                for j in data.get('jobs', []):
                    description = ContentExtractor.extract_description_summary(
                        j.get('descriptionHtml', '') or j.get('description', '')
                    )
                    requirements = ContentExtractor.extract_requirements(description)
                    
                    # NEW: Enhanced salary extraction
                    job_data_for_salary = {
                        'description': description,
                        'content': description,
                        'title': j['title'],
                        'requirements': requirements
                    }
                    salary = extract_salary_from_job(job_data_for_salary)
                    
                    jobs.append({
                        'id': str(j['id']),
                        'title': j['title'],
                        'location': j.get('location', 'Remote'),
                        'link': j['jobUrl'],
                        'source': 'Ashby',
                        'company': target['name'],
                        'description': description,
                        'requirements': requirements,
                        'salary': salary,  # Now uses enhanced extractor
                        'posted_days_ago': 0,  # Ashby doesn't provide posting date
                    })
                return jobs
                
        except asyncio.TimeoutError:
            logger.warning(f"â° Timeout fetching from {target['name']}")
            return []
        except Exception as e:
            logger.error(f"Error in Ashby scraper for {target['name']}: {e}")
            return []
    
    @staticmethod
    async def _fetch_lever(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        """Lever ATS scraper - Integrated with EnhancedSalaryExtractor"""
        url = f"https://api.lever.co/v0/postings/{target['id']}?mode=json"
        
        headers = {
            'User-Agent': random.choice(USER_AGENTS),
            'Accept': 'application/json',
        }
        
        try:
            async with session.get(url, headers=headers, timeout=Config.REQUEST_TIMEOUT) as resp:
                if resp.status != 200:
                    logger.warning(f"âš ï¸  {target['name']} returned status {resp.status}")
                    return []
                
                data = await resp.json()
                jobs = []
                
                for j in data:
                    description = j.get('descriptionPlain', '') or j.get('description', '')
                    requirements = ContentExtractor.extract_requirements(description)
                    
                    # NEW: Enhanced salary extraction
                    job_data_for_salary = {
                        'description': description,
                        'content': description,
                        'title': j['text'],
                        'requirements': requirements
                    }
                    salary = extract_salary_from_job(job_data_for_salary)
                    
                    # Calculate days since posted - Lever provides timestamp
                    posted_at = j.get('createdAt', 0)
                    days_ago = 0
                    if posted_at:
                        try:
                            posted_date = datetime.fromtimestamp(posted_at / 1000)
                            days_ago = (datetime.now() - posted_date).days
                        except:
                            pass
                    
                    jobs.append({
                        'id': str(j['id']),
                        'title': j['text'],
                        'location': j.get('categories', {}).get('location', 'Remote'),
                        'link': j['hostedUrl'],
                        'source': 'Lever',
                        'company': target['name'],
                        'description': description[:2000],
                        'requirements': requirements,
                        'salary': salary,  # Now uses enhanced extractor
                        'posted_days_ago': days_ago,
                    })
                return jobs
                
        except asyncio.TimeoutError:
            logger.warning(f"â° Timeout fetching from {target['name']}")
            return []
        except Exception as e:
            logger.error(f"Error in Lever scraper for {target['name']}: {e}")
            return []
    
    @staticmethod
    async def _fetch_workday(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        """Enhanced Workday ATS scraper for *.myworkdayjobs.com and *.myworkday.com domains"""
        company_id = target['id']
        company_name = target['name']

        # Try using pre-validated URL if available (from CompanyValidator)
        if '_validated_workday_url' in target:
            validated_url = target['_validated_workday_url']
            logger.info(f"ðŸ” Using validated Workday URL for {company_name}: {validated_url}")
            # Parse base URL from validated URL
            from urllib.parse import urlparse, urlunparse
            parsed = urlparse(validated_url)
            # Remove path to get base URL
            base_url = f"{parsed.scheme}://{parsed.netloc}"
            jobs = await ScraperFactory._try_workday_scrape(session, company_name, base_url, validated_url)
            if jobs:
                return jobs

        # Otherwise try all combinations
        domains = ['myworkdayjobs.com', 'myworkday.com']
        subdomains = ['', 'wd1', 'wd2', 'wd3', 'wd4', 'wd5']
        paths = [
            f"/{company_id}/jobs",
            f"/{company_id}/careers/jobs",
            f"/jobs",
            f"/careers/jobs"
        ]

        for domain in domains:
            for subdomain in subdomains:
                if subdomain:
                    host = f"{company_id}.{subdomain}.{domain}"
                else:
                    host = f"{company_id}.{domain}"
                base_url = f"https://{host}"

                for path in paths:
                    jobs_url = f"{base_url}{path}"
                    logger.info(f"ðŸ” Scanning {company_name} Workday at {jobs_url}")

                    jobs = await ScraperFactory._try_workday_scrape(session, company_name, base_url, jobs_url)
                    if jobs:
                        return jobs

        logger.warning(f"âš ï¸  Could not scrape Workday jobs for {company_name}")
        return []

    @staticmethod
    async def _try_workday_scrape(session: aiohttp.ClientSession, company_name: str, base_url: str, jobs_url: str) -> List[dict]:
        """Try scraping from a specific Workday URL"""
        try:
            headers = {
                'User-Agent': random.choice(USER_AGENTS),
                'Accept': 'application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Sec-Fetch-User': '?1',
            }

            # First, try to get the page to discover API endpoints
            async with session.get(jobs_url, headers=headers, timeout=Config.REQUEST_TIMEOUT) as resp:
                if resp.status != 200:
                    logger.debug(f"  âš ï¸  {company_name} URL {jobs_url} returned status {resp.status}")
                    return []

                html = await resp.text()

                # Try to extract API configuration from page scripts
                api_config = ScraperFactory._extract_workday_api_config(html, base_url)
                if api_config:
                    jobs = await ScraperFactory._fetch_workday_api(session, company_name, api_config)
                    if jobs:
                        logger.info(f"  âœ… Found {len(jobs)} jobs via API for {company_name}")
                        return jobs

                # Fallback: parse HTML for job listings
                jobs = ScraperFactory._parse_workday_html(html, company_name, base_url)
                if jobs:
                    logger.info(f"  âœ… Found {len(jobs)} jobs via HTML parsing for {company_name}")
                    return jobs

        except asyncio.TimeoutError:
            logger.debug(f"  â° Timeout for {company_name} at {jobs_url}")
        except Exception as e:
            logger.debug(f"  âŒ Error scanning {company_name} at {jobs_url}: {e}")

        return []

    @staticmethod
    def _extract_workday_api_config(html: str, base_url: str) -> Optional[dict]:
        """Extract Workday API configuration from page scripts"""
        try:
            # Pattern 1: Look for window.initialData or window.currentControlledLocale
            patterns = [
                r'window\.initialData\s*=\s*({.*?});',
                r'window\.currentControlledLocale\s*=\s*["\']([^"\']+)["\']',
                r'"tenantName"\s*:\s*["\']([^"\']+)["\']',
                r'"hostPath"\s*:\s*["\']([^"\']+)["\']',
                r'"apiEndpoint"\s*:\s*["\']([^"\']+)["\']',
                r'"tenant"\s*:\s*["\']([^"\']+)["\']',
                r'tenantName\s*:\s*["\']([^"\']+)["\']',
                r'tenant\s*:\s*["\']([^"\']+)["\']',
            ]

            config = {}

            # Find tenant name - try multiple patterns
            tenant = None
            tenant_patterns = [
                r'"tenantName"\s*:\s*["\']([^"\']+)["\']',
                r'"tenant"\s*:\s*["\']([^"\']+)["\']',
                r'tenantName\s*:\s*["\']([^"\']+)["\']',
                r'tenant\s*:\s*["\']([^"\']+)["\']',
                r'window\.initialData\s*=\s*({.*?});',  # parse JSON later
            ]
            for pattern in tenant_patterns:
                match = re.search(pattern, html, re.IGNORECASE)
                if match:
                    # If pattern matches window.initialData, parse JSON
                    if pattern.startswith('window'):
                        try:
                            import json
                            data = json.loads(match.group(1))
                            # Try to find tenant in nested structure
                            if 'tenant' in data:
                                tenant = data['tenant']
                            elif 'tenantName' in data:
                                tenant = data['tenantName']
                        except:
                            pass
                    else:
                        tenant = match.group(1)
                    if tenant:
                        break

            if tenant:
                config['tenant'] = tenant
            else:
                # Fallback: extract tenant from host (first subdomain before dot)
                from urllib.parse import urlparse
                parsed = urlparse(base_url)
                host = parsed.netloc
                # Remove subdomains like wd1, wd2 etc.
                parts = host.split('.')
                # Find the part that is not 'wd1', 'wd2', etc and not 'myworkdayjobs' or 'myworkday'
                for part in parts:
                    if not part.startswith('wd') and part not in ['myworkdayjobs', 'myworkday', 'com', 'jobs']:
                        tenant = part
                        break
                if tenant:
                    config['tenant'] = tenant
                else:
                    # Last resort: use first part
                    config['tenant'] = parts[0] if parts else 'unknown'

            # Find host path
            host_match = re.search(r'"hostPath"\s*:\s*["\']([^"\']+)["\']', html)
            if host_match:
                config['host'] = host_match.group(1)
            else:
                # Use base URL host
                from urllib.parse import urlparse
                parsed = urlparse(base_url)
                config['host'] = parsed.netloc

            # Find API endpoint pattern
            api_match = re.search(r'"apiEndpoint"\s*:\s*["\']([^"\']+)["\']', html)
            if api_match:
                config['api_path'] = api_match.group(1)
            else:
                # Default API path pattern
                config['api_path'] = '/wday/cxs/{tenant}/jobs'

            # Check if we have minimal config
            if 'tenant' in config and 'host' in config:
                # Construct full API URL
                api_url = f"https://{config['host']}{config['api_path'].format(tenant=config['tenant'])}"
                config['api_url'] = api_url
                return config

        except Exception as e:
            logger.debug(f"Error extracting Workday API config: {e}")

        return None

    @staticmethod
    async def _fetch_workday_api(session: aiohttp.ClientSession, company_name: str, config: dict) -> List[dict]:
        """Fetch jobs from Workday API"""
        jobs = []
        limit = 100
        offset = 0
        max_jobs = 500  # Safety limit

        try:
            while len(jobs) < max_jobs:
                payload = {
                    "limit": limit,
                    "offset": offset,
                    "searchText": "",
                    "appliedFacets": {},
                    "sortOrder": "newest"
                }

                headers = {
                    'User-Agent': random.choice(USER_AGENTS),
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                }

                async with session.post(config['api_url'], json=payload, headers=headers, timeout=Config.REQUEST_TIMEOUT) as resp:
                    if resp.status != 200:
                        logger.debug(f"  âš ï¸  Workday API returned status {resp.status}")
                        break

                    data = await resp.json()

                    # Extract job listings from response
                    # Workday API structure varies; try common patterns
                    job_list = data.get('jobPostings', []) or data.get('postings', []) or data.get('jobs', []) or data.get('results', []) or []

                    if not job_list:
                        # No more jobs
                        break

                    for job_data in job_list:
                        try:
                            job = ScraperFactory._parse_workday_job_data(job_data, company_name, config)
                            if job:
                                jobs.append(job)
                        except Exception as e:
                            logger.debug(f"Error parsing Workday job: {e}")
                            continue

                    # Check if we've fetched all jobs
                    total = data.get('total', 0)
                    if offset + limit >= total or len(job_list) < limit:
                        break

                    offset += limit

                    # Rate limiting
                    await asyncio.sleep(0.5)

        except Exception as e:
            logger.debug(f"Error fetching from Workday API: {e}")

        return jobs

    @staticmethod
    def _parse_workday_job_data(job_data: dict, company_name: str, config: dict) -> Optional[dict]:
        """Parse individual job from Workday API response"""
        try:
            # Extract common fields with fallbacks
            title = job_data.get('title') or job_data.get('jobTitle') or job_data.get('position') or 'Unknown Position'
            job_id = job_data.get('id') or job_data.get('jobId') or job_data.get('requisitionId') or ''

            # Location
            location = job_data.get('location') or job_data.get('locations') or job_data.get('workLocation') or 'Remote'
            if isinstance(location, list):
                location = ', '.join([loc.get('name', '') if isinstance(loc, dict) else str(loc) for loc in location])
            elif isinstance(location, dict):
                location = location.get('name', 'Remote')

            # Description
            description_html = job_data.get('description') or job_data.get('jobDescription') or job_data.get('content') or ''
            description = ContentExtractor.extract_description_summary(description_html)
            requirements = ContentExtractor.extract_requirements(description_html)

            # Salary extraction
            job_data_for_salary = {
                'description': description_html,
                'content': description_html,
                'title': title,
                'requirements': requirements
            }
            salary = extract_salary_from_job(job_data_for_salary)

            # Posted date
            posted_date_str = job_data.get('postedDate') or job_data.get('createdDate') or job_data.get('startDate') or ''
            posted_days_ago = 0
            if posted_date_str:
                try:
                    # Try to parse ISO format
                    posted_date_str = posted_date_str.replace('Z', '+00:00')
                    posted_dt = datetime.fromisoformat(posted_date_str)
                    current_time = datetime.now(timezone.utc)
                    posted_days_ago = (current_time - posted_dt).days
                except:
                    pass

            # Construct job link
            base_host = config.get('host', 'myworkday.com')
            job_path = job_data.get('externalPath') or job_data.get('applyPath') or f"/careers/job/{job_id}"
            link = f"https://{base_host}{job_path}"

            return {
                'id': job_id,
                'title': title,
                'location': location,
                'link': link,
                'source': 'Workday',
                'company': company_name,
                'description': description,
                'requirements': requirements,
                'salary': salary,
                'posted_days_ago': posted_days_ago,
            }
        except Exception as e:
            logger.debug(f"Error parsing Workday job data: {e}")
            return None

    @staticmethod
    def _parse_workday_html(html: str, company_name: str, base_url: str) -> List[dict]:
        """Fallback HTML parsing for Workday job listings"""
        jobs = []

        try:
            # Look for job cards in HTML
            # Common patterns for Workday job listings
            job_card_patterns = [
                r'<div[^>]*class="[^"]*job[^"]*"[^>]*>.*?<a[^>]*href="([^"]*)"[^>]*>.*?<span[^>]*class="[^"]*title[^"]*"[^>]*>(.*?)</span>.*?<span[^>]*class="[^"]*location[^"]*"[^>]*>(.*?)</span>',
                r'<li[^>]*data-career-site-job-id="[^"]*"[^>]*>.*?<a[^>]*href="([^"]*)"[^>]*>.*?<h3[^>]*>(.*?)</h3>.*?<div[^>]*class="[^"]*location[^"]*"[^>]*>(.*?)</div>',
            ]

            for pattern in job_card_patterns:
                matches = re.findall(pattern, html, re.DOTALL)
                for match in matches:
                    try:
                        href, title, location = match[:3]
                        # Clean up extracted strings
                        title = re.sub(r'<[^>]*>', '', title).strip()
                        location = re.sub(r'<[^>]*>', '', location).strip()

                        # Ensure absolute URL
                        if href.startswith('/'):
                            link = f"https://{urlparse(base_url).netloc}{href}"
                        else:
                            link = href

                        # Generate job ID from title
                        job_id = hashlib.md5(f"{company_name}:{title}".encode()).hexdigest()[:16]

                        jobs.append({
                            'id': job_id,
                            'title': title,
                            'location': location,
                            'link': link,
                            'source': 'Workday',
                            'company': company_name,
                            'description': '',  # Would need separate page fetch
                            'requirements': [],
                            'salary': None,
                            'posted_days_ago': 0,
                        })
                    except:
                        continue

                if jobs:
                    break

        except Exception as e:
            logger.debug(f"Error parsing Workday HTML: {e}")

        return jobs

# ===========================================================================
#                        PERFORMANCE MONITOR (OPTIONAL)
# ===========================================================================

class PerformanceMonitor:
    """Track and report performance metrics"""
    
    def __init__(self):
        self.start_time = time.time()
        self.company_timings = []
        self.requests_by_ats = defaultdict(int)
    
    def log_company(self, company: str, duration: float, ats: str, jobs: int):
        self.company_timings.append({
            'company': company,
            'duration': duration,
            'ats': ats,
            'jobs': jobs,
            'jobs_per_second': jobs / max(duration, 0.1)
        })
        self.requests_by_ats[ats] += 1
    
    def print_performance_summary(self):
        print("\n" + "="*80)
        print("ðŸ“Š PERFORMANCE ANALYSIS")
        print("="*80)
        
        total_time = time.time() - self.start_time
        print(f"â±ï¸  Total time: {total_time:.1f}s")
        
        # Show slowest companies
        print(f"\nðŸŒ 5 SLOWEST COMPANIES:")
        slowest = sorted(self.company_timings, key=lambda x: x['duration'], reverse=True)[:5]
        for item in slowest:
            print(f"   {item['company']:25} â†’ {item['duration']:5.1f}s ({item['jobs']} jobs, {item['jobs_per_second']:.1f} jobs/s)")
        
        # Show fastest companies
        print(f"\nâš¡ 5 FASTEST COMPANIES:")
        fastest = sorted(self.company_timings, key=lambda x: x['duration'])[:5]
        for item in fastest:
            print(f"   {item['company']:25} â†’ {item['duration']:5.1f}s ({item['jobs']} jobs, {item['jobs_per_second']:.1f} jobs/s)")
        
        # ATS performance
        print(f"\nðŸ”§ ATS PERFORMANCE:")
        for ats, count in sorted(self.requests_by_ats.items()):
            # Calculate average time for this ATS
            ats_times = [t['duration'] for t in self.company_timings if t['ats'] == ats]
            avg_time = sum(ats_times) / max(len(ats_times), 1)
            print(f"   {ats.upper():10} â†’ {count:3} companies, avg: {avg_time:.1f}s each")
        
        print("="*80)

# ===========================================================================
#                        MAIN ENGINE (FIXED & OPTIMIZED)
# ===========================================================================

class JobEngine:
    """Main orchestrator for the job scraping engine"""
    
    def __init__(self):
        self.fb = FirebaseManager()
        self.metrics = GlobalMetrics()
        self.analytics = AnalyticsEngine()
        self.perf_monitor = PerformanceMonitor()
        self.companies_processed = 0
    
    async def run(self):
        """Execute the full scraping pipeline"""
        logger.info("="*80)
        logger.info("ðŸš€ JOBHUNT AI - PRODUCTION SCRAPER V3.2 (INTEGRATED)")
        logger.info("="*80)
        logger.info(f"ðŸ“… Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info(f"ðŸŽ¯ Targets: {len(TARGETS)} companies (from Complete Target List)")
        logger.info(f"âš™ï¸  Config: {Config.MAX_CONCURRENCY} max concurrency, {Config.RETRY_ATTEMPTS} retries")
        logger.info(f"ðŸ“ˆ Rate Limits: Greenhouse={Config.GREENHOUSE_RATE}/s, Ashby={Config.ASHBY_RATE}/s, Lever={Config.LEVER_RATE}/s")
        
        # Step 1: Load user profiles (pass FirebaseManager instance)
        profiles = await load_active_profiles(self.fb)
        if not profiles:
            logger.error("âŒ No user profiles loaded. Exiting.")
            return
        
        logger.info(f"ðŸ‘¥ Scanning for {len(profiles)} user(s)")
        
        # Step 2: Cleanup old jobs (pass FirebaseManager instance)
        logger.info("ðŸ—‘ï¸  Cleaning up expired jobs...")
        await cleanup_expired_jobs(self.fb)
        
        # Step 3: Scrape companies with improved concurrency
        # NEW OPTIMIZATION: Removed ATS grouping overhead to honor Priority sorting strictly
        connector = aiohttp.TCPConnector(
            limit=Config.MAX_CONCURRENCY * 2,  # Doubled for better throughput
            ttl_dns_cache=600,
            force_close=False,  # Keep connections alive
            enable_cleanup_closed=True
        )
        timeout = aiohttp.ClientTimeout(total=Config.REQUEST_TIMEOUT)
        
        async with aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={'User-Agent': random.choice(USER_AGENTS)}
        ) as session:
            
            # Optimized Sequential Processing (Priority Sorted)
            logger.info(f"ðŸ” Processing {len(TARGETS)} companies in optimized priority order...")
            
            for target in TARGETS:
                await self._process_company(session, target, profiles)
        
        # Step 4: Final reporting
        if self.fb.db:
            self.metrics.save_to_firestore(self.fb.db)
            self.analytics.save_analytics_to_firestore(self.fb.db)
            
        self.metrics.print_summary()
        self.analytics.print_analytics_summary()
        self.perf_monitor.print_performance_summary()
        
        logger.info("="*80)
        logger.info("âœ… Enhanced scraping complete with fixed company IDs!")
        logger.info("="*80)
    
    async def _process_company(self, session: aiohttp.ClientSession, target: dict, profiles: List[dict]):
        """Process a single company with enhanced metrics"""
        company_start = time.time()
        company_metrics = ScraperMetrics(
            company=target['name'],
            priority=target.get('priority', 3)
        )
        
        try:
            logger.info(f"ðŸ” Scanning {target['name']} ({target['ats'].upper()}, priority: {target.get('priority', 3)})...")
            
            jobs = await ScraperFactory.fetch_with_retry(session, target)
            company_metrics.jobs_found = len(jobs)
            
            if not jobs:
                logger.warning(f"âš ï¸  {target['name']}: No jobs found")
                company_metrics.status = "success"
                self.metrics.add_company_metrics(company_metrics, target['ats'])
                return
            
            # Analyze all jobs for market insights
            for job in jobs:
                self.analytics.analyze_job(job)
            
            # Batch process matches
            jobs_with_scores = []
            total_score = 0
            
            for job in jobs:
                for profile in profiles:
                    scoring = JobScorer.calculate_score(job, profile)
                    
                    if scoring.get('rejected'):
                        continue
                        
                    total_score += scoring['score']
                    
                    if scoring['score'] >= profile.get('min_score', 40):
                        if (profile.get('avoid_companies') and 
                            target['name'] in profile['avoid_companies']):
                            continue
                            
                        if (profile.get('preferred_companies') and 
                            target['name'] not in profile['preferred_companies'] and
                            len(profile['preferred_companies']) > 0):
                            continue
                        
                        jobs_with_scores.append((job, scoring, profile['email']))
            
            # Batch insert to Firebase
            if jobs_with_scores:
                successful_matches = await self.fb.add_job_and_match_batch(
                    jobs_with_scores, 
                    self.metrics
                )
                company_metrics.jobs_matched = successful_matches
            
            company_metrics.status = "success"
            company_metrics.avg_score = total_score / max(len(jobs) * len(profiles), 1)
            
            match_rate = (company_metrics.jobs_matched / max(company_metrics.jobs_found, 1) * 100)
            logger.info(f"   âœ… {target['name']}: {len(jobs)} jobs, {company_metrics.jobs_matched} matches ({match_rate:.1f}%), avg score: {company_metrics.avg_score:.1f}")
            
        except Exception as e:
            logger.error(f"âŒ Failed to scrape {target['name']}: {e}")
            company_metrics.status = "failed"
            company_metrics.errors = 1
        
        company_metrics.duration = time.time() - company_start
        
        # Track performance
        self.perf_monitor.log_company(
            target['name'],
            company_metrics.duration,
            target['ats'],
            company_metrics.jobs_found
        )
        
        self.metrics.add_company_metrics(company_metrics, target.get('ats', 'unknown'))

        # Periodic analytics save every 50 companies
        self.companies_processed += 1
        if self.companies_processed % 50 == 0 and self.fb.db:
            logger.info(f"ðŸ“ˆ Periodic analytics save after {self.companies_processed} companies")
            self.analytics.save_analytics_to_firestore(self.fb.db)

        # Adaptive delay based on priority and errors
        delay = 0.3 if target.get('priority', 3) <= 2 else 0.5
        if company_metrics.errors > 0:
            delay *= 2
        await asyncio.sleep(delay)

# ===========================================================================
#                            ENTRY POINT (FIXED)
# ===========================================================================

if __name__ == "__main__":
    # Enhanced entry point with better error handling
    try:
        start_time = time.time()
        logger.info("ðŸ”§ Initializing JobHunt AI Scraper V3.2 (Integrated)...")
        
        # Run the enhanced engine
        asyncio.run(JobEngine().run())
        
        total_time = time.time() - start_time
        logger.info(f"â±ï¸  Total execution time: {total_time:.1f} seconds")
        
    except KeyboardInterrupt:
        logger.info("\nâš ï¸  Scraper interrupted by user")
    except Exception as e:
        logger.critical(f"ðŸ’¥ Fatal error in enhanced scraper: {e}", exc_info=True)
        sys.exit(1)
===== ./scripts/job_scraper_v2.4_backup.py =====
#!/usr/bin/env python3
"""
=============================================================================
   JOBHUNT AI - ENTERPRISE PRODUCTION ENGINE V2.5 (MAXIMIZED)
   - MARKET INTELLIGENCE: Analytics Engine Added
   - DATABASE: Full Firestore Profile Loading Restored
   - EXTRACTION: Full Regex Requirements Extraction Restored
   - TARGETS: Complete list of 100+ companies restored
   - LOGIC: Fixed Location & Relaxed Keywords (V2.4) included
=============================================================================
"""

import asyncio
import aiohttp
import logging
import sys
import re
import hashlib
import time
import os
from datetime import datetime, timedelta, timezone
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from collections import defaultdict
import random
from pathlib import Path

# --- LOAD ENVIRONMENT VARIABLES ---
from dotenv import load_dotenv
env_path = Path(__file__).parent / '.env.local'
load_dotenv(dotenv_path=env_path)

# --- WINDOWS ENCODING FIX ---
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

# --- FIREBASE SETUP ---
import firebase_admin
from firebase_admin import credentials, firestore, auth

# --- LOGGING SETUP ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s',
    handlers=[
        logging.FileHandler('scraper.log', encoding='utf-8', mode='a'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# ===========================================================================
#                            GLOBAL FIREBASE INSTANCE
# ===========================================================================

class FirebaseSingleton:
    """Singleton pattern for Firebase to avoid multiple initializations"""
    _instance = None
    _db = None
    _initialized = False
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(FirebaseSingleton, cls).__new__(cls)
        return cls._instance
    
    def initialize(self):
        """Initialize Firebase once"""
        if not self._initialized:
            try:
                if not firebase_admin._apps:
                    cred_path = os.getenv('FIREBASE_CREDENTIALS_PATH', 'serviceAccountKey.json')
                    if not os.path.exists(cred_path):
                        logger.error(f"âŒ Firebase credentials not found at: {cred_path}")
                        return False
                    
                    cred = credentials.Certificate(cred_path)
                    firebase_admin.initialize_app(cred)
                
                self._db = firestore.client()
                self._initialized = True
                logger.info("âœ… Connected to Firebase Firestore successfully!")
                return True
            except Exception as e:
                logger.critical(f"âŒ Error connecting to Firebase: {e}")
                return False
        return True
    
    @property
    def db(self):
        """Get Firestore database instance"""
        if not self._initialized:
            self.initialize()
        return self._db

# Create global Firebase instance
firebase_singleton = FirebaseSingleton()

# ===========================================================================
#                            CONFIGURATION
# ===========================================================================

class Config:
    # Environment variables with defaults
    REQUEST_TIMEOUT = int(os.getenv('REQUEST_TIMEOUT', '30'))
    MAX_CONCURRENCY = int(os.getenv('MAX_CONCURRENCY', '15'))
    RETRY_ATTEMPTS = int(os.getenv('RETRY_ATTEMPTS', '3'))
    RETRY_DELAY = float(os.getenv('RETRY_DELAY', '2.0'))
    JOB_EXPIRATION_DAYS = int(os.getenv('JOB_EXPIRATION_DAYS', '30'))
    
    # Rate limiting (requests per second per ATS)
    GREENHOUSE_RATE = float(os.getenv('GREENHOUSE_RATE', '2'))
    ASHBY_RATE = float(os.getenv('ASHBY_RATE', '1'))
    LEVER_RATE = float(os.getenv('LEVER_RATE', '2'))
    WORKDAY_RATE = float(os.getenv('WORKDAY_RATE', '1'))
    
    # Batch processing
    FIREBASE_BATCH_SIZE = 500
    MAX_JOBS_PER_COMPANY = 200
    
    # Content limits
    MAX_DESCRIPTION_LENGTH = 2000
    MAX_REQUIREMENTS = 15

# User agents for rotation
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
]

# ===========================================================================
#                            TARGET COMPANIES
# ===========================================================================

TARGETS = [
    # --- TIER 1: THE GIANTS ---
    {"name": "Airbnb", "ats": "greenhouse", "id": "airbnb", "priority": 1},
    {"name": "Stripe", "ats": "greenhouse", "id": "stripe", "priority": 1},
    {"name": "Uber", "ats": "greenhouse", "id": "uber", "priority": 1},
    {"name": "Lyft", "ats": "greenhouse", "id": "lyft", "priority": 1},
    {"name": "DoorDash", "ats": "greenhouse", "id": "doordash", "priority": 1},
    {"name": "Instacart", "ats": "greenhouse", "id": "instacart", "priority": 1},
    {"name": "Dropbox", "ats": "greenhouse", "id": "dropbox", "priority": 1},
    {"name": "Pinterest", "ats": "greenhouse", "id": "pinterest", "priority": 1},
    {"name": "Twitch", "ats": "greenhouse", "id": "twitch", "priority": 1},
    {"name": "Reddit", "ats": "greenhouse", "id": "reddit", "priority": 1},
    {"name": "Spotify", "ats": "lever", "id": "spotify", "priority": 1},
    {"name": "Netflix", "ats": "lever", "id": "netflix", "priority": 1},
    {"name": "Atlassian", "ats": "lever", "id": "atlassian", "priority": 1},
    {"name": "Palantir", "ats": "lever", "id": "palantir", "priority": 1},
    {"name": "Okta", "ats": "greenhouse", "id": "okta", "priority": 1},
    {"name": "Slack", "ats": "greenhouse", "id": "slack", "priority": 1},
    {"name": "Block", "ats": "greenhouse", "id": "block", "priority": 1},
    {"name": "Zillow", "ats": "greenhouse", "id": "zillow", "priority": 1},
    {"name": "Peloton", "ats": "greenhouse", "id": "peloton", "priority": 1},
    {"name": "Cloudflare", "ats": "greenhouse", "id": "cloudflare", "priority": 1},
    {"name": "Zoom", "ats": "greenhouse", "id": "zoom", "priority": 1},
    {"name": "DocuSign", "ats": "greenhouse", "id": "docusign", "priority": 1},
    {"name": "Roku", "ats": "greenhouse", "id": "roku", "priority": 1},
    {"name": "Snap", "ats": "greenhouse", "id": "snap", "priority": 1},
    {"name": "Wayfair", "ats": "greenhouse", "id": "wayfair", "priority": 1},
    {"name": "Box", "ats": "greenhouse", "id": "box", "priority": 1},
    {"name": "Twilio", "ats": "greenhouse", "id": "twilio", "priority": 1},
    {"name": "Splunk", "ats": "greenhouse", "id": "splunk", "priority": 1},
    {"name": "Yelp", "ats": "greenhouse", "id": "yelp", "priority": 1},
    {"name": "Zendesk", "ats": "greenhouse", "id": "zendesk", "priority": 1},
    {"name": "HubSpot", "ats": "greenhouse", "id": "hubspot", "priority": 1},
    {"name": "CrowdStrike", "ats": "greenhouse", "id": "crowdstrike", "priority": 1},
    {"name": "Snowflake", "ats": "greenhouse", "id": "snowflake", "priority": 1},
    {"name": "Datadog", "ats": "greenhouse", "id": "datadog", "priority": 1},
    {"name": "HashiCorp", "ats": "greenhouse", "id": "hashicorp", "priority": 1},
    {"name": "GitLab", "ats": "greenhouse", "id": "gitlab", "priority": 1},
    {"name": "Snyk", "ats": "greenhouse", "id": "snyk", "priority": 1},
    {"name": "MongoDB", "ats": "greenhouse", "id": "mongodb", "priority": 1},
    {"name": "Elastic", "ats": "greenhouse", "id": "elastic", "priority": 1},
    {"name": "PagerDuty", "ats": "greenhouse", "id": "pagerduty", "priority": 1},

    # --- TIER 2: AI & ML ---
    {"name": "OpenAI", "ats": "greenhouse", "id": "openai", "priority": 1},
    {"name": "Anthropic", "ats": "ashby", "id": "anthropic", "priority": 1},
    {"name": "Databricks", "ats": "greenhouse", "id": "databricks", "priority": 1},
    {"name": "Scale AI", "ats": "ashby", "id": "scale", "priority": 1},
    {"name": "Hugging Face", "ats": "ashby", "id": "huggingface", "priority": 1},
    {"name": "Cohere", "ats": "ashby", "id": "cohere", "priority": 1},
    {"name": "Jasper", "ats": "ashby", "id": "jasper", "priority": 2},
    {"name": "Perplexity", "ats": "ashby", "id": "perplexity", "priority": 2},
    {"name": "Mistral", "ats": "ashby", "id": "mistral", "priority": 2},
    {"name": "Midjourney", "ats": "ashby", "id": "midjourney", "priority": 2},
    {"name": "Runway", "ats": "ashby", "id": "runwayml", "priority": 2},
    {"name": "Character.ai", "ats": "ashby", "id": "character", "priority": 2},
    {"name": "LangChain", "ats": "ashby", "id": "langchain", "priority": 2},
    {"name": "Copy.ai", "ats": "ashby", "id": "copyai", "priority": 2},
    {"name": "Glean", "ats": "ashby", "id": "glean", "priority": 2},
    {"name": "Harvey", "ats": "ashby", "id": "harvey", "priority": 2},
    {"name": "Shield AI", "ats": "greenhouse", "id": "shieldai", "priority": 2},
    {"name": "Anduril", "ats": "greenhouse", "id": "andurilindustries", "priority": 2},
    {"name": "C3 AI", "ats": "greenhouse", "id": "c3ai", "priority": 2},
    {"name": "Nuro", "ats": "greenhouse", "id": "nuro", "priority": 2},
    {"name": "Cruise", "ats": "greenhouse", "id": "getcruise", "priority": 2},
    {"name": "Waymo", "ats": "greenhouse", "id": "waymo", "priority": 2},
    {"name": "Aurora", "ats": "greenhouse", "id": "aurora", "priority": 2},
    {"name": "Zoox", "ats": "greenhouse", "id": "zoox", "priority": 2},

    # --- TIER 3: FINTECH & CRYPTO ---
    {"name": "Robinhood", "ats": "greenhouse", "id": "robinhood", "priority": 2},
    {"name": "Coinbase", "ats": "greenhouse", "id": "coinbase", "priority": 1},
    {"name": "Affirm", "ats": "greenhouse", "id": "affirm", "priority": 2},
    {"name": "SoFi", "ats": "greenhouse", "id": "sofi", "priority": 2},
    {"name": "Chime", "ats": "greenhouse", "id": "chime", "priority": 2},
    {"name": "Brex", "ats": "greenhouse", "id": "brex", "priority": 2},
    {"name": "Ramp", "ats": "ashby", "id": "ramp", "priority": 2},
    {"name": "Mercury", "ats": "greenhouse", "id": "mercury", "priority": 2},
    {"name": "Plaid", "ats": "greenhouse", "id": "plaid", "priority": 2},
    {"name": "Kraken", "ats": "lever", "id": "kraken", "priority": 2},
    {"name": "Chainalysis", "ats": "greenhouse", "id": "chainalysis", "priority": 2},
    {"name": "Anchorage Digital", "ats": "greenhouse", "id": "anchorage", "priority": 3},
    {"name": "Carta", "ats": "greenhouse", "id": "carta", "priority": 2},
    {"name": "Bill.com", "ats": "greenhouse", "id": "billcom", "priority": 3},
    {"name": "Expensify", "ats": "greenhouse", "id": "expensify", "priority": 3},

    # --- TIER 4: SAAS & INFRASTRUCTURE ---
    {"name": "Figma", "ats": "ashby", "id": "figma", "priority": 1},
    {"name": "Notion", "ats": "ashby", "id": "notion", "priority": 1},
    {"name": "Canva", "ats": "greenhouse", "id": "canva", "priority": 1},
    {"name": "Miro", "ats": "greenhouse", "id": "miro", "priority": 2},
    {"name": "Airtable", "ats": "greenhouse", "id": "airtable", "priority": 2},
    {"name": "Rippling", "ats": "lever", "id": "rippling", "priority": 2},
    {"name": "Deel", "ats": "ashby", "id": "deel", "priority": 2},
    {"name": "Remote", "ats": "greenhouse", "id": "remote", "priority": 3},
    {"name": "Gusto", "ats": "greenhouse", "id": "gusto", "priority": 3},
    {"name": "Navan", "ats": "greenhouse", "id": "navan", "priority": 3},
    {"name": "Checkr", "ats": "greenhouse", "id": "checkr", "priority": 3},
    {"name": "Webflow", "ats": "greenhouse", "id": "webflow", "priority": 2},
    {"name": "Retool", "ats": "ashby", "id": "retool", "priority": 2},
    {"name": "Vanta", "ats": "ashby", "id": "vanta", "priority": 2},
    {"name": "Drata", "ats": "greenhouse", "id": "drata", "priority": 3},
    {"name": "Linear", "ats": "ashby", "id": "linear", "priority": 2},
    {"name": "ClickUp", "ats": "greenhouse", "id": "clickup", "priority": 3},
    {"name": "Monday.com", "ats": "greenhouse", "id": "monday", "priority": 3},
    {"name": "Asana", "ats": "greenhouse", "id": "asana", "priority": 2},
    {"name": "Coda", "ats": "greenhouse", "id": "coda", "priority": 3},
    {"name": "Zapier", "ats": "greenhouse", "id": "zapier", "priority": 2},
    {"name": "Loom", "ats": "greenhouse", "id": "loom", "priority": 3},
    {"name": "Discord", "ats": "greenhouse", "id": "discord", "priority": 2},
    {"name": "Substack", "ats": "ashby", "id": "substack", "priority": 3},
    {"name": "Patreon", "ats": "greenhouse", "id": "patreon", "priority": 3},
    {"name": "Duolingo", "ats": "greenhouse", "id": "duolingo", "priority": 2},
    {"name": "Roblox", "ats": "greenhouse", "id": "roblox", "priority": 2},
    {"name": "Unity", "ats": "greenhouse", "id": "unity-technologies", "priority": 2},
    {"name": "SpaceX", "ats": "greenhouse", "id": "spacex", "priority": 1},
    {"name": "Rivian", "ats": "greenhouse", "id": "rivian", "priority": 2},
    {"name": "Lucid Motors", "ats": "greenhouse", "id": "lucidmotors", "priority": 3},
    {"name": "Postman", "ats": "greenhouse", "id": "postman", "priority": 2},
    {"name": "Grammarly", "ats": "greenhouse", "id": "grammarly", "priority": 2},
]

# Sort targets by priority for better resource allocation
TARGETS.sort(key=lambda x: x.get('priority', 3))

COMPANY_TIERS = {
    "tier_s": ["OpenAI", "Anthropic", "Google", "Meta", "Apple", "Stripe", "Airbnb", "Netflix", "Nvidia", "SpaceX", "Databricks"],
    "tier_a": ["Scale AI", "Figma", "Notion", "Uber", "Lyft", "Coinbase", "Rippling", "DoorDash", "Snowflake", "Datadog", "Spotify"],
}

# ===========================================================================
#                        RATE LIMITER
# ===========================================================================

class RateLimiter:
    """Enhanced rate limiting with adaptive backoff"""
    
    def __init__(self, calls_per_second: float):
        self.delay = 1.0 / calls_per_second
        self.last_call = 0
        self.consecutive_errors = 0
    
    async def wait(self):
        now = asyncio.get_event_loop().time()
        time_since_last = now - self.last_call
        if time_since_last < self.delay:
            wait_time = self.delay - time_since_last
            # Add jitter to avoid thundering herd
            wait_time *= random.uniform(0.9, 1.1)
            await asyncio.sleep(wait_time)
        self.last_call = asyncio.get_event_loop().time()
    
    def record_error(self):
        self.consecutive_errors += 1
        if self.consecutive_errors > 3:
            # Adaptive backoff for repeated errors
            self.delay = min(self.delay * 1.5, 10.0)
    
    def record_success(self):
        if self.consecutive_errors > 0:
            self.consecutive_errors = 0
            # Gradually return to normal rate
            self.delay = max(self.delay * 0.9, 1.0 / 2)

rate_limiters = {
    'greenhouse': RateLimiter(Config.GREENHOUSE_RATE),
    'ashby': RateLimiter(Config.ASHBY_RATE),
    'lever': RateLimiter(Config.LEVER_RATE),
    'workday': RateLimiter(Config.WORKDAY_RATE),
}

# ===========================================================================
#                        SALARY DETECTION
# ===========================================================================

class SalaryFinder:
    """Enhanced salary extraction"""
    
    @staticmethod
    def extract(text: str) -> Optional[str]:
        if not text:
            return None
        
        patterns = [
            r'[\$Â£â‚¬]?\s*[0-9]{2,3}(?:,[0-9]{3}|[kK])?\s*-\s*[\$Â£â‚¬]?\s*[0-9]{2,3}(?:,[0-9]{3}|[kK])?',
            r'[0-9]{2,3}[kK]?\s*-\s*[0-9]{2,3}[kK]?\s*(?:USD|EUR|GBP|CAD)',
            r'\$[0-9]{2,3},[0-9]{3}\s*-\s*\$[0-9]{2,3},[0-9]{3}',
            r'[\$Â£â‚¬][0-9]{2,3}[kK]?\+?',
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, text, re.IGNORECASE)
            if matches:
                return matches[0].strip()
        
        return None
    
    @staticmethod
    def normalize_salary(salary_str: str) -> Optional[int]:
        if not salary_str:
            return None
        
        numbers = re.findall(r'[0-9]+', salary_str.replace(',', ''))
        if not numbers:
            return None
        
        base = int(numbers[0])
        
        if 'k' in salary_str.lower():
            return base * 1000
        
        return base if base > 1000 else base * 1000
    
    @staticmethod
    def extract_range(salary_str: str) -> Optional[Tuple[int, int]]:
        if not salary_str:
            return None
        
        numbers = re.findall(r'[0-9]+', salary_str.replace(',', ''))
        if len(numbers) < 2:
            return None
        
        nums = [int(n) for n in numbers[:2]]
        
        if 'k' in salary_str.lower():
            nums = [n * 1000 for n in nums]
        
        return (min(nums), max(nums))

# ===========================================================================
#                        JOB SCORING SYSTEM (TUNED)
# ===========================================================================

class JobScorer:
    """Enhanced job scoring with tuned filtering"""
    
    # USA locations allow-list
    USA_LOCATIONS = [
        'united states', 'usa', 'us', 'remote', 'anywhere', 'distributed',
        'california', 'new york', 'texas', 'florida', 'washington',
        'san francisco', 'bay area', 'los angeles', 'seattle', 'austin',
        'boston', 'chicago', 'denver', 'portland', 'san diego',
        'miami', 'atlanta', 'philadelphia', 'detroit', 'phoenix',
        'north america', 'cambridge', 'palo alto', 'mountain view'
    ]
    
    # International locations to EXPLICITLY EXCLUDE
    EXCLUDED_LOCATIONS = [
        'berlin', 'germany', 'europe', 'uk', 'london', 'paris', 'france',
        'amsterdam', 'netherlands', 'spain', 'madrid', 'barcelona',
        'italy', 'rome', 'sweden', 'stockholm', 'denmark', 'copenhagen',
        'norway', 'oslo', 'switzerland', 'zurich', 'austria', 'vienna',
        'poland', 'warsaw', 'czech', 'prague', 'hungary', 'budapest',
        'asia', 'china', 'japan', 'singapore', 'india', 'bangalore',
        'canada', 'toronto', 'vancouver', 'montreal', 'australia', 'sydney',
        'latam', 'brazil', 'mexico', 'apac', 'emea'
    ]
    
    @staticmethod
    def _is_usa_location(location: str) -> bool:
        """Check if location is likely in the USA (FIXED: PERMISSIVE MODE)"""
        # FIX 1: Allow empty or generic locations
        if not location:
            return True
        
        location_lower = location.lower()
        
        # FIX 1: Explicitly allow generic remote terms
        if any(term == location_lower for term in ['remote', 'anywhere', 'distributed', 'global', 'united states', 'usa', 'us']):
            return True
            
        # 1. Critical: Check exclusion list first
        for excluded in JobScorer.EXCLUDED_LOCATIONS:
            if excluded in location_lower:
                return False
        
        # 2. Check allow list
        for usa_loc in JobScorer.USA_LOCATIONS:
            if usa_loc in location_lower:
                return True
        
        # 3. Fallback: Default to True if it doesn't match exclusion list
        # This fixes the issue of rejecting valid jobs that don't match strict list
        return True
    
    @staticmethod
    def _safe_get_days_ago(job: dict) -> int:
        """Safely extract days_ago from job data"""
        days_ago = job.get('posted_days_ago', 999)
        if isinstance(days_ago, (int, float)):
            return int(days_ago)
        if isinstance(days_ago, str):
            try:
                if 'T' in days_ago:
                    date_str = days_ago.replace('Z', '+00:00')
                    posted_dt = datetime.fromisoformat(date_str)
                    current_time = datetime.now(timezone.utc)
                    return (current_time - posted_dt).days
                return int(float(days_ago))
            except (ValueError, TypeError):
                return 999
        return 999
    
    @staticmethod
    def calculate_score(job: dict, profile: dict) -> dict:
        score = 0
        flags = []
        
        title_lower = job['title'].lower()
        location_lower = job.get('location', '').lower()
        description_lower = job.get('description', '').lower()
        company = job['company']
        
        # ðŸš¨ STEP 0: USA LOCATION FILTER
        if not JobScorer._is_usa_location(job.get('location', '')):
            return {
                'score': 0,
                'flags': ['âŒ Non-USA location'],
                'seniority': 'unknown',
                'matched_keywords': [],
                'location_match': False,
                'days_ago': 999,
                'rejected': True,
                'rejection_reason': f"Non-USA location: {job.get('location')}"
            }
        
        # 1. KEYWORD MATCH (RELAXED)
        keyword_score = 0
        matched_keywords = []
        
        for kw in profile.get('keywords', []):
            kw_lower = kw.lower()
            
            # Check title (allow partial matches for common terms)
            if kw_lower in title_lower:
                if ' ' in kw_lower:  # Multi-word
                    keyword_score += 30
                else:  # Single word
                    keyword_score += 10
                matched_keywords.append(kw)
            
            elif kw_lower in description_lower:
                requirements_text = ' '.join(job.get('requirements', []))
                if kw_lower in requirements_text.lower():
                    keyword_score += 12
                else:
                    keyword_score += 6
                matched_keywords.append(kw)
        
        score += min(keyword_score, 50)
        
        if matched_keywords:
            flags.append(f"Keywords: {', '.join(list(set(matched_keywords))[:3])}")
        
        # 2. SENIORITY MATCH
        detected_seniority = JobScorer._extract_seniority(title_lower)
        target_seniority_levels = profile.get('seniority', [])
        
        if detected_seniority in target_seniority_levels:
            score += 25
            flags.append(f"Level: {detected_seniority.title()}")
        elif not target_seniority_levels:
            score += 15
        
        # 3. LOCATION MATCH
        target_locs = profile.get('locations', [])
        location_match = False
        
        for loc in target_locs:
            loc_lower = loc.lower()
            if (loc_lower in location_lower or 
                loc_lower in description_lower or
                JobScorer._is_location_match(loc_lower, location_lower)):
                score += 15
                flags.append(f"Location: {loc.title()}")
                location_match = True
                break
        
        if not location_match and not target_locs:
            score += 10
        
        # 4. COMPANY TIER
        if company in COMPANY_TIERS['tier_s']:
            score += 20
            flags.append("ðŸŒŸ Top Tier")
        elif company in COMPANY_TIERS['tier_a']:
            score += 15
            flags.append("â­ High Growth")
        else:
            score += 5
        
        # 5. SALARY TRANSPARENCY
        if job.get('salary'):
            score += 5
            flags.append(f"ðŸ’° {job['salary']}")
            
            salary_range = SalaryFinder.extract_range(job['salary'])
            if salary_range and salary_range[1] > 150000:
                score += 3
                flags.append("ðŸ’µ High Salary")
        
        # 6. FRESHNESS BONUS
        days_ago = JobScorer._safe_get_days_ago(job)
        
        if days_ago <= 1:
            score += 8
            flags.append("ðŸ”¥ Just Posted")
        elif days_ago <= 3:
            score += 6
            flags.append("ðŸ†• Very Fresh")
        elif days_ago <= 7:
            score += 4
            flags.append("ðŸ†• Fresh")
        elif days_ago <= 14:
            score += 2
            flags.append("ðŸ“… Recent")
        
        # 7. REMOTE FRIENDLY
        if any(remote_term in location_lower or remote_term in description_lower 
               for remote_term in ['remote', 'anywhere', 'distributed', 'virtual']):
            score += 5
            flags.append("ðŸ  Remote Friendly")
        
        # 8. NEGATIVE KEYWORD FILTER
        negative_keywords = profile.get('excludeKeywords', [
            'intern', 'internship', 'entry level', 'junior', 
            'designer', 'engineer', 'analyst', 'coordinator'
        ])
        
        for neg_kw in negative_keywords:
            if neg_kw.lower() in title_lower:
                return {
                    'score': 0,
                    'flags': flags,
                    'seniority': detected_seniority,
                    'matched_keywords': matched_keywords,
                    'location_match': location_match,
                    'days_ago': days_ago,
                    'rejected': True,
                    'rejection_reason': f"Negative keyword: {neg_kw}"
                }

        # ðŸš¨ FIX 2: RELAXED REJECTION LOGIC
        # Only reject if strictly NO keywords matched AND score is very low
        if not matched_keywords and score < 15:
            return {
                'score': 0,
                'flags': ['âš ï¸ Low relevance'],
                'seniority': detected_seniority,
                'matched_keywords': [],
                'location_match': False,
                'days_ago': days_ago,
                'rejected': True,
                'rejection_reason': 'Low score & no keywords'
            }
        
        return {
            'score': min(score, 100),
            'flags': flags,
            'seniority': detected_seniority,
            'matched_keywords': matched_keywords,
            'location_match': location_match,
            'days_ago': days_ago,
            'rejected': False
        }
    
    @staticmethod
    def _extract_seniority(title: str) -> str:
        title = title.lower()
        seniority_patterns = [
            (['vp', 'vice president', 'head of', 'director', 'chief', 'exec'], 'executive'),
            (['principal', 'distinguished', 'fellow'], 'principal'),
            (['staff', 'senior staff'], 'staff'),
            (['senior', 'sr.', 'sr '], 'senior'),
            (['lead', 'tech lead', 'engineering lead', 'manager'], 'lead'),
            (['mid', 'mid-level', 'experienced'], 'mid'),
            (['junior', 'jr.', 'entry', 'associate', 'new grad'], 'junior'),
            (['intern', 'internship'], 'intern'),
        ]
        
        for patterns, level in seniority_patterns:
            if any(pattern in title for pattern in patterns):
                return level
        return 'mid'
    
    @staticmethod
    def _is_location_match(target_loc: str, job_loc: str) -> bool:
        location_mappings = {
            'sf': 'san francisco',
            'bay area': 'san francisco',
            'nyc': 'new york',
            'la': 'los angeles',
            'austin': 'texas',
            'seattle': 'washington',
        }
        
        if target_loc in job_loc:
            return True
        
        for short, full in location_mappings.items():
            if (target_loc == short and full in job_loc) or (target_loc == full and short in job_loc):
                return True
        
        return False

# ===========================================================================
#                        CONTENT EXTRACTION
# ===========================================================================

class ContentExtractor:
    """Enhanced content extraction"""
    
    @staticmethod
    def clean_html(html_content: str) -> str:
        if not html_content:
            return ""
        
        html_content = re.sub(r'<(script|style)[^>]*>.*?</\1>', '', html_content, flags=re.DOTALL)
        
        replacements = {
            '&nbsp;': ' ', '&amp;': '&', '&lt;': '<', '&gt;': '>',
            '&quot;': '"', '&#39;': "'", '&ndash;': '-', '&mdash;': 'â€”',
        }
        
        for entity, replacement in replacements.items():
            html_content = html_content.replace(entity, replacement)
        
        html_content = re.sub(r'<br\s*/?>', '\n', html_content, flags=re.IGNORECASE)
        html_content = re.sub(r'</p>', '\n\n', html_content, flags=re.IGNORECASE)
        html_content = re.sub(r'<li>', '\nâ€¢ ', html_content, flags=re.IGNORECASE)
        
        clean_text = re.sub(r'<[^>]+>', ' ', html_content)
        
        clean_text = re.sub(r'\s+', ' ', clean_text)
        clean_text = re.sub(r'\n\s*\n', '\n\n', clean_text)
        clean_text = re.sub(r'[ \t]+', ' ', clean_text)
        
        return clean_text.strip()
    
    @staticmethod
    def extract_requirements(content: str) -> List[str]:
        if not content:
            return []
        
        patterns = [
            r'(?:Requirements?|Qualifications?|You Have|Must Have|Required Skills|You Will Need)[:\s]+(.*?)(?=\n\n|Requirements|Responsibilities|What You\'ll Do|$|Qualifications)',
            r'(?:What [Yy]ou\'ll [Bb]ring|What [Ww]e\'re [Ll]ooking [Ff]or|Ideal Candidate)[:\s]+(.*?)(?=\n\n|$|Qualifications)',
            r'(?:Minimum Qualifications|Basic Qualifications)[:\s]+(.*?)(?=\n\n|Preferred Qualifications|$|What We\'re Looking For)',
        ]
        
        all_requirements = []
        
        for pattern in patterns:
            matches = re.findall(pattern, content, re.IGNORECASE | re.DOTALL)
            for match in matches:
                bullets = re.findall(r'[â€¢\-\*â—¦â–ªâ–¶]\s*(.+?)(?=\n|$|[â€¢\-\*])', match)
                if not bullets:
                    bullets = re.findall(r'\d+\.\s*(.+?)(?=\n|$|\d+\.)', match)
                if not bullets:
                    bullets = re.findall(r'(?:^|\n)\s*[â€¢\-\*]?\s*([A-Z].+?[.!?])(?=\n|$)', match)
                
                if bullets:
                    cleaned = [b.strip() for b in bullets if len(b.strip()) > 10]
                    all_requirements.extend(cleaned)
        
        unique_reqs = []
        seen = set()
        for req in all_requirements:
            req_lower = req.lower()
            if req_lower not in seen and len(req) < 500:
                seen.add(req_lower)
                unique_reqs.append(req)
        
        return unique_reqs[:Config.MAX_REQUIREMENTS]
    
    @staticmethod
    def extract_description_summary(content: str, max_length: int = None) -> str:
        if max_length is None:
            max_length = Config.MAX_DESCRIPTION_LENGTH
            
        clean = ContentExtractor.clean_html(content)
        if len(clean) <= max_length:
            return clean
        
        truncated = clean[:max_length]
        last_period = truncated.rfind('.')
        last_exclamation = truncated.rfind('!')
        last_question = truncated.rfind('?')
        
        last_boundary = max(last_period, last_exclamation, last_question)
        
        if last_boundary > max_length * 0.7:
            return truncated[:last_boundary + 1]
        
        return truncated + "..."

# ===========================================================================
#                        ANALYTICS ENGINE (NEW)
# ===========================================================================

class AnalyticsEngine:
    """Enhanced analytics for job market insights"""
    
    def __init__(self):
        self.company_stats = defaultdict(lambda: {
            'total_jobs': 0,
            'avg_salary': 0,
            'salary_count': 0,
            'remote_ratio': 0,
            'seniority_dist': defaultdict(int),
            'role_dist': defaultdict(int),
            'locations': defaultdict(int)
        })
        
        self.role_stats = defaultdict(lambda: {
            'count': 0,
            'companies': set(),
            'avg_salary': 0,
            'salary_sum': 0,
            'salary_count': 0
        })
        
        self.salary_brackets = {
            'under_100k': 0,
            '100k_150k': 0,
            '150k_200k': 0,
            '200k_250k': 0,
            '250k_300k': 0,
            '300k_plus': 0,
            'not_specified': 0
        }
        
        self.location_stats = defaultdict(int)
        self.remote_count = 0
        self.total_jobs_analyzed = 0
    
    def analyze_job(self, job: dict):
        """Analyze a single job for insights"""
        self.total_jobs_analyzed += 1
        company = job['company']
        
        # Company stats
        self.company_stats[company]['total_jobs'] += 1
        
        # Role extraction and categorization
        title_lower = job['title'].lower()
        role_category = self._categorize_role(title_lower)
        self.company_stats[company]['role_dist'][role_category] += 1
        self.role_stats[role_category]['count'] += 1
        self.role_stats[role_category]['companies'].add(company)
        
        # Seniority analysis
        seniority = JobScorer._extract_seniority(title_lower)
        self.company_stats[company]['seniority_dist'][seniority] += 1
        
        # Location analysis
        location = job.get('location', '').lower()
        if 'remote' in location or 'anywhere' in location or 'distributed' in location:
            self.remote_count += 1
            self.company_stats[company]['remote_ratio'] += 1
        
        # Extract city/state from location
        primary_location = self._extract_primary_location(location)
        if primary_location:
            self.location_stats[primary_location] += 1
            self.company_stats[company]['locations'][primary_location] += 1
        
        # Salary analysis
        salary = job.get('salary')
        if salary:
            salary_range = SalaryFinder.extract_range(salary)
            if salary_range:
                avg_salary = sum(salary_range) / 2
                
                # Update company salary stats
                curr_avg = self.company_stats[company]['avg_salary']
                count = self.company_stats[company]['salary_count']
                
                # Standard running average formula
                self.company_stats[company]['avg_salary'] = (
                    (curr_avg * count + avg_salary) / (count + 1)
                )
                self.company_stats[company]['salary_count'] += 1
                
                # Update role salary stats
                self.role_stats[role_category]['salary_sum'] += avg_salary
                self.role_stats[role_category]['salary_count'] += 1
                self.role_stats[role_category]['avg_salary'] = (
                    self.role_stats[role_category]['salary_sum'] / 
                    self.role_stats[role_category]['salary_count']
                )
                
                # Update salary brackets
                self._update_salary_bracket(avg_salary)
    
    def _categorize_role(self, title: str) -> str:
        """Categorize job title into role categories"""
        title_lower = title.lower()
        
        categories = {
            'engineering': ['engineer', 'developer', 'architect', 'devops', 'sre', 'infrastructure', 'backend', 'frontend', 'full stack'],
            'product': ['product manager', 'pm', 'product owner', 'product lead', 'director of product', 'head of product'],
            'data': ['data scientist', 'data analyst', 'machine learning', 'ml', 'ai engineer', 'data engineer', 'analytics'],
            'design': ['designer', 'ux', 'ui', 'product design', 'creative', 'art director'],
            'marketing': ['marketing', 'growth', 'demand gen', 'brand', 'content', 'seo', 'sem'],
            'sales': ['sales', 'account executive', 'ae', 'business development', 'sdr', 'bdr', 'account manager'],
            'finance': ['finance', 'accounting', 'cfo', 'controller', 'analyst', 'treasury'],
            'hr': ['hr', 'recruiter', 'talent', 'people operations', 'human resources'],
            'operations': ['operations', 'ops', 'program manager', 'project manager', 'chief of staff'],
            'executive': ['director', 'vp', 'vice president', 'c-level', 'chief', 'head of', 'founder']
        }
        
        for category, keywords in categories.items():
            if any(keyword in title_lower for keyword in keywords):
                return category
        
        return 'other'
    
    def _extract_primary_location(self, location: str) -> Optional[str]:
        """Extract primary location from job location string"""
        if not location:
            return None
        
        # Common location patterns
        location_patterns = [
            ('san francisco', ['sf', 'san francisco', 'bay area', 'palo alto', 'mountain view', 'menlo park', 'redwood city']),
            ('new york', ['nyc', 'new york', 'manhattan', 'brooklyn']),
            ('seattle', ['seattle', 'bellevue', 'redmond', 'kirkland']),
            ('austin', ['austin', 'texas']),
            ('los angeles', ['la', 'los angeles', 'santa monica', 'culver city']),
            ('boston', ['boston', 'cambridge', 'massachusetts']),
            ('chicago', ['chicago', 'illinois']),
            ('denver', ['denver', 'colorado', 'boulder']),
            ('remote', ['remote', 'anywhere', 'distributed', 'virtual'])
        ]
        
        for primary_loc, patterns in location_patterns:
            if any(pattern in location for pattern in patterns):
                return primary_loc
        
        return None
    
    def _update_salary_bracket(self, salary: float):
        """Update salary bracket statistics"""
        if salary < 100000:
            self.salary_brackets['under_100k'] += 1
        elif salary < 150000:
            self.salary_brackets['100k_150k'] += 1
        elif salary < 200000:
            self.salary_brackets['150k_200k'] += 1
        elif salary < 250000:
            self.salary_brackets['200k_250k'] += 1
        elif salary < 300000:
            self.salary_brackets['250k_300k'] += 1
        else:
            self.salary_brackets['300k_plus'] += 1
    
    def get_top_hiring_companies(self, limit: int = 10) -> List[Tuple[str, dict]]:
        """Get top companies by number of jobs"""
        sorted_companies = sorted(
            self.company_stats.items(),
            key=lambda x: x[1]['total_jobs'],
            reverse=True
        )
        return sorted_companies[:limit]
    
    def get_highest_paying_companies(self, min_jobs: int = 5, limit: int = 10) -> List[Tuple[str, float]]:
        """Get companies with highest average salaries"""
        qualified_companies = [
            (company, data['avg_salary']) 
            for company, data in self.company_stats.items() 
            if data['salary_count'] >= min_jobs and data['avg_salary'] > 0
        ]
        
        sorted_companies = sorted(
            qualified_companies,
            key=lambda x: x[1],
            reverse=True
        )
        return sorted_companies[:limit]
    
    def get_most_popular_roles(self, limit: int = 10) -> List[Tuple[str, dict]]:
        """Get most popular job roles"""
        sorted_roles = sorted(
            self.role_stats.items(),
            key=lambda x: x[1]['count'],
            reverse=True
        )
        return sorted_roles[:limit]
    
    def get_location_insights(self, limit: int = 10) -> List[Tuple[str, int]]:
        """Get job distribution by location"""
        sorted_locations = sorted(
            self.location_stats.items(),
            key=lambda x: x[1],
            reverse=True
        )
        return sorted_locations[:limit]
    
    def print_analytics_summary(self):
        """Print comprehensive analytics summary"""
        print("\n" + "="*80)
        print("ðŸ“ˆ JOB MARKET ANALYTICS INSIGHTS")
        print("="*80)
        
        print(f"\nðŸ“Š Total Jobs Analyzed: {self.total_jobs_analyzed:,}")
        print(f"ðŸ  Remote Jobs: {self.remote_count:,} ({self.remote_count/max(self.total_jobs_analyzed,1)*100:.1f}%)")
        
        # Top hiring companies
        print(f"\nðŸ† TOP 10 HIRING COMPANIES:")
        top_hiring = self.get_top_hiring_companies(10)
        for rank, (company, stats) in enumerate(top_hiring, 1):
            remote_pct = (stats['remote_ratio']/max(stats['total_jobs'],1)*100)
            print(f"   {rank:2}. {company:25} â†’ {stats['total_jobs']:4} jobs | {remote_pct:5.1f}% remote")
        
        # Highest paying companies
        print(f"\nðŸ’° HIGHEST PAYING COMPANIES (avg salary):")
        top_paying = self.get_highest_paying_companies(min_jobs=3, limit=10)
        for rank, (company, avg_salary) in enumerate(top_paying, 1):
            print(f"   {rank:2}. {company:25} â†’ ${avg_salary:,.0f}")
        
        # Most popular roles
        print(f"\nðŸŽ¯ MOST IN-DEMAND ROLES:")
        popular_roles = self.get_most_popular_roles(10)
        for rank, (role, stats) in enumerate(popular_roles, 1):
            avg_salary = f"${stats['avg_salary']:,.0f}" if stats['avg_salary'] > 0 else "N/A"
            companies = len(stats['companies'])
            print(f"   {rank:2}. {role:20} â†’ {stats['count']:4} jobs | {avg_salary:10} | {companies:3} companies")
        
        # Salary distribution
        print(f"\nðŸ’µ SALARY DISTRIBUTION:")
        total_with_salary = sum(self.salary_brackets.values()) - self.salary_brackets['not_specified']
        if total_with_salary > 0:
            for bracket, count in self.salary_brackets.items():
                if bracket != 'not_specified':
                    pct = count/max(total_with_salary,1)*100
                    bracket_name = bracket.replace('_', '-').replace('k', 'K').title()
                    print(f"   ðŸ“Š {bracket_name:15} â†’ {count:4} jobs ({pct:5.1f}%)")
        
        # Location insights
        print(f"\nðŸ“ TOP JOB LOCATIONS:")
        top_locations = self.get_location_insights(10)
        for rank, (location, count) in enumerate(top_locations, 1):
            pct = count/max(self.total_jobs_analyzed,1)*100
            print(f"   {rank:2}. {location:20} â†’ {count:4} jobs ({pct:5.1f}%)")
        
        print("="*80)
    
    def save_analytics_to_firestore(self, db):
        """Save analytics data to Firestore for dashboard display"""
        try:
            analytics_id = f"analytics_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M')}"
            analytics_ref = db.collection('market_analytics').document(analytics_id)
            
            # Prepare data for Firestore
            analytics_data = {
                'timestamp': firestore.SERVER_TIMESTAMP,
                'total_jobs_analyzed': self.total_jobs_analyzed,
                'remote_count': self.remote_count,
                'salary_brackets': dict(self.salary_brackets),
                'top_companies': [
                    {
                        'company': company,
                        'total_jobs': stats['total_jobs'],
                        'avg_salary': stats['avg_salary'],
                        'remote_ratio': stats['remote_ratio']/max(stats['total_jobs'],1)*100,
                    }
                    for company, stats in self.get_top_hiring_companies(20)
                ],
                'top_roles': [
                    {
                        'role': role,
                        'count': stats['count'],
                        'avg_salary': stats['avg_salary'],
                        'company_count': len(stats['companies'])
                    }
                    for role, stats in self.get_most_popular_roles(15)
                ],
                'top_locations': [
                    {'location': loc, 'count': count}
                    for loc, count in self.get_location_insights(15)
                ],
                'salary_insights': {
                    'highest_paying_companies': [
                        {'company': company, 'avg_salary': salary}
                        for company, salary in self.get_highest_paying_companies(min_jobs=3, limit=10)
                    ],
                    'salary_distribution': dict(self.salary_brackets)
                }
            }
            
            analytics_ref.set(analytics_data)
            logger.info(f"ðŸ“ˆ Analytics saved to Firestore: {analytics_id}")
            
        except Exception as e:
            logger.error(f"âŒ Failed to save analytics: {e}")

# ===========================================================================
#                        METRICS TRACKING
# ===========================================================================

@dataclass
class ScraperMetrics:
    company: str
    jobs_found: int = 0
    jobs_matched: int = 0
    errors: int = 0
    duration: float = 0.0
    status: str = "pending"
    priority: int = 3
    avg_score: float = 0.0
    scraped_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))

@dataclass
class GlobalMetrics:
    start_time: float = field(default_factory=time.time)
    total_jobs_scraped: int = 0
    total_matches_created: int = 0
    total_errors: int = 0
    companies_scraped: int = 0
    companies_failed: int = 0
    company_metrics: Dict[str, ScraperMetrics] = field(default_factory=dict)
    user_match_counts: Dict[str, int] = field(default_factory=lambda: defaultdict(int))
    ats_metrics: Dict[str, Dict] = field(default_factory=lambda: defaultdict(lambda: {'success': 0, 'failed': 0, 'jobs': 0}))
    
    def add_company_metrics(self, metrics: ScraperMetrics, ats_type: str):
        self.company_metrics[metrics.company] = metrics
        self.total_jobs_scraped += metrics.jobs_found
        self.total_matches_created += metrics.jobs_matched
        self.total_errors += metrics.errors
        self.companies_scraped += 1
        
        self.ats_metrics[ats_type]['jobs'] += metrics.jobs_found
        if metrics.status == "success":
            self.ats_metrics[ats_type]['success'] += 1
        else:
            self.ats_metrics[ats_type]['failed'] += 1
            self.companies_failed += 1
    
    def print_summary(self):
        duration = time.time() - self.start_time
        
        print("\n" + "="*80)
        print("ðŸ“Š JOBHUNT AI SCRAPER SUMMARY V2.5")
        print("="*80)
        print(f"â±ï¸  Total Runtime: {duration:.1f}s")
        print(f"ðŸ¢ Companies Scraped: {self.companies_scraped} ({self.companies_failed} failed)")
        print(f"ðŸ’¼ Total Jobs Found: {self.total_jobs_scraped}")
        print(f"âœ¨ Total Matches Created: {self.total_matches_created}")
        print(f"âŒ Total Errors: {self.total_errors}")
        print(f"ðŸ“ˆ Match Rate: {(self.total_matches_created/max(self.total_jobs_scraped,1)*100):.1f}%")
        
        if self.ats_metrics:
            print(f"\nðŸ”§ ATS Breakdown:")
            for ats, metrics in sorted(self.ats_metrics.items()):
                success_rate = (metrics['success']/max(metrics['success']+metrics['failed'],1)*100)
                print(f"   {ats.upper():10} â†’ {metrics['success']+metrics['failed']:3} companies, {metrics['jobs']:4} jobs, {success_rate:.0f}% success")
        
        if self.user_match_counts:
            print(f"\nðŸ‘¥ User Match Breakdown:")
            for email, count in sorted(self.user_match_counts.items(), key=lambda x: x[1], reverse=True):
                print(f"   {email:40} â†’ {count:3} matches")
        
        print(f"\nðŸ† Top Performing Companies:")
        sorted_metrics = sorted(
            [m for m in self.company_metrics.values() if m.status == "success"],
            key=lambda x: (x.jobs_found, -x.duration),
            reverse=True
        )[:15]
        
        for m in sorted_metrics:
            match_rate = (m.jobs_matched / m.jobs_found * 100) if m.jobs_found > 0 else 0
            print(f"   {m.company:25} â†’ {m.jobs_found:4} jobs | {m.jobs_matched:3} matches ({match_rate:.0f}%) | {m.duration:.1f}s")
        
        if self.companies_failed > 0:
            print(f"\nâš ï¸  Failed Companies:")
            failed = [m for m in self.company_metrics.values() if m.status == "failed"]
            for m in failed[:10]:
                print(f"   âŒ {m.company}")
        
        print("="*80 + "\n")
    
    def save_to_firestore(self, db):
        """Save metrics to Firestore for historical tracking"""
        try:
            metrics_id = f"scrape_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}"
            metrics_ref = db.collection('scraper_metrics').document(metrics_id)
            
            metrics_data = {
                'timestamp': firestore.SERVER_TIMESTAMP,
                'duration': time.time() - self.start_time,
                'total_jobs_scraped': self.total_jobs_scraped,
                'total_matches_created': self.total_matches_created,
                'total_errors': self.total_errors,
                'companies_scraped': self.companies_scraped,
                'companies_failed': self.companies_failed,
                'user_match_counts': dict(self.user_match_counts),
                'ats_metrics': dict(self.ats_metrics),
            }
            
            metrics_ref.set(metrics_data)
            logger.info(f"ðŸ“Š Metrics saved to Firestore: {metrics_id}")
        except Exception as e:
            logger.error(f"âŒ Failed to save metrics: {e}")

# ===========================================================================
#                        FIREBASE MANAGER
# ===========================================================================

class FirebaseManager:
    """Enhanced Firebase operations"""
    
    def __init__(self):
        self.user_cache = {}
        self.job_id_cache = set()
        self._db = None
        self._initialize_firebase()
    
    def _initialize_firebase(self):
        """Safe Firebase initialization"""
        try:
            # Use the singleton instance
            if firebase_singleton.initialize():
                self._db = firebase_singleton.db
                logger.info("âœ… Firebase Manager initialized successfully!")
                return True
            return False
        except Exception as e:
            logger.critical(f"âŒ Error initializing Firebase Manager: {e}")
            return False
    
    @property
    def db(self):
        """Get Firestore database instance"""
        if not self._db:
            self._initialize_firebase()
        return self._db
    
    async def get_user_id(self, email: str) -> Optional[str]:
        """Get Firebase UID from email with caching"""
        if not self._db:
            logger.error("Firebase not initialized in FirebaseManager")
            return None
            
        if email in self.user_cache:
            return self.user_cache[email]
        
        try:
            user = auth.get_user_by_email(email)
            self.user_cache[email] = user.uid
            return user.uid
        except auth.UserNotFoundError:
            logger.warning(f"âš ï¸  User not found: {email}")
            return None
        except Exception as e:
            logger.error(f"âŒ Error fetching user {email}: {e}")
            return None
    
    def generate_job_id(self, company: str, title: str) -> str:
        """Generate deterministic job ID"""
        unique_string = f"{company.lower()}:{title.lower()}"
        return hashlib.md5(unique_string.encode()).hexdigest()[:16]
    
    async def check_job_exists(self, job_id: str) -> bool:
        """Enhanced job existence check with cache"""
        if not self._db:
            return False
            
        if job_id in self.job_id_cache:
            return True
        
        try:
            job_ref = self.db.collection('jobs').document(job_id)
            doc = job_ref.get()
            
            if doc.exists:
                posted_at = doc.get('postedAt')
                if posted_at:
                    current_time = datetime.now(timezone.utc)
                    age_days = (current_time - posted_at).days
                    
                    if age_days < Config.JOB_EXPIRATION_DAYS:
                        self.job_id_cache.add(job_id)
                        return True
                else:
                    self.job_id_cache.add(job_id)
                    return True
            
            return False
        except Exception as e:
            logger.error(f"Error checking job existence: {e}")
            return False
    
    async def add_job_and_match_batch(
        self, 
        jobs_with_scores: List[Tuple[dict, dict, str]], 
        metrics: GlobalMetrics
    ) -> int:
        """Batch process jobs for better performance"""
        if not self._db:
            logger.error("Cannot add jobs: Firebase not initialized")
            return 0
            
        successful_matches = 0
        batch = self.db.batch()
        batch_count = 0
        
        for job, score_data, email in jobs_with_scores:
            try:
                user_id = await self.get_user_id(email)
                if not user_id:
                    continue
                
                job_id = self.generate_job_id(job['company'], job['title'])
                
                if await self.check_job_exists(job_id):
                    continue
                
                # Add job document
                job_ref = self.db.collection('jobs').document(job_id)
                batch.set(job_ref, {
                    'title': job['title'],
                    'company': job['company'],
                    'location': job.get('location', 'Not specified'),
                    'url': job['link'],
                    'postedAt': firestore.SERVER_TIMESTAMP,
                    'expiresAt': datetime.now(timezone.utc) + timedelta(days=Config.JOB_EXPIRATION_DAYS),
                    'source': job['source'],
                    'tags': score_data['flags'],
                    'salary': job.get('salary'),
                    'description': job.get('description', ''),
                    'requirements': job.get('requirements', []),
                    'seniority': score_data.get('seniority'),
                    'matchScore': score_data['score'],
                    'scrapedAt': firestore.SERVER_TIMESTAMP,
                }, merge=True)
                
                self.job_id_cache.add(job_id)
                
                # Create user match document
                match_id = f"{user_id}_{job_id}"
                match_ref = self.db.collection('user_job_matches').document(match_id)
                
                batch.set(match_ref, {
                    'userId': user_id,
                    'jobId': job_id,
                    'matchScore': score_data['score'],
                    'matchReasons': score_data['flags'],
                    'matchedKeywords': score_data.get('matched_keywords', []),
                    'notifiedAt': firestore.SERVER_TIMESTAMP,
                    'viewed': False,
                    'saved': False,
                    'applied': False,
                    'createdAt': firestore.SERVER_TIMESTAMP,
                }, merge=True)
                
                metrics.user_match_counts[email] += 1
                successful_matches += 1
                batch_count += 1
                
                # Commit batch when full
                if batch_count >= Config.FIREBASE_BATCH_SIZE:
                    batch.commit()
                    batch = self.db.batch()
                    batch_count = 0
                    logger.debug(f"  ðŸ’¾ Committed batch of {Config.FIREBASE_BATCH_SIZE} jobs")
                    
            except Exception as e:
                logger.error(f"âŒ Error in batch job processing: {e}")
                continue
        
        # Commit remaining batch
        if batch_count > 0:
            batch.commit()
            logger.debug(f"  ðŸ’¾ Committed final batch of {batch_count} jobs")
        
        return successful_matches

# ===========================================================================
#                        USER PROFILE LOADER (ENHANCED)
# ===========================================================================

async def load_active_profiles(firebase_manager: FirebaseManager) -> List[dict]:
    """Load all active user profiles from Firestore"""
    if not firebase_manager.db:
        logger.error("âŒ Firebase not available for loading profiles")
        return []
    
    try:
        users_ref = firebase_manager.db.collection('users')
        docs = users_ref.stream()
        
        profiles = []
        for doc in docs:
            data = doc.to_dict()
            email = data.get('email')
            
            if not email:
                continue
            
            profile = {
                'name': data.get('displayName', 'User'),
                'email': email,
                'keywords': data.get('searchKeywords', ['product manager', 'pm', 'product']),
                'seniority': data.get('seniorityLevels', ['senior', 'staff', 'lead']),
                'locations': data.get('preferredLocations', ['remote', 'san francisco', 'bay area', 'new york']),
                'min_score': data.get('minMatchScore', 40), # Default lower to catch more
                'preferred_companies': data.get('preferredCompanies', []),
                'avoid_companies': data.get('avoidCompanies', []),
                'industry_preferences': data.get('industryPreferences', ['tech', 'saas', 'ai']),
                'excludeKeywords': data.get('excludeKeywords', []),
            }
            profiles.append(profile)
        
        if not profiles:
            logger.warning("âš ï¸  No user profiles found in Firestore, using enhanced default profile")
            # FIX 3: Expanded Default Profile
            profiles = [{
                'name': 'Default User',
                'email': os.getenv('DEFAULT_USER_EMAIL', 'default@example.com'),
                'keywords': [
                    'product manager', 'product lead', 'pm', 'product management', 
                    'strategy', 'chief product officer', 'head of product', 
                    'group product manager', 'senior product manager', 'technical product manager'
                ],
                'seniority': ['senior', 'staff', 'principal', 'lead', 'executive', 'mid'],
                'locations': ['remote', 'san francisco', 'bay area', 'new york', 'austin', 'seattle'],
                'min_score': 30,
                'preferred_companies': [],
                'avoid_companies': [],
                'industry_preferences': ['tech', 'saas', 'ai', 'fintech'],
                'excludeKeywords': ['intern', 'internship', 'entry level', 'junior', 'designer', 'engineer', 'analyst'],
            }]
        
        logger.info(f"âœ… Loaded {len(profiles)} user profile(s) with enhanced settings")
        return profiles
    
    except Exception as e:
        logger.error(f"âŒ Error loading user profiles: {e}")
        return []

# ===========================================================================
#                        CLEANUP UTILITIES
# ===========================================================================

async def cleanup_expired_jobs(firebase_manager: FirebaseManager):
    """Cleanup expired jobs from Firestore"""
    if not firebase_manager.db:
        logger.error("âŒ Firebase not available for cleanup")
        return
    
    try:
        now = datetime.now(timezone.utc)
        expired_query = firebase_manager.db.collection('jobs').where('expiresAt', '<', now).stream()
        
        batch = firebase_manager.db.batch()
        count = 0
        start_time = time.time()
        
        for doc in expired_query:
            batch.delete(doc.reference)
            count += 1
            
            if count % Config.FIREBASE_BATCH_SIZE == 0:
                batch.commit()
                batch = firebase_manager.db.batch()
                elapsed = time.time() - start_time
                logger.info(f"ðŸ—‘ï¸  Deleted {count} expired jobs... ({elapsed:.1f}s)")
        
        if count % Config.FIREBASE_BATCH_SIZE != 0:
            batch.commit()
        
        if count > 0:
            elapsed = time.time() - start_time
            logger.info(f"âœ… Cleanup complete: {count} expired jobs removed in {elapsed:.1f}s")
        else:
            logger.info("âœ… No expired jobs to clean up")
            
    except Exception as e:
        logger.error(f"âŒ Error during cleanup: {e}")

# ===========================================================================
#                        SCRAPER FACTORY (FIXED)
# ===========================================================================

class ScraperFactory:
    """Multi-ATS scraper with better error handling"""
    
    @staticmethod
    async def fetch_with_retry(
        session: aiohttp.ClientSession,
        target: dict,
        attempt: int = 1
    ) -> List[dict]:
        try:
            limiter = rate_limiters.get(target['ats'])
            if limiter:
                await limiter.wait()
            
            jobs = await ScraperFactory._fetch_jobs(session, target)
            
            if limiter:
                limiter.record_success()
            
            return jobs
            
        except aiohttp.ClientError as e:
            logger.error(f"âŒ Network error for {target['name']} ({target['ats']}): {e}")
            
            limiter = rate_limiters.get(target['ats'])
            if limiter:
                limiter.record_error()
            
            if attempt < Config.RETRY_ATTEMPTS:
                delay = Config.RETRY_DELAY * attempt * random.uniform(0.8, 1.2)
                logger.info(f"ðŸ”„ Retrying {target['name']} in {delay:.1f}s (attempt {attempt + 1}/{Config.RETRY_ATTEMPTS})")
                await asyncio.sleep(delay)
                return await ScraperFactory.fetch_with_retry(session, target, attempt + 1)
            return []
            
        except Exception as e:
            logger.error(f"âŒ Unexpected error for {target['name']}: {e}")
            return []
    
    @staticmethod
    async def _fetch_jobs(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        jobs = []
        
        try:
            if target['ats'] == 'greenhouse':
                jobs = await ScraperFactory._fetch_greenhouse(session, target)
            elif target['ats'] == 'ashby':
                jobs = await ScraperFactory._fetch_ashby(session, target)
            elif target['ats'] == 'lever':
                jobs = await ScraperFactory._fetch_lever(session, target)
            elif target['ats'] == 'workday':
                jobs = await ScraperFactory._fetch_workday(session, target)
            else:
                logger.warning(f"âš ï¸  Unknown ATS type: {target['ats']}")
                
        except Exception as e:
            logger.error(f"Error fetching from {target['name']} ({target['ats']}): {e}")
        
        return jobs[:Config.MAX_JOBS_PER_COMPANY]
    
    @staticmethod
    async def _fetch_greenhouse(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        """Greenhouse ATS scraper - FIXED to handle date parsing correctly"""
        url = f"https://boards-api.greenhouse.io/v1/boards/{target['id']}/jobs?content=true"
        
        headers = {
            'User-Agent': random.choice(USER_AGENTS),
            'Accept': 'application/json',
        }
        
        try:
            async with session.get(url, headers=headers, timeout=Config.REQUEST_TIMEOUT) as resp:
                if resp.status != 200:
                    logger.warning(f"âš ï¸  {target['name']} returned status {resp.status}")
                    if resp.status == 429:
                        logger.warning(f"   âš ï¸ Rate limited by {target['name']}, backing off...")
                        await asyncio.sleep(5)
                    return []
                
                data = await resp.json()
                jobs = []
                
                for j in data.get('jobs', []):
                    try:
                        content = j.get('content', '')
                        description = ContentExtractor.extract_description_summary(content)
                        requirements = ContentExtractor.extract_requirements(content)
                        salary = SalaryFinder.extract(content)
                        
                        # Extract location - handle both formats
                        location_obj = j.get('location', {})
                        if isinstance(location_obj, dict):
                            location = location_obj.get('name', 'Remote')
                        else:
                            location = str(location_obj) if location_obj else 'Remote'
                        
                        # FIXED: Parse date correctly
                        posted_date_str = j.get('updated_at')
                        posted_days_ago = 0
                        
                        if posted_date_str:
                            try:
                                # Greenhouse date format: "2023-10-25T14:30:00Z"
                                # Remove trailing Z and add timezone for Python 3.7+ compatibility
                                date_str = posted_date_str.replace('Z', '+00:00')
                                posted_dt = datetime.fromisoformat(date_str)
                                current_time = datetime.now(timezone.utc)
                                posted_days_ago = (current_time - posted_dt).days
                            except Exception as date_error:
                                logger.debug(f"Could not parse date {posted_date_str}: {date_error}")
                                posted_days_ago = 0
                        
                        jobs.append({
                            'id': str(j['id']),
                            'title': j['title'],
                            'location': location,
                            'link': j.get('absolute_url', f"https://boards.greenhouse.io/{target['id']}/jobs/{j['id']}"),
                            'source': 'Greenhouse',
                            'company': target['name'],
                            'description': description,
                            'requirements': requirements,
                            'salary': salary,
                            'posted_days_ago': posted_days_ago,  # FIXED: Now an integer!
                        })
                    except Exception as e:
                        logger.error(f"Error processing Greenhouse job {j.get('id', 'unknown')}: {e}")
                        continue
                        
                return jobs
                
        except asyncio.TimeoutError:
            logger.warning(f"â° Timeout fetching from {target['name']}")
            return []
        except Exception as e:
            logger.error(f"Error in Greenhouse scraper for {target['name']}: {e}")
            return []
    
    @staticmethod
    async def _fetch_ashby(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        """Ashby ATS scraper"""
        url = f"https://api.ashbyhq.com/posting-api/job-board/{target['id']}"
        
        headers = {
            'User-Agent': random.choice(USER_AGENTS),
            'Accept': 'application/json',
        }
        
        try:
            async with session.get(url, headers=headers, timeout=Config.REQUEST_TIMEOUT) as resp:
                if resp.status != 200:
                    logger.warning(f"âš ï¸  {target['name']} returned status {resp.status}")
                    return []
                
                data = await resp.json()
                jobs = []
                
                for j in data.get('jobs', []):
                    description = ContentExtractor.extract_description_summary(
                        j.get('descriptionHtml', '') or j.get('description', '')
                    )
                    requirements = ContentExtractor.extract_requirements(description)
                    salary = SalaryFinder.extract(j.get('title', '') + ' ' + description)
                    
                    jobs.append({
                        'id': str(j['id']),
                        'title': j['title'],
                        'location': j.get('location', 'Remote'),
                        'link': j['jobUrl'],
                        'source': 'Ashby',
                        'company': target['name'],
                        'description': description,
                        'requirements': requirements,
                        'salary': salary,
                        'posted_days_ago': 0,  # Ashby doesn't provide posting date
                    })
                return jobs
                
        except asyncio.TimeoutError:
            logger.warning(f"â° Timeout fetching from {target['name']}")
            return []
        except Exception as e:
            logger.error(f"Error in Ashby scraper for {target['name']}: {e}")
            return []
    
    @staticmethod
    async def _fetch_lever(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        """Lever ATS scraper"""
        url = f"https://api.lever.co/v0/postings/{target['id']}?mode=json"
        
        headers = {
            'User-Agent': random.choice(USER_AGENTS),
            'Accept': 'application/json',
        }
        
        try:
            async with session.get(url, headers=headers, timeout=Config.REQUEST_TIMEOUT) as resp:
                if resp.status != 200:
                    logger.warning(f"âš ï¸  {target['name']} returned status {resp.status}")
                    return []
                
                data = await resp.json()
                jobs = []
                
                for j in data:
                    description = j.get('descriptionPlain', '') or j.get('description', '')
                    requirements = ContentExtractor.extract_requirements(description)
                    salary = SalaryFinder.extract(description)
                    
                    # Calculate days since posted - Lever provides timestamp
                    posted_at = j.get('createdAt', 0)
                    days_ago = 0
                    if posted_at:
                        try:
                            posted_date = datetime.fromtimestamp(posted_at / 1000)
                            days_ago = (datetime.now() - posted_date).days
                        except:
                            pass
                    
                    jobs.append({
                        'id': str(j['id']),
                        'title': j['text'],
                        'location': j.get('categories', {}).get('location', 'Remote'),
                        'link': j['hostedUrl'],
                        'source': 'Lever',
                        'company': target['name'],
                        'description': description[:2000],
                        'requirements': requirements,
                        'salary': salary,
                        'posted_days_ago': days_ago,  # Already an integer
                    })
                return jobs
                
        except asyncio.TimeoutError:
            logger.warning(f"â° Timeout fetching from {target['name']}")
            return []
        except Exception as e:
            logger.error(f"Error in Lever scraper for {target['name']}: {e}")
            return []
    
    @staticmethod
    async def _fetch_workday(session: aiohttp.ClientSession, target: dict) -> List[dict]:
        """Workday ATS placeholder"""
        logger.info(f"â„¹ï¸  Workday scraper not yet implemented for {target['name']}")
        return []

# ===========================================================================
#                        MAIN ENGINE (FIXED)
# ===========================================================================

class JobEngine:
    """Main orchestrator for the job scraping engine"""
    
    def __init__(self):
        self.fb = FirebaseManager()
        self.metrics = GlobalMetrics()
        self.analytics = AnalyticsEngine()  # New: Analytics engine
    
    async def run(self):
        """Execute the full scraping pipeline"""
        logger.info("="*80)
        logger.info("ðŸš€ JOBHUNT AI - PRODUCTION SCRAPER V2.5 (FIXED & ANALYTICS)")
        logger.info("="*80)
        logger.info(f"ðŸ“… Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info(f"ðŸŽ¯ Targets: {len(TARGETS)} companies (sorted by priority)")
        logger.info(f"âš™ï¸  Config: {15} max concurrency, {3} retries")
        
        # Step 1: Load user profiles (pass FirebaseManager instance)
        profiles = await load_active_profiles(self.fb)
        if not profiles:
            logger.error("âŒ No user profiles loaded. Exiting.")
            return
        
        logger.info(f"ðŸ‘¥ Scanning for {len(profiles)} user(s)")
        
        # Step 2: Cleanup old jobs (pass FirebaseManager instance)
        logger.info("ðŸ—‘ï¸  Cleaning up expired jobs...")
        await cleanup_expired_jobs(self.fb)
        
        # Step 3: Scrape companies with improved concurrency
        connector = aiohttp.TCPConnector(
            limit=Config.MAX_CONCURRENCY,
            ttl_dns_cache=300
        )
        timeout = aiohttp.ClientTimeout(total=Config.REQUEST_TIMEOUT)
        
        async with aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={'User-Agent': random.choice(USER_AGENTS)}
        ) as session:
            
            # Process companies by priority
            high_priority = [t for t in TARGETS if t.get('priority', 3) <= 2]
            low_priority = [t for t in TARGETS if t.get('priority', 3) > 2]
            
            logger.info(f"ðŸ” Processing {len(high_priority)} high-priority companies first...")
            
            for target in high_priority + low_priority:
                await self._process_company(session, target, profiles)
        
        # Step 4: Final reporting (pass db instance)
        if self.fb.db:
            self.metrics.save_to_firestore(self.fb.db)
            # NEW: Save analytics
            self.analytics.save_analytics_to_firestore(self.fb.db)
            
        self.metrics.print_summary()
        self.analytics.print_analytics_summary()
        
        logger.info("="*80)
        logger.info("âœ… Enhanced scraping complete!")
        logger.info("="*80)
    
    async def _process_company(self, session: aiohttp.ClientSession, target: dict, profiles: List[dict]):
        """Process a single company with enhanced metrics"""
        company_start = time.time()
        company_metrics = ScraperMetrics(
            company=target['name'],
            priority=target.get('priority', 3)
        )
        
        try:
            logger.info(f"ðŸ” Scanning {target['name']} ({target['ats'].upper()}, priority: {target.get('priority', 3)})...")
            
            jobs = await ScraperFactory.fetch_with_retry(session, target)
            company_metrics.jobs_found = len(jobs)
            
            if not jobs:
                logger.warning(f"âš ï¸  {target['name']}: No jobs found")
                company_metrics.status = "success"
                self.metrics.add_company_metrics(company_metrics, target['ats'])
                return
            
            # NEW: Analyze all jobs for market insights
            for job in jobs:
                self.analytics.analyze_job(job)  # Add to analytics
            
            # Batch process matches
            jobs_with_scores = []
            total_score = 0
            
            for job in jobs:
                for profile in profiles:
                    scoring = JobScorer.calculate_score(job, profile)
                    
                    # ðŸ†• Handle explicit rejection for better logging/debugging
                    if scoring.get('rejected'):
                        # Optional: logger.debug(f"   âŒ Skipped {job['title']}: {scoring.get('rejection_reason')}")
                        continue
                        
                    total_score += scoring['score']
                    
                    if scoring['score'] >= profile.get('min_score', 40): # Tuned min_score
                        if (profile.get('avoid_companies') and 
                            target['name'] in profile['avoid_companies']):
                            continue
                            
                        if (profile.get('preferred_companies') and 
                            target['name'] not in profile['preferred_companies'] and
                            len(profile['preferred_companies']) > 0):
                            continue
                        
                        jobs_with_scores.append((job, scoring, profile['email']))
            
            # Batch insert to Firebase
            if jobs_with_scores:
                successful_matches = await self.fb.add_job_and_match_batch(
                    jobs_with_scores, 
                    self.metrics
                )
                company_metrics.jobs_matched = successful_matches
            
            company_metrics.status = "success"
            company_metrics.avg_score = total_score / max(len(jobs) * len(profiles), 1)
            
            match_rate = (company_metrics.jobs_matched / max(company_metrics.jobs_found, 1) * 100)
            logger.info(f"   âœ… {target['name']}: {len(jobs)} jobs, {company_metrics.jobs_matched} matches ({match_rate:.1f}%), avg score: {company_metrics.avg_score:.1f}")
            
        except Exception as e:
            logger.error(f"âŒ Failed to scrape {target['name']}: {e}")
            company_metrics.status = "failed"
            company_metrics.errors = 1
        
        company_metrics.duration = time.time() - company_start
        self.metrics.add_company_metrics(company_metrics, target.get('ats', 'unknown'))
        
        delay = 0.3 if target.get('priority', 3) <= 2 else 0.5
        if company_metrics.errors > 0:
            delay *= 2
        await asyncio.sleep(delay)

# ===========================================================================
#                            ENTRY POINT (FIXED)
# ===========================================================================

if __name__ == "__main__":
    # Enhanced entry point with better error handling
    try:
        start_time = time.time()
        logger.info("ðŸ”§ Initializing enhanced JobHunt AI Scraper V2.5...")
        
        # Run the enhanced engine
        asyncio.run(JobEngine().run())
        
        total_time = time.time() - start_time
        logger.info(f"â±ï¸  Total execution time: {total_time:.1f} seconds")
        
    except KeyboardInterrupt:
        logger.info("\nâš ï¸  Scraper interrupted by user")
    except Exception as e:
        logger.critical(f"ðŸ’¥ Fatal error in enhanced scraper: {e}", exc_info=True)
        sys.exit(1)
===== ./scripts/salary_extractor.py =====
import re
from typing import Optional, Tuple, List
import logging

logger = logging.getLogger(__name__)

class EnhancedSalaryExtractor:
    """Extract salary from job descriptions with 90%+ accuracy"""
    
    # Comprehensive salary patterns
    SALARY_PATTERNS = [
        # Standard ranges with currency symbols
        r'[\$Â£â‚¬Â¥]\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*[-â€“to]+\s*[\$Â£â‚¬Â¥]?\s*(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)\s*(?:per\s+year|annually|/year|/yr|p\.a\.)?',
        
        # K notation (e.g., $150k - $200k)
        r'[\$Â£â‚¬Â¥]\s*(\d{2,3})\s*[kK]\s*[-â€“to]+\s*[\$Â£â‚¬Â¥]?\s*(\d{2,3})\s*[kK]',
        
        # Written format (e.g., "between $150,000 and $200,000")
        r'between\s+[\$Â£â‚¬Â¥]\s*(\d{1,3}(?:,\d{3})*)\s+(?:and|to)\s+[\$Â£â‚¬Â¥]?\s*(\d{1,3}(?:,\d{3})*)',
        
        # Compensation/pay range
        r'(?:compensation|pay|salary)\s+(?:range|is|of)?\s*:?\s*[\$Â£â‚¬Â¥]\s*(\d{1,3}(?:,\d{3})*(?:k|K)?)\s*[-â€“to]+\s*[\$Â£â‚¬Â¥]?\s*(\d{1,3}(?:,\d{3})*(?:k|K)?)',
        
        # Annual salary format
        r'annual\s+salary\s+of\s+[\$Â£â‚¬Â¥]\s*(\d{1,3}(?:,\d{3})*)\s*[-â€“to]+\s*[\$Â£â‚¬Â¥]?\s*(\d{1,3}(?:,\d{3})*)',
        
        # Base salary + bonus (extract base)
        r'base\s+salary\s+[\$Â£â‚¬Â¥]\s*(\d{1,3}(?:,\d{3})*(?:k|K)?)\s*[-â€“to]+\s*[\$Â£â‚¬Â¥]?\s*(\d{1,3}(?:,\d{3})*(?:k|K)?)',
        
        # OTE (On-Target Earnings)
        r'OTE\s+of\s+[\$Â£â‚¬Â¥]\s*(\d{1,3}(?:,\d{3})*(?:k|K)?)\s*[-â€“to]+\s*[\$Â£â‚¬Â¥]?\s*(\d{1,3}(?:,\d{3})*(?:k|K)?)',
        
        # Single value with plus (e.g., "$150k+")
        r'[\$Â£â‚¬Â¥]\s*(\d{2,3})\s*[kK]\+',
        
        # Hourly rate (convert to annual)
        r'[\$Â£â‚¬Â¥]\s*(\d{2,3}(?:\.\d{2})?)\s*[-â€“to]+\s*[\$Â£â‚¬Â¥]?\s*(\d{2,3}(?:\.\d{2})?)\s*(?:per\s+hour|/hour|/hr|hourly)',
    ]
    
    @staticmethod
    def extract(text: str) -> Optional[str]:
        """
        Extract salary from job description text
        Returns formatted salary string or None
        """
        if not text:
            return None
        
        # Clean text for better matching
        text = text.replace('\n', ' ').replace('\r', ' ')
        text = re.sub(r'\s+', ' ', text)
        
        # Try all patterns
        for pattern in EnhancedSalaryExtractor.SALARY_PATTERNS:
            matches = re.findall(pattern, text, re.IGNORECASE)
            
            if matches:
                # Process first valid match
                for match in matches:
                    salary = EnhancedSalaryExtractor._process_match(match, pattern)
                    if salary:
                        return salary
        
        return None
    
    @staticmethod
    def _process_match(match: tuple, pattern: str) -> Optional[str]:
        """Process regex match and format salary"""
        try:
            # Check if it's a single value pattern (e.g., "$150k+")
            if len(match) == 1 or (isinstance(match, tuple) and len(match) == 1):
                value = EnhancedSalaryExtractor._normalize_value(match[0] if isinstance(match, tuple) else match)
                if value and value >= 30000:  # Minimum threshold
                    return f"${value // 1000}k+"
                return None
            
            # Range pattern
            if len(match) >= 2:
                low = EnhancedSalaryExtractor._normalize_value(match[0])
                high = EnhancedSalaryExtractor._normalize_value(match[1])
                
                # Validation
                if not low or not high:
                    return None
                
                # Ensure low < high
                if low > high:
                    low, high = high, low
                
                # Check if hourly rate (pattern contains 'hour')
                if 'hour' in pattern.lower():
                    # Convert hourly to annual (assume 40hrs/week, 52 weeks)
                    low = low * 40 * 52
                    high = high * 40 * 52
                
                # Sanity checks
                if low < 20000 or high > 2000000:  # Unrealistic ranges
                    return None
                
                if high - low > 500000:  # Range too wide
                    return None
                
                # Format output
                if low >= 1000 and high >= 1000:
                    low_k = low // 1000
                    high_k = high // 1000
                    return f"${low_k}k - ${high_k}k"
                else:
                    return f"${low:,} - ${high:,}"
            
            return None
            
        except Exception as e:
            logger.debug(f"Error processing salary match: {e}")
            return None
    
    @staticmethod
    def _normalize_value(value: str) -> Optional[int]:
        """Convert string value to integer (handling k notation)"""
        if not value:
            return None
        
        try:
            # Remove commas and spaces
            value = value.replace(',', '').replace(' ', '').strip()
            
            # Handle 'k' notation
            if value.lower().endswith('k'):
                base = float(value[:-1])
                return int(base * 1000)
            
            # Handle decimal values (hourly rates)
            if '.' in value:
                return int(float(value))
            
            # Plain integer
            return int(value)
            
        except (ValueError, TypeError):
            return None
    
    @staticmethod
    def extract_multiple(text: str) -> List[str]:
        """Extract all salary mentions from text (useful for debugging)"""
        salaries = []
        
        for pattern in EnhancedSalaryExtractor.SALARY_PATTERNS:
            matches = re.findall(pattern, text, re.IGNORECASE)
            for match in matches:
                salary = EnhancedSalaryExtractor._process_match(match, pattern)
                if salary and salary not in salaries:
                    salaries.append(salary)
        
        return salaries
    
    @staticmethod
    def extract_with_context(text: str) -> Optional[dict]:
        """Extract salary with surrounding context for verification"""
        for pattern in EnhancedSalaryExtractor.SALARY_PATTERNS:
            matches = re.finditer(pattern, text, re.IGNORECASE)
            
            for match in matches:
                salary = EnhancedSalaryExtractor._process_match(match.groups(), pattern)
                if salary:
                    # Get 100 chars before and after for context
                    start = max(0, match.start() - 100)
                    end = min(len(text), match.end() + 100)
                    context = text[start:end]
                    
                    return {
                        'salary': salary,
                        'context': context,
                        'confidence': EnhancedSalaryExtractor._calculate_confidence(context)
                    }
        
        return None
    
    @staticmethod
    def _calculate_confidence(context: str) -> float:
        """Calculate confidence score based on context"""
        confidence = 0.7  # Base confidence
        
        # Increase confidence for explicit salary keywords
        positive_keywords = [
            'base salary', 'annual salary', 'compensation', 
            'pay range', 'total compensation', 'OTE'
        ]
        
        negative_keywords = [
            'budget', 'revenue', 'funding', 'investment',
            'bonus', 'equity', 'stock options'  # These are additional, not base
        ]
        
        context_lower = context.lower()
        
        for keyword in positive_keywords:
            if keyword in context_lower:
                confidence += 0.1
        
        for keyword in negative_keywords:
            if keyword in context_lower:
                confidence -= 0.15
        
        return min(max(confidence, 0.0), 1.0)


# Integration function for job_scraper.py
def extract_salary_from_job(job_data: dict) -> Optional[str]:
    """
    Extract salary from job data (description + title)
    
    Args:
        job_data: Dict with 'description', 'title', 'content' keys
    
    Returns:
        Formatted salary string or None
    """
    extractor = EnhancedSalaryExtractor()
    
    # Priority 1: Check description
    description = job_data.get('description', '')
    salary = extractor.extract(description)
    if salary:
        return salary
    
    # Priority 2: Check raw content (for Greenhouse jobs)
    content = job_data.get('content', '')
    salary = extractor.extract(content)
    if salary:
        return salary
    
    # Priority 3: Check title (some companies put it there)
    title = job_data.get('title', '')
    salary = extractor.extract(title)
    if salary:
        return salary
    
    # Priority 4: Check requirements list
    requirements = job_data.get('requirements', [])
    if isinstance(requirements, list):
        req_text = ' '.join(requirements)
        salary = extractor.extract(req_text)
        if salary:
            return salary
    
    return None

===== ./src/app/actions/admin-actions.ts =====
// src/app/actions/admin-actions.ts - CORRECTED VERSION
'use server';

import { adminAuth } from '@/lib/firebase-admin';
import { cookies } from 'next/headers';

/**
 * Server action to trigger job scraper
 * This runs on the server, keeping CRON_SECRET secure
 */
export async function triggerJobScraper() {
  try {
    // Verify the user is authenticated and is an admin
    // You should add admin check here based on your user model
    const sessionCookie = cookies().get('session')?.value;
    
    if (!sessionCookie) {
      throw new Error('Not authenticated');
    }

    // Verify session
    const decodedClaims = await adminAuth.verifySessionCookie(sessionCookie);
    
    // Add admin check here
    // Example: if (!decodedClaims.admin) throw new Error('Not authorized');
    
    const CRON_SECRET = process.env.CRON_SECRET;
    
    if (!CRON_SECRET) {
      throw new Error('CRON_SECRET not configured');
    }

    // Call your trigger-scraper endpoint with the secret
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    const response = await fetch(`${baseUrl}/api/trigger-scraper`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${CRON_SECRET}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to trigger scraper: ${error}`);
    }

    const data = await response.json();
    return { success: true, data };
    
  } catch (error: any) {
    console.error('Trigger scraper error:', error);
    return { 
      success: false, 
      error: error.message || 'Failed to trigger scraper' 
    };
  }
}

/**
 * Server action to sync jobs
 */
export async function syncJobs() {
  try {
    const sessionCookie = cookies().get('session')?.value;
    
    if (!sessionCookie) {
      throw new Error('Not authenticated');
    }

    const decodedClaims = await adminAuth.verifySessionCookie(sessionCookie);
    // Add admin check
    
    const CRON_SECRET = process.env.CRON_SECRET;
    const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
    
    const response = await fetch(`${baseUrl}/api/sync-jobs`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${CRON_SECRET}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error('Failed to sync jobs');
    }

    const data = await response.json();
    return { success: true, data };
    
  } catch (error: any) {
    console.error('Sync jobs error:', error);
    return { 
      success: false, 
      error: error.message || 'Failed to sync jobs' 
    };
  }
}
===== ./src/app/api/analyze-job/route.ts =====
// src/app/api/analyze-job/route.ts - FIXED VERSION
import { NextResponse } from 'next/server';
import { adminDb } from '@/lib/firebase-admin';
import { verifyAuth } from '@/lib/auth-middleware';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// Rate limiter for job analysis
const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(20, '1 h'), // 20 analyses per hour
  analytics: true,
  prefix: '@upstash/ratelimit:analyze-job',
});

const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;

export async function POST(req: Request) {
  try {
    // ðŸ”’ SECURITY FIX: Verify authentication
    const userId = await verifyAuth(req);
    
    // Rate limiting
    const { success, reset, remaining } = await ratelimit.limit(userId);
    
    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);
      return NextResponse.json(
        { 
          error: 'Rate limit exceeded. Try again later.',
          retryAfter: `${retryAfter} seconds`
        }, 
        { status: 429 }
      );
    }

    const { jobId } = await req.json();

    if (!jobId) {
      return NextResponse.json({ error: 'Missing jobId' }, { status: 400 });
    }

    // Fetch user profile
    const userDoc = await adminDb.collection('users').doc(userId).get();
    if (!userDoc.exists) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    const userData = userDoc.data();

    // Fetch job details
    const jobDoc = await adminDb.collection('jobs').doc(jobId).get();
    if (!jobDoc.exists) {
      return NextResponse.json({ error: 'Job not found' }, { status: 404 });
    }

    const job = jobDoc.data();

    const prompt = `
Analyze this job posting and provide insights:

JOB DETAILS:
Title: ${job?.title}
Company: ${job?.company}
Location: ${job?.location}
Salary: ${job?.salary || 'Not specified'}
Description: ${job?.description}
Requirements: ${job?.requirements?.join(', ') || 'Not specified'}

USER PROFILE:
Skills: ${userData?.searchKeywords?.join(', ')}
Experience: ${userData?.yearsOfExperience || 'Not specified'} years
Current Title: ${userData?.currentTitle}

Provide a concise analysis (200 words max):
1. Key Requirements: Top 3 must-have skills
2. Match Assessment: How well the user's profile fits
3. Red Flags: Any concerning aspects of the job posting
4. Salary Insights: If salary info available, comment on market rate
5. Next Steps: Actionable advice for applying

Be honest and helpful.
    `;

    const aiResponse = await fetch("https://api.deepseek.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${DEEPSEEK_API_KEY}`,
      },
      body: JSON.stringify({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: "You are a career advisor analyzing job postings." },
          { role: "user", content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 500,
      }),
    });

    if (!aiResponse.ok) {
      return NextResponse.json({ 
        error: 'AI analysis failed' 
      }, { status: 500 });
    }

    const aiData = await aiResponse.json();
    const analysis = aiData.choices?.[0]?.message?.content;

    return NextResponse.json({ 
      success: true,
      analysis,
      job: {
        title: job?.title,
        company: job?.company
      }
    });

  } catch (error: any) {
    if (error.message === 'Unauthorized') {
      return NextResponse.json({ 
        error: 'Unauthorized. Please sign in.' 
      }, { status: 401 });
    }
    
    console.error("Analyze Job Error:", error);
    return NextResponse.json({ 
      error: error.message || 'Internal server error' 
    }, { status: 500 });
  }
}
===== ./src/app/api/chat/route.ts =====
// src/app/api/chat/route.ts - FIXED VERSION
import { NextResponse } from 'next/server';
import { verifyAuth } from '@/lib/auth-middleware';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// Rate limiter for chat
const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(30, '1 h'), // 30 messages per hour
  analytics: true,
  prefix: '@upstash/ratelimit:chat',
});

const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;

export async function POST(req: Request) {
  try {
    // ðŸ”’ SECURITY FIX: Verify authentication
    const userId = await verifyAuth(req);
    
    // Rate limiting
    const { success, reset } = await ratelimit.limit(userId);
    
    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);
      return NextResponse.json(
        { 
          error: 'Rate limit exceeded. Please wait before sending more messages.',
          retryAfter: `${retryAfter} seconds`
        }, 
        { status: 429 }
      );
    }

    const { messages, context } = await req.json();

    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json({ error: 'Invalid messages format' }, { status: 400 });
    }

    // Prepare system prompt with context
    const systemPrompt = `You are a helpful career assistant for JobHunt AI. 
You help users with job search, resume writing, interview prep, and career advice.

${context ? `\nCurrent Context:\n${JSON.stringify(context, null, 2)}` : ''}

Be concise, practical, and encouraging. Provide specific, actionable advice.`;

    // Call DeepSeek API
    const aiResponse = await fetch("https://api.deepseek.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${DEEPSEEK_API_KEY}`,
      },
      body: JSON.stringify({
        model: "deepseek-chat",
        messages: [
          { role: "system", content: systemPrompt },
          ...messages
        ],
        temperature: 0.7,
        max_tokens: 800,
      }),
    });

    if (!aiResponse.ok) {
      const errorText = await aiResponse.text();
      console.error("DeepSeek API Error:", errorText);
      return NextResponse.json({ 
        error: 'AI chat failed' 
      }, { status: 500 });
    }

    const aiData = await aiResponse.json();
    const reply = aiData.choices?.[0]?.message?.content;

    if (!reply) {
      return NextResponse.json({ 
        error: 'No response generated' 
      }, { status: 500 });
    }

    return NextResponse.json({ 
      success: true,
      message: reply
    });

  } catch (error: any) {
    if (error.message === 'Unauthorized') {
      return NextResponse.json({ 
        error: 'Unauthorized. Please sign in to chat.' 
      }, { status: 401 });
    }
    
    console.error("Chat Error:", error);
    return NextResponse.json({ 
      error: error.message || 'Internal server error' 
    }, { status: 500 });
  }
}
===== ./src/app/api/cron/scrape-jobs/route.ts =====
import { NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export async function POST(request: Request) {
  try {
    // Verify cron secret
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    console.log('ðŸš€ Starting job scraper...');
    
    // Get the absolute path to the script
    const scriptPath = process.cwd() + '/scripts/job_scraper.py';
    const pythonCommand = process.platform === 'win32' ? 'python' : 'python3';
    
    const { stdout, stderr } = await execAsync(
      `${pythonCommand} "${scriptPath}"`,
      { 
        timeout: 600000, // 10 min
        cwd: process.cwd() + '/scripts',
        env: { ...process.env }
      }
    );

    console.log('ðŸ“Š Scraper output:', stdout);
    if (stderr) console.error('âš ï¸ Scraper warnings:', stderr);

    // Parse the output to get stats
    const jobsMatch = stdout.match(/Total Jobs Found: (\d+)/);
    const matchesMatch = stdout.match(/Total Matches Created: (\d+)/);

    return NextResponse.json({ 
      success: true,
      message: 'Job scraper completed successfully',
      jobsScraped: jobsMatch ? parseInt(jobsMatch[1]) : 0,
      matchesCreated: matchesMatch ? parseInt(matchesMatch[1]) : 0,
      output: stdout.slice(-500) // Last 500 chars
    });

  } catch (error: any) {
    console.error('âŒ Scraper failed:', error);
    
    return NextResponse.json({ 
      error: 'Job scraper failed',
      message: error.message,
      stderr: error.stderr?.slice(-500),
      stdout: error.stdout?.slice(-500)
    }, { status: 500 });
  }
}

// Also support GET for testing
export async function GET(request: Request) {
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  return NextResponse.json({
    message: 'Cron endpoint is active. Use POST to trigger scraper.',
    timestamp: new Date().toISOString()
  });
}
===== ./src/app/api/generate-cover-letter/route.ts =====
// src/app/api/generate-cover-letter/route.ts - FIXED VERSION
import { NextResponse } from 'next/server';
import { adminDb } from '@/lib/firebase-admin';
import { verifyAuth } from '@/lib/auth-middleware';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

// Rate limiter for cover letter generation
const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(5, '1 h'), // 5 cover letters per hour
  analytics: true,
  prefix: '@upstash/ratelimit:cover-letter',
});

const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;

export async function POST(req: Request) {
  try {
    // ðŸ”’ SECURITY FIX: Verify authentication FIRST
    const userId = await verifyAuth(req);
    
    // Rate limiting by authenticated user
    const { success, reset, remaining } = await ratelimit.limit(userId);
    
    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);
      return NextResponse.json(
        { 
          error: 'Rate limit exceeded. You can generate 5 cover letters per hour.',
          retryAfter: `${retryAfter} seconds`
        }, 
        { status: 429 }
      );
    }

    // ðŸ”’ SECURITY FIX: Only get jobId from body - userId comes from token
    const { jobId } = await req.json();

    if (!jobId) {
      return NextResponse.json({ error: 'Missing jobId' }, { status: 400 });
    }

    // Fetch user's profile (using VERIFIED userId)
    const userDoc = await adminDb.collection('users').doc(userId).get();
    if (!userDoc.exists) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    const userData = userDoc.data();

    // Fetch job details
    const jobDoc = await adminDb.collection('jobs').doc(jobId).get();
    if (!jobDoc.exists) {
      return NextResponse.json({ error: 'Job not found' }, { status: 404 });
    }

    const job = jobDoc.data();

    // Build user profile
    const userProfile = `
Name: ${userData?.displayName || 'Not provided'}
Email: ${userData?.email || 'Not provided'}
Current Title: ${userData?.currentTitle || 'Not provided'}
Years of Experience: ${userData?.yearsOfExperience || 'Not specified'}

Work History:
${userData?.workHistory?.map((work: any, idx: number) => 
  `${idx + 1}. ${work.title} at ${work.company} (${work.startDate} - ${work.current ? 'Present' : work.endDate})`
).join('\n') || 'No work history provided'}

Skills: ${userData?.searchKeywords?.join(', ') || 'Not specified'}
    `.trim();

    const prompt = `
You are an expert cover letter writer. Create a professional, compelling cover letter for this job application.

CANDIDATE'S PROFILE:
${userProfile}

TARGET JOB:
Title: ${job?.title}
Company: ${job?.company}
Description: ${job?.description || 'Not provided'}

Write a professional cover letter (250-350 words) that:
1. Opens with enthusiasm for the specific role
2. Highlights 2-3 relevant experiences from their profile
3. Shows understanding of the company/role
4. Closes with a strong call to action

Use professional but authentic tone. DO NOT use generic templates.
    `;

    // Call DeepSeek API
    const aiResponse = await fetch("https://api.deepseek.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${DEEPSEEK_API_KEY}`,
      },
      body: JSON.stringify({
        model: "deepseek-chat",
        messages: [
          {
            role: "system",
            content: "You are an expert cover letter writer who creates authentic, compelling cover letters."
          },
          {
            role: "user", 
            content: prompt
          }
        ],
        temperature: 0.8,
        max_tokens: 1000,
      }),
    });

    if (!aiResponse.ok) {
      const errorText = await aiResponse.text();
      console.error("DeepSeek API Error:", errorText);
      return NextResponse.json({ 
        error: `AI API Error: ${aiResponse.status}` 
      }, { status: 500 });
    }

    const aiData = await aiResponse.json();
    const coverLetter = aiData.choices?.[0]?.message?.content;

    if (!coverLetter) {
      return NextResponse.json({ 
        error: 'Failed to generate cover letter' 
      }, { status: 500 });
    }

    return NextResponse.json({ 
      success: true,
      coverLetter,
      job: {
        title: job?.title,
        company: job?.company
      }
    });

  } catch (error: any) {
    if (error.message === 'Unauthorized') {
      return NextResponse.json({ 
        error: 'Unauthorized. Please sign in.' 
      }, { status: 401 });
    }
    
    console.error("Cover Letter Error:", error);
    return NextResponse.json({ 
      error: error.message || 'Internal server error' 
    }, { status: 500 });
  }
}
===== ./src/app/api/sync-jobs/route.ts =====
import { NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import { adminDb } from '@/lib/firebase-admin';
import { JobMatchingEngine } from '@/lib/jobs/scraper';

const execAsync = promisify(exec);

export async function POST(request: Request) {
  try {
    // Verify cron secret
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 1. Run Python scraper
    console.log('Running Python job scraper...');
    const { stdout, stderr } = await execAsync(
      'cd scripts && python job_scraper.py --no-email',
      { timeout: 600000 } // 10 min timeout
    );
    console.log('Scraper output:', stdout);

    // 2. Read jobs from SQLite
    const db = await open({
      filename: './data/job_intelligence.db',
      driver: sqlite3.Database
    });

    const newJobs = await db.all(`
      SELECT * FROM jobs 
      WHERE found_at > datetime('now', '-1 hour')
      ORDER BY score DESC
    `);

    await db.close();

    console.log(`Found ${newJobs.length} new jobs from scraper`);

    // 3. Sync to Firebase
    const batch = adminDb.batch();
    const jobsForMatching: { id: string; data: any }[] = [];

    for (const job of newJobs) {
      const jobRef = adminDb.collection('jobs').doc();
      batch.set(jobRef, {
        title: job.title,
        company: job.company,
        location: job.location,
        url: job.url,
        source: job.ats_source,
        seniority: job.seniority,
        score: job.score,
        postedAt: new Date(job.found_at),
        createdAt: new Date(),
        indexed: false,
      });
      jobsForMatching.push({ id: jobRef.id, data: job });
    }

    await batch.commit();
    console.log(`Synced ${jobsForMatching.length} jobs to Firebase`);

    // 4. Trigger AI matching
    const matcher = new JobMatchingEngine();
    await matcher.matchJobsWithUsers(jobsForMatching);

    return NextResponse.json({ 
      success: true, 
      jobsScraped: newJobs.length,
      jobsSynced: jobsForMatching.length 
    });

  } catch (error) {
    console.error('Job sync failed:', error);
    return NextResponse.json({ 
      error: 'Job sync failed', 
      details: error instanceof Error ? error.message : String(error) 
    }, { status: 500 });
  }
}
===== ./src/app/api/tailor/route.ts =====
// src/app/api/tailor/route.ts - FIXED VERSION
import { NextResponse } from 'next/server';
import { adminDb } from '@/lib/firebase-admin';
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';
import { verifyAuth } from '@/lib/auth-middleware';

// Initialize rate limiter
const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '1 h'), // 10 requests per hour
  analytics: true,
  prefix: '@upstash/ratelimit:tailor',
});

const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;

export async function POST(req: Request) {
  try {
    // ðŸ”’ SECURITY FIX: Verify authentication FIRST
    const userId = await verifyAuth(req);
    console.log('âœ… Authenticated user:', userId);

    // Rate limiting - now rate limit by authenticated userId instead of IP
    const { success, limit, reset, remaining } = await ratelimit.limit(userId);

    if (!success) {
      const retryAfter = Math.ceil((reset - Date.now()) / 1000);
      return NextResponse.json(
        { 
          error: 'Rate limit exceeded. Please try again later.',
          retryAfter: `${retryAfter} seconds`,
          limit: 10,
          window: '1 hour'
        }, 
        { 
          status: 429,
          headers: {
            'X-RateLimit-Limit': '10',
            'X-RateLimit-Remaining': remaining.toString(),
            'X-RateLimit-Reset': reset.toString(),
            'Retry-After': retryAfter.toString()
          }
        }
      );
    }

    // ðŸ”’ SECURITY FIX: Get jobId from body, but userId comes from verified token
    const { jobId, generatePDF } = await req.json();

    if (!jobId) {
      return NextResponse.json({ error: 'Missing jobId' }, { status: 400 });
    }

    console.log('ðŸ”¥ Fetching data for userId:', userId, 'jobId:', jobId);

    // 1. Fetch User's Profile Data (using VERIFIED userId)
    const userDoc = await adminDb.collection('users').doc(userId).get();
    if (!userDoc.exists) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    const userData = userDoc.data();
    console.log('âœ… User data fetched');

    // Check if user has uploaded a resume for PDF generation
    if (generatePDF && !userData?.resumeUrl) {
      return NextResponse.json({ 
        error: 'No resume found. Please upload your master resume in Settings â†’ Resume first.' 
      }, { status: 400 });
    }

    // 2. Fetch Job Details
    const jobDoc = await adminDb.collection('jobs').doc(jobId).get();
    if (!jobDoc.exists) {
      return NextResponse.json({ error: 'Job not found' }, { status: 404 });
    }

    const job = jobDoc.data();
    console.log('âœ… Job data fetched:', job?.title);

    // 3. Build user profile from structured data
    const userProfile = `
Name: ${userData?.displayName || 'Not provided'}
Email: ${userData?.email || 'Not provided'}
Phone: ${userData?.phone || 'Not provided'}
Current Title: ${userData?.currentTitle || 'Not provided'}
Location: ${userData?.location || 'Not provided'}
Years of Experience: ${userData?.yearsOfExperience || 'Not specified'}
LinkedIn: ${userData?.linkedinUrl || 'Not provided'}
Portfolio: ${userData?.portfolioUrl || 'Not provided'}
GitHub: ${userData?.githubUrl || 'Not provided'}

Work History:
${userData?.workHistory?.map((work: any, idx: number) => 
  `${idx + 1}. ${work.title} at ${work.company}
   Duration: ${work.startDate} - ${work.current ? 'Present' : work.endDate}
   Key Achievements:
   ${work.description}`
).join('\n\n') || 'No work history provided'}

Education:
${userData?.education?.map((edu: any) => 
  `- ${edu.degree} in ${edu.field} from ${edu.school} (${edu.graduationYear})`
).join('\n') || 'No education provided'}

Current Skills/Keywords: ${userData?.searchKeywords?.join(', ') || 'Not specified'}
    `.trim();

    // 4. Determine prompt type based on request
    const prompt = generatePDF ? `
You are an expert ATS Resume Writer. Your task is to tailor this person's EXISTING resume for THIS SPECIFIC JOB.

CRITICAL: Use the candidate's ACTUAL experience from their profile. Do NOT invent or change their job titles, companies, dates, or core accomplishments. Only reframe and re-emphasize what already exists.

CANDIDATE'S CURRENT PROFILE:
${userProfile}

TARGET JOB DETAILS:
Title: ${job?.title}
Company: ${job?.company}
Location: ${job?.location}
Description: ${job?.description || 'Not provided'}
Requirements: ${job?.requirements?.join(', ') || 'Not specified'}
Key Tags/Skills: ${job?.tags?.join(', ') || 'Not specified'}

YOUR TASK - GENERATE A TAILORED RESUME JSON:

Analyze the candidate's profile and rewrite it to highlight the most relevant experience for this specific job. Keep all facts accurate - only change the emphasis, ordering, and framing.

Return a JSON object with this EXACT structure:
{
  "professionalSummary": "A powerful 3-4 sentence summary that positions the candidate perfectly for this role. Use keywords from the job description naturally. Highlight their ACTUAL relevant achievements.",
  
  "skills": ["skill1", "skill2", "skill3", ...], // 15-20 skills that match the job requirements, prioritized by relevance to this role
  
  "workHistory": [
    {
      "company": "Actual Company Name from Profile",
      "title": "Actual Job Title from Profile", 
      "startDate": "Actual Start Date",
      "endDate": "Present" or "Actual End Date",
      "current": true or false,
      "description": "â€¢ Rewrite achievements to emphasize relevance to target role\\nâ€¢ Use metrics and impact from their actual experience\\nâ€¢ Highlight technical skills that match job requirements\\nâ€¢ Keep 4-6 bullets per role, focus on most relevant achievements"
    }
  ], // Include ALL work experiences, rewritten to emphasize relevance. Keep dates and titles EXACTLY as shown.
  
  "education": [
    {
      "school": "Actual School Name",
      "degree": "Actual Degree",
      "field": "Actual Field",
      "graduationYear": "Actual Year"
    }
  ] // Use EXACT education from profile
}

CRITICAL RULES:
1. Use ONLY information from the candidate's actual profile - do NOT invent experience
2. Keep company names, job titles, dates, and education EXACTLY as they appear
3. Rewrite bullet points to emphasize skills/experience relevant to the target job
4. Use POWERFUL ACTION VERBS: Architected, Led, Delivered, Optimized, Engineered, etc.
5. Include SPECIFIC METRICS where available (percentages, dollar amounts, scale, numbers)
6. Naturally incorporate JOB KEYWORDS from the job description into the bullets
7. Reorder experiences to put most relevant first if needed
8. Professional summary should connect their ACTUAL background to THIS specific role
9. Return ONLY valid JSON, no markdown formatting, no explanations, no extra text

Generate the tailored resume JSON now:
    ` : `
You are an expert ATS Resume Optimizer and Career Coach.

CANDIDATE'S CURRENT PROFILE:
${userProfile}

TARGET JOB DETAILS:
Title: ${job?.title}
Company: ${job?.company}
Location: ${job?.location}
Description: ${job?.description || 'Not provided'}
Requirements: ${job?.requirements?.join(', ') || 'Not specified'}
Key Tags/Skills: ${job?.tags?.join(', ') || 'Not specified'}

YOUR TASK:
Analyze their ACTUAL profile and provide specific suggestions for tailoring their resume to this role.

Provide:
1. **Match Analysis**: How their actual experience aligns with this role (2-3 sentences)
2. **Professional Summary Rewrite**: A 2-3 sentence summary emphasizing their relevant experience
3. **Keywords to Emphasize**: Critical ATS keywords from job description to naturally incorporate
4. **Experience Reframing**: How to rephrase their ACTUAL work experience to better match
5. **Skills to Highlight**: Top 8-10 skills most relevant to this job
6. **Recommended Changes**: Specific improvements while keeping their real experience

IMPORTANT:
- Base suggestions ONLY on their actual profile content
- Do NOT suggest inventing experiences
- Focus on reframing and repositioning their real skills
- Use markdown formatting for readability
- Keep response under 500 words

Output your suggestions now:
    `.trim();

    console.log('ðŸ¤– Calling DeepSeek API...');

    // 5. Call DeepSeek API
    const aiResponse = await fetch("https://api.deepseek.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${DEEPSEEK_API_KEY}`,
      },
      body: JSON.stringify({
        model: "deepseek-chat",
        messages: [
          {
            role: "system",
            content: generatePDF 
              ? "You are an expert resume writer who tailors resumes based on candidates' ACTUAL experience. You never invent or falsify information. Return ONLY valid JSON, no markdown formatting."
              : "You are an expert resume writer and ATS optimization specialist who provides honest, practical advice based on candidates' real experience."
          },
          {
            role: "user", 
            content: prompt
          }
        ],
        temperature: 0.7,
        max_tokens: generatePDF ? 4000 : 1000,
      }),
    });

    if (!aiResponse.ok) {
      const errorText = await aiResponse.text();
      console.error("âŒ DeepSeek API Error:", errorText);
      return NextResponse.json({ 
        error: `AI API Error: ${aiResponse.status}` 
      }, { status: 500 });
    }

    const aiData = await aiResponse.json();
    const content = aiData.choices?.[0]?.message?.content;

    if (!content) {
      return NextResponse.json({ 
        error: 'No content generated from AI' 
      }, { status: 500 });
    }

    if (generatePDF) {
      // Parse JSON response and prepare for PDF generation
      try {
        // Clean JSON response (remove markdown code blocks if present)
        let cleanedContent = content.trim();
        if (cleanedContent.startsWith('```json')) {
          cleanedContent = cleanedContent.replace(/```json\n?/g, '').replace(/```\n?/g, '');
        } else if (cleanedContent.startsWith('```')) {
          cleanedContent = cleanedContent.replace(/```\n?/g, '');
        }
        
        const resumeData = JSON.parse(cleanedContent);
        
        // Add user contact info
        const completeResumeData = {
          name: userData?.displayName || 'Your Name',
          email: userData?.email || '',
          phone: userData?.phone || '',
          location: userData?.location || '',
          linkedin: userData?.linkedinUrl,
          portfolio: userData?.portfolioUrl,
          github: userData?.githubUrl,
          targetJob: {
            title: job?.title || '',
            company: job?.company || ''
          },
          ...resumeData
        };

        console.log('âœ… Resume data parsed and ready for PDF generation');
        
        return NextResponse.json({ 
          success: true,
          resumeData: completeResumeData,
          type: 'pdf'
        });
        
      } catch (parseError: any) {
        console.error('âŒ JSON Parse Error:', parseError);
        console.error('Raw content:', content);
        return NextResponse.json({ 
          error: 'Failed to parse AI response. Please try again.',
          details: parseError.message
        }, { status: 500 });
      }
    } else {
      // Return suggestions text
      console.log('âœ… Resume suggestions generated successfully');
      return NextResponse.json({ 
        success: true,
        tailoredContent: content,
        type: 'suggestions'
      });
    }

  } catch (error: any) {
    // Handle auth errors specifically
    if (error.message === 'Unauthorized') {
      return NextResponse.json({ 
        error: 'Unauthorized. Please sign in.' 
      }, { status: 401 });
    }
    
    console.error("âŒ Tailor Error:", error);
    return NextResponse.json({ 
      error: error.message || 'Internal server error' 
    }, { status: 500 });
  }
}
===== ./src/app/api/trigger-scraper/route.ts =====
// src/app/api/trigger-scraper/route.ts - FIXED VERSION
import { NextResponse } from 'next/server';

// Use server-only secret (NOT NEXT_PUBLIC_*)
const SCRAPER_SECRET = process.env.SCRAPER_SECRET || process.env.CRON_SECRET;

export async function POST(req: Request) {
  try {
    // ðŸ”’ SECURITY FIX: Verify server secret
    const authHeader = req.headers.get('Authorization');
    const providedSecret = authHeader?.replace('Bearer ', '');

    if (!providedSecret || providedSecret !== SCRAPER_SECRET) {
      console.error('âŒ Unauthorized scraper trigger attempt');
      return NextResponse.json({ 
        error: 'Unauthorized' 
      }, { status: 401 });
    }

    console.log('âœ… Authorized scraper trigger');

    // Get GitHub token
    const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
    const GITHUB_REPO = process.env.GITHUB_REPO || 'iusmuchandra/jobhunt-ai';

    if (!GITHUB_TOKEN) {
      return NextResponse.json({ 
        error: 'GitHub token not configured' 
      }, { status: 500 });
    }

    // Trigger GitHub Actions workflow
    const response = await fetch(
      `https://api.github.com/repos/${GITHUB_REPO}/actions/workflows/scraper.yml/dispatches`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${GITHUB_TOKEN}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ref: 'main', // or your default branch
        }),
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error('GitHub Actions trigger failed:', errorText);
      return NextResponse.json({ 
        error: 'Failed to trigger scraper',
        details: errorText
      }, { status: response.status });
    }

    console.log('âœ… Scraper workflow triggered successfully');

    return NextResponse.json({ 
      success: true,
      message: 'Job scraper triggered successfully'
    });

  } catch (error: any) {
    console.error('Trigger Scraper Error:', error);
    return NextResponse.json({ 
      error: error.message || 'Internal server error' 
    }, { status: 500 });
  }
}

// Optional: Add GET endpoint for health check
export async function GET() {
  return NextResponse.json({ 
    status: 'Scraper trigger endpoint active',
    method: 'POST with Authorization header required'
  });
}
===== ./src/app/applications/page.tsx =====
"use client";

import React, { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { collection, query, where, getDocs, doc, updateDoc, deleteDoc } from 'firebase/firestore'; // Removed orderBy
import { useAuth } from '@/contexts/AuthContext';
import { 
  Briefcase, 
  Calendar, 
  Building2, 
  MapPin, 
  Search, 
  Filter, 
  Loader2,
  CheckCircle2,
  XCircle,
  Clock,
  ArrowUpRight,
  Trash2,
  TrendingUp,
  MoreHorizontal
} from 'lucide-react';
import Link from 'next/link';
import { formatDistanceToNow } from 'date-fns';

// --- UI Components ---
import { 
  Card, 
  CardContent, 
  CardHeader, 
  CardTitle 
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

// --- Interfaces ---
interface Application {
  id: string;
  jobTitle: string;
  company: string;
  location?: string;
  status: 'applied' | 'interviewing' | 'offer' | 'rejected' | 'ghosted';
  appliedAt: any;
  jobId?: string;
  notes?: string;
  salary?: string;
  matchScore?: number;
  jobUrl?: string;
}

export default function ApplicationsPage() {
  const { user } = useAuth();
  const [applications, setApplications] = useState<Application[]>([]);
  const [loading, setLoading] = useState(true);
  
  // Filters
  const [statusFilter, setStatusFilter] = useState('all');
  const [companyFilter, setCompanyFilter] = useState('all');
  const [searchQuery, setSearchQuery] = useState('');

  // --- Load Data ---
  useEffect(() => {
    async function fetchApplications() {
      if (!user) return;
      try {
        // FIXED: Removed 'orderBy' from query to prevent missing index/field issues
        const q = query(
          collection(db, 'applications'),
          where('userId', '==', user.uid)
        );
        
        const snapshot = await getDocs(q);
        
        const apps = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as Application[];

        // FIXED: Sort client-side instead
        apps.sort((a, b) => {
          const dateA = a.appliedAt?.toDate ? a.appliedAt.toDate() : new Date(0);
          const dateB = b.appliedAt?.toDate ? b.appliedAt.toDate() : new Date(0);
          return dateB - dateA; // Descending order
        });

        setApplications(apps);
      } catch (error) {
        console.error("Error fetching applications:", error);
      } finally {
        setLoading(false);
      }
    }
    fetchApplications();
  }, [user]);

  // --- Actions ---
  const handleStatusUpdate = async (appId: string, newStatus: string) => {
    try {
      const appRef = doc(db, 'applications', appId);
      await updateDoc(appRef, { status: newStatus });
      setApplications(prev => prev.map(app => 
        app.id === appId ? { ...app, status: newStatus as any } : app
      ));
    } catch (error) {
      console.error("Error updating status:", error);
    }
  };

  const handleDelete = async (appId: string) => {
    if (!confirm('Are you sure you want to remove this application?')) return;
    try {
      await deleteDoc(doc(db, 'applications', appId));
      setApplications(prev => prev.filter(app => app.id !== appId));
    } catch (error) {
      console.error("Error deleting application:", error);
    }
  };

  // --- Calculations ---
  const getCompanies = () => [...new Set(applications.map(app => app.company))];

  const getStats = () => {
    const total = applications.length;
    const interviewing = applications.filter(app => app.status === 'interviewing').length;
    const offers = applications.filter(app => app.status === 'offer').length;
    const responseRate = total > 0 ? ((interviewing + offers) / total * 100).toFixed(1) : 0;
    return { total, interviewing, offers, responseRate };
  };

  const stats = getStats();

  const filteredApps = applications.filter(app => {
    const matchesSearch = 
      app.jobTitle?.toLowerCase().includes(searchQuery.toLowerCase()) || 
      app.company?.toLowerCase().includes(searchQuery.toLowerCase());
    const matchesStatus = statusFilter === 'all' || app.status === statusFilter;
    const matchesCompany = companyFilter === 'all' || app.company === companyFilter;
    
    return matchesSearch && matchesStatus && matchesCompany;
  });

  // --- Helpers ---
  const getStatusBadge = (status: string) => {
    const styles = {
      offer: 'bg-green-500/10 text-green-400 border-green-500/20 hover:bg-green-500/20',
      interviewing: 'bg-purple-500/10 text-purple-400 border-purple-500/20 hover:bg-purple-500/20',
      rejected: 'bg-red-500/10 text-red-400 border-red-500/20 hover:bg-red-500/20',
      ghosted: 'bg-gray-500/10 text-gray-400 border-gray-500/20 hover:bg-gray-500/20',
      applied: 'bg-blue-500/10 text-blue-400 border-blue-500/20 hover:bg-blue-500/20',
    };
    // Fallback for any unknown status
    const style = styles[status as keyof typeof styles] || styles.applied;
    
    return (
      <Badge variant="outline" className={`${style} capitalize`}>
        {status}
      </Badge>
    );
  };

  if (!user) return (
    <div className="min-h-screen bg-[#0A0A0A] flex items-center justify-center">
      <Loader2 className="w-8 h-8 text-blue-500 animate-spin" />
    </div>
  );

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30">
      {/* Background Gradients */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 right-1/4 w-96 h-96 bg-blue-500/10 rounded-full blur-[120px] animate-pulse" />
        <div className="absolute bottom-0 left-1/4 w-96 h-96 bg-purple-500/10 rounded-full blur-[120px] animate-pulse animation-delay-2000" />
        <div className="absolute inset-0 opacity-10" 
          style={{ backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`, backgroundSize: '40px 40px' }} 
        />
      </div>

      <div className="max-w-7xl mx-auto p-4 md:p-8 space-y-8">
        
        {/* Header */}
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
          <div>
            <h1 className="text-4xl font-black tracking-tight mb-2">
              <span className="bg-gradient-to-r from-white via-blue-200 to-purple-200 bg-clip-text text-transparent">
                Applications Tracker
              </span>
            </h1>
            <p className="text-gray-400">Track and manage your job search progress.</p>
          </div>
          <Link href="/jobs">
            <Button className="bg-white text-black hover:bg-gray-200 rounded-xl font-bold">
              <Search className="w-4 h-4 mr-2" /> Find More Jobs
            </Button>
          </Link>
        </div>

        {/* Stats Cards */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          {[
            { label: 'Total Applications', value: stats.total, color: 'text-white', icon: Briefcase },
            { label: 'Interviewing', value: stats.interviewing, color: 'text-purple-400', icon: Calendar },
            { label: 'Offers', value: stats.offers, color: 'text-green-400', icon: CheckCircle2 },
            { label: 'Response Rate', value: `${stats.responseRate}%`, color: 'text-blue-400', icon: TrendingUp },
          ].map((stat, idx) => (
            <Card key={idx} className="bg-gray-900/50 backdrop-blur-xl border-gray-800">
              <CardContent className="p-6">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-gray-400 text-sm font-medium">{stat.label}</span>
                  <stat.icon className={`w-4 h-4 ${stat.color} opacity-80`} />
                </div>
                <div className={`text-3xl font-bold ${stat.color}`}>{stat.value}</div>
              </CardContent>
            </Card>
          ))}
        </div>

        {/* Toolbar */}
        <div className="flex flex-col md:flex-row gap-4">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-500" />
            <Input 
              placeholder="Search jobs or companies..." 
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 bg-gray-900/50 border-gray-800 text-white placeholder:text-gray-500"
            />
          </div>
          
          <Select value={statusFilter} onValueChange={setStatusFilter}>
            <SelectTrigger className="w-[180px] bg-gray-900/50 border-gray-800 text-white">
              <div className="flex items-center gap-2">
                <Filter className="w-4 h-4" />
                <SelectValue placeholder="Status" />
              </div>
            </SelectTrigger>
            <SelectContent className="bg-gray-900 border-gray-800 text-white">
              <SelectItem value="all">All Statuses</SelectItem>
              <SelectItem value="applied">Applied</SelectItem>
              <SelectItem value="interviewing">Interviewing</SelectItem>
              <SelectItem value="offer">Offer</SelectItem>
              <SelectItem value="rejected">Rejected</SelectItem>
              <SelectItem value="ghosted">Ghosted</SelectItem>
            </SelectContent>
          </Select>

          <Select value={companyFilter} onValueChange={setCompanyFilter}>
            <SelectTrigger className="w-[180px] bg-gray-900/50 border-gray-800 text-white">
              <div className="flex items-center gap-2">
                <Building2 className="w-4 h-4" />
                <SelectValue placeholder="Company" />
              </div>
            </SelectTrigger>
            <SelectContent className="bg-gray-900 border-gray-800 text-white">
              <SelectItem value="all">All Companies</SelectItem>
              {getCompanies().map(c => (
                <SelectItem key={c} value={c}>{c}</SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        {/* Applications Table */}
        <Card className="bg-gray-900/40 backdrop-blur-xl border-gray-800 overflow-hidden">
          <CardContent className="p-0">
            {loading ? (
              <div className="flex justify-center py-20"><Loader2 className="w-8 h-8 text-blue-500 animate-spin" /></div>
            ) : filteredApps.length === 0 ? (
              <div className="text-center py-20 text-gray-500">
                <Briefcase className="w-16 h-16 mx-auto mb-4 opacity-20" />
                <h3 className="text-xl font-bold text-gray-300">No applications found</h3>
                <p className="mb-6">Try adjusting your filters or apply to new jobs.</p>
                <Link href="/jobs">
                  <Button variant="outline" className="border-gray-700 text-gray-300 hover:text-white hover:bg-gray-800">
                    Browse Jobs
                  </Button>
                </Link>
              </div>
            ) : (
              <Table>
                <TableHeader className="bg-gray-900/50">
                  <TableRow className="border-gray-800 hover:bg-transparent">
                    <TableHead className="text-gray-400">Position</TableHead>
                    <TableHead className="text-gray-400">Company</TableHead>
                    <TableHead className="text-gray-400">Status</TableHead>
                    <TableHead className="text-gray-400">Applied</TableHead>
                    <TableHead className="text-gray-400">Match</TableHead>
                    <TableHead className="text-right text-gray-400">Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {filteredApps.map((app) => (
                    <TableRow key={app.id} className="border-gray-800 hover:bg-gray-800/30 transition-colors">
                      <TableCell>
                        <div className="font-semibold text-white">{app.jobTitle}</div>
                        {app.location && <div className="text-xs text-gray-500 flex items-center gap-1"><MapPin className="w-3 h-3"/> {app.location}</div>}
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2 text-gray-300">
                          <Building2 className="w-4 h-4 text-gray-500" />
                          {app.company}
                        </div>
                      </TableCell>
                      <TableCell>
                        {getStatusBadge(app.status)}
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2 text-sm text-gray-400">
                          <Calendar className="w-4 h-4 text-gray-600" />
                          {app.appliedAt ? formatDistanceToNow(app.appliedAt.toDate ? app.appliedAt.toDate() : new Date(), { addSuffix: true }) : 'N/A'}
                        </div>
                      </TableCell>
                      <TableCell>
                        {app.matchScore ? (
                          <span className={`text-sm font-bold ${app.matchScore >= 90 ? 'text-green-400' : 'text-blue-400'}`}>
                            {app.matchScore}%
                          </span>
                        ) : <span className="text-gray-600">-</span>}
                      </TableCell>
                      <TableCell className="text-right">
                        <div className="flex items-center justify-end gap-2">
                          {app.jobUrl && (
                            <Link href={app.jobUrl} target="_blank">
                              <Button size="icon" variant="ghost" className="h-8 w-8 text-gray-400 hover:text-white hover:bg-gray-800">
                                <ArrowUpRight className="w-4 h-4" />
                              </Button>
                            </Link>
                          )}
                          
                          <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                              <Button size="icon" variant="ghost" className="h-8 w-8 text-gray-400 hover:text-white hover:bg-gray-800">
                                <MoreHorizontal className="w-4 h-4" />
                              </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end" className="bg-gray-900 border-gray-800 text-gray-200">
                              <DropdownMenuItem onClick={() => handleStatusUpdate(app.id, 'interviewing')} className="hover:bg-gray-800 focus:bg-gray-800 cursor-pointer">
                                Mark as Interviewing
                              </DropdownMenuItem>
                              <DropdownMenuItem onClick={() => handleStatusUpdate(app.id, 'offer')} className="hover:bg-gray-800 focus:bg-gray-800 cursor-pointer">
                                Mark as Offer
                              </DropdownMenuItem>
                              <DropdownMenuItem onClick={() => handleStatusUpdate(app.id, 'rejected')} className="hover:bg-gray-800 focus:bg-gray-800 cursor-pointer text-red-400 hover:text-red-300">
                                Mark as Rejected
                              </DropdownMenuItem>
                              <DropdownMenuItem onClick={() => handleDelete(app.id)} className="hover:bg-red-900/20 focus:bg-red-900/20 cursor-pointer text-red-500 hover:text-red-400">
                                <Trash2 className="w-4 h-4 mr-2" /> Delete
                              </DropdownMenuItem>
                            </DropdownMenuContent>
                          </DropdownMenu>
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
===== ./src/app/assistant/page.tsx =====
"use client";

import React, { useState, useRef, useEffect } from 'react';
import { Send, Bot, User, Sparkles, AlertCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
}

export default function AssistantPage() {
  const [messages, setMessages] = useState<Message[]>([
    {
      id: '1',
      role: 'assistant',
      content: "Hello! I'm your AI Career Coach. I can help you write cover letters, optimize your resume, or practice for interviews. What shall we work on today?"
    }
  ]);
  const [input, setInput] = useState('');
  const [loading, setLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const handleSend = async () => {
    if (!input.trim()) return;

    // 1. Add User Message immediately
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: input
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setLoading(true);

    try {
      // 2. Prepare message history for context (limit to last 10 to save tokens)
      const apiMessages = [...messages, userMessage].slice(-10).map(m => ({
        role: m.role,
        content: m.content
      }));

      // 3. Call our server API route
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ messages: apiMessages }),
      });

      if (!response.ok) throw new Error('Failed to get response');

      const data = await response.json();

      // 4. Add AI Response
      const aiResponse: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: data.reply
      };
      setMessages(prev => [...prev, aiResponse]);

    } catch (error) {
      console.error("Error sending message:", error);
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: "I'm sorry, I encountered an error connecting to the AI. Please verify your API key is set in .env.local and try again."
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-[calc(100vh-4rem)] bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30">
      {/* --- Background Gradients (Premium Look) --- */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 right-1/4 w-96 h-96 bg-purple-500/20 rounded-full blur-[120px] animate-pulse" />
        <div className="absolute bottom-0 left-1/4 w-96 h-96 bg-blue-500/20 rounded-full blur-[120px] animate-pulse animation-delay-2000" />
        <div className="absolute inset-0 opacity-10"
          style={{
            backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`,
            backgroundSize: '40px 40px'
          }}
        />
      </div>

      <div className="flex-1 flex flex-col max-w-5xl mx-auto w-full p-4 h-full">
        {/* Header */}
        <div className="mb-6 text-center shrink-0">
          <h1 className="text-3xl font-bold flex items-center justify-center gap-2 mb-1">
            <Sparkles className="w-6 h-6 text-purple-400" />
            <span className="bg-gradient-to-r from-white via-purple-200 to-blue-300 bg-clip-text text-transparent">
              AI Career Assistant
            </span>
          </h1>
          <p className="text-gray-400 text-sm">Powered by DeepSeek AI</p>
        </div>

        {/* Chat Window */}
        <div className="flex-1 flex flex-col overflow-hidden bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl shadow-2xl relative">
          
          {/* Messages Area */}
          <div className="flex-1 overflow-y-auto p-4 md:p-6 space-y-6 scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent">
            {messages.map((message) => (
              <div
                key={message.id}
                className={`flex items-start gap-4 ${
                  message.role === 'user' ? 'flex-row-reverse' : ''
                }`}
              >
                {/* Avatar */}
                <div className={`w-10 h-10 rounded-full flex items-center justify-center shrink-0 shadow-lg ${
                  message.role === 'assistant' 
                    ? 'bg-gradient-to-br from-purple-600 to-blue-600 text-white' 
                    : 'bg-gray-700 text-gray-300'
                }`}>
                  {message.role === 'assistant' ? <Bot className="w-6 h-6" /> : <User className="w-6 h-6" />}
                </div>

                {/* Bubble */}
                <div className={`rounded-2xl p-5 max-w-[85%] shadow-md text-sm md:text-base leading-relaxed ${
                  message.role === 'user'
                    ? 'bg-blue-600 text-white rounded-tr-none'
                    : 'bg-gray-800/80 border border-gray-700 text-gray-100 rounded-tl-none'
                }`}>
                  <p className="whitespace-pre-wrap">
                    {message.content}
                  </p>
                </div>
              </div>
            ))}
            
            {loading && (
              <div className="flex items-center gap-4">
                <div className="w-10 h-10 rounded-full bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center text-white shrink-0 shadow-lg">
                  <Bot className="w-6 h-6" />
                </div>
                <div className="bg-gray-800/80 px-5 py-4 rounded-2xl rounded-tl-none border border-gray-700 shadow-md">
                  <div className="flex gap-1.5">
                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                  </div>
                </div>
              </div>
            )}
            <div ref={messagesEndRef} />
          </div>

          {/* Input Area */}
          <div className="p-4 bg-gray-900/80 border-t border-gray-800 backdrop-blur-md">
            <form 
              onSubmit={(e) => { e.preventDefault(); handleSend(); }}
              className="flex gap-3 relative max-w-4xl mx-auto"
            >
              <Input
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder="Ask for a cover letter, interview tips, or resume advice..."
                className="pr-14 py-6 text-base bg-gray-800/50 border-gray-700 text-white placeholder-gray-500 focus-visible:ring-blue-500/50 rounded-2xl shadow-inner"
                disabled={loading}
              />
              <Button 
                type="submit" 
                disabled={!input.trim() || loading}
                className="absolute right-2 top-2 bottom-2 bg-blue-600 hover:bg-blue-500 text-white rounded-xl w-10 h-10 p-0 shadow-lg transition-all hover:scale-105"
              >
                <Send className="w-5 h-5" />
              </Button>
            </form>
          </div>
        </div>
      </div>
    </div>
  );
}
===== ./src/app/auth/signin/page.tsx =====
'use client';

import React, { useState } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { useRouter } from 'next/navigation';
import AuthPages from '@/components/auth_ui'; // Assuming your UI artifact is saved here

export default function SignInPage() {
  const { signIn, signInWithGoogle } = useAuth();
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // Local state for the form inputs
  const [formData, setFormData] = useState({
    email: '',
    password: '',
  });

  const handleSubmit = async (e?: React.FormEvent) => {
    if (e) e.preventDefault();
    setError('');
    setSuccess('');
    setLoading(true);

    try {
      await signIn(formData.email, formData.password);
      setSuccess('Signed in successfully! Redirecting...');
      // Small delay to show the success message before redirecting
      setTimeout(() => router.push('/dashboard'), 1000);
    } catch (err: any) {
      setError(err.message || 'Failed to sign in. Please check your credentials.');
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleSignIn = async () => {
    setError('');
    setLoading(true);
    try {
      await signInWithGoogle();
      setSuccess('Signed in with Google! Redirecting...');
      setTimeout(() => router.push('/dashboard'), 1000);
    } catch (err: any) {
      setError(err.message || 'Google sign-in failed.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <AuthPages 
      mode="signin"
      loading={loading}
      error={error}
      success={success}
      formData={formData}
      setFormData={setFormData}
      onSubmit={handleSubmit}
      onGoogleSignIn={handleGoogleSignIn}
    />
  );
}
===== ./src/app/auth/signup/page.tsx =====
'use client';

import React, { useState } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { useRouter } from 'next/navigation';
import AuthPages from '@/components/auth_ui';

export default function SignUpPage() {
  const { signUp, signInWithGoogle } = useAuth();
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // Local state for the signup form
  const [formData, setFormData] = useState({
    name: '', // Required for signup to set the display name
    email: '',
    password: '',
  });

  const handleSubmit = async (e?: React.FormEvent) => {
    if (e) e.preventDefault();
    setError('');
    setSuccess('');
    
    // Simple front-end validation
    if (formData.password.length < 6) {
      setError('Password must be at least 6 characters.');
      return;
    }

    setLoading(true);

    try {
      // AuthContext handles updateProfile and Firestore doc creation
      await signUp(formData.email, formData.password, formData.name);
      
      setSuccess('Account created! Redirecting to preferences setup...');
      // Redirect to preferences setup after a short delay
      setTimeout(() => router.push('/settings/preferences'), 1500);
    } catch (err: any) {
      setError(err.message || 'Failed to create account. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleSignIn = async () => {
    setError('');
    setLoading(true);
    try {
      await signInWithGoogle();
      setSuccess('Signed in with Google! Redirecting...');
      setTimeout(() => router.push('/dashboard'), 1000);
    } catch (err: any) {
      setError(err.message || 'Google sign-in failed.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <AuthPages 
      mode="signup"
      loading={loading}
      error={error}
      success={success}
      formData={formData}
      setFormData={setFormData}
      onSubmit={handleSubmit}
      onGoogleSignIn={handleGoogleSignIn}
    />
  );
}
===== ./src/app/compare/page.tsx =====
"use client"; 

import { useState, useEffect, Suspense } from 'react';
import { useSearchParams } from 'next/navigation';
import { collection, query, where, getDocs, documentId } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { 
  Building2, MapPin, DollarSign, Target, TrendingUp, 
  Calendar, Zap, ArrowRight, X, Check, LucideIcon 
} from 'lucide-react';
import Link from 'next/link';

// TypeScript Interfaces
interface Job {
  id: string;
  title: string;
  company: string;
  location: string;
  salary?: string;
  seniority?: string;
  matchScore?: number;
  postedAt?: any;
  tags?: string[];
  [key: string]: any;
}

interface Metric {
  key: string;
  label: string;
  icon: LucideIcon;
  format: (val: any) => string;
  higher_better?: boolean;
  lower_better?: boolean;
  highlight_tiers?: boolean;
  highlight_remote?: boolean;
}

// --- 1. Inner Component (Contains the Logic) ---
function CompareContent() {
  const searchParams = useSearchParams();
  const jobIds = searchParams.get('jobs')?.split(',') || [];
  
  const [jobs, setJobs] = useState<Job[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchJobs() {
      if (jobIds.length === 0) {
        setLoading(false);
        return;
      }
      
      try {
        const jobsRef = collection(db, 'jobs');
        const q = query(jobsRef, where(documentId(), 'in', jobIds.slice(0, 3)));
        const snapshot = await getDocs(q);
        
        // FIX: Explicitly cast the result to Job[]
        const jobsData = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        })) as Job[];
        
        setJobs(jobsData);
      } catch (error) {
        console.error('Error fetching jobs:', error);
      } finally {
        setLoading(false);
      }
    }
    
    fetchJobs();
  }, [jobIds]); // Removed unnecessary dependencies to prevent re-loops

  if (loading) {
    return (
      <div className="min-h-screen bg-[#0A0A0A] text-white flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-400">Loading comparison...</p>
        </div>
      </div>
    );
  }

  if (jobs.length === 0) {
    return (
      <div className="min-h-screen bg-[#0A0A0A] text-white flex items-center justify-center">
        <div className="text-center">
          <Target className="w-16 h-16 text-gray-600 mx-auto mb-4" />
          <h2 className="text-2xl font-bold mb-2">No Jobs to Compare</h2>
          <p className="text-gray-400 mb-6">Select at least 2 jobs from the jobs page</p>
          <Link href="/jobs">
            <button className="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-xl font-semibold transition-colors">
              Browse Jobs
            </button>
          </Link>
        </div>
      </div>
    );
  }

  const comparisonMetrics: Metric[] = [
    {
      key: 'matchScore',
      label: 'Match Score',
      icon: Target,
      format: (val: any) => `${val}%`,
      higher_better: true
    },
    {
      key: 'company',
      label: 'Company',
      icon: Building2,
      format: (val: any) => val,
      highlight_tiers: true
    },
    {
      key: 'salary',
      label: 'Salary',
      icon: DollarSign,
      format: (val: any) => val || 'Not specified',
      higher_better: true
    },
    {
      key: 'location',
      label: 'Location',
      icon: MapPin,
      format: (val: any) => val,
      highlight_remote: true
    },
    {
      key: 'seniority',
      label: 'Seniority',
      icon: TrendingUp,
      format: (val: any) => val?.charAt(0).toUpperCase() + val?.slice(1) || 'Mid',
    },
    {
      key: 'postedAt',
      label: 'Posted',
      icon: Calendar,
      format: (val: any) => {
        if (!val) return 'Recently';
        const date = val.toDate ? val.toDate() : new Date(val);
        const days = Math.floor((new Date().getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
        if (days === 0) return 'Today';
        if (days === 1) return 'Yesterday';
        return `${days} days ago`;
      },
      lower_better: true
    },
  ];

  const getBestValue = (metric: Metric, jobs: Job[]) => {
    if (metric.key === 'matchScore') {
      return Math.max(...jobs.map(j => j[metric.key] || 0));
    }
    if (metric.key === 'postedAt') {
      const dates = jobs.map(j => {
        const val = j[metric.key];
        if (!val) return new Date();
        return val.toDate ? val.toDate() : new Date(val);
      });
      return Math.max(...dates.map(d => d.getTime()));
    }
    return null;
  };

  const isHighlighted = (job: Job, metric: Metric) => {
    if (metric.higher_better) {
      const best = getBestValue(metric, jobs);
      return job[metric.key] === best;
    }
    if (metric.lower_better) {
      const jobDate = job[metric.key]?.toDate ? job[metric.key].toDate() : new Date(job[metric.key] || new Date());
      const best = getBestValue(metric, jobs);
      return jobDate.getTime() === best;
    }
    if (metric.highlight_remote) {
      return job[metric.key]?.toLowerCase().includes('remote');
    }
    if (metric.highlight_tiers) {
      const tierS = ['OpenAI', 'Anthropic', 'Google', 'Meta', 'Stripe'];
      return tierS.includes(job.company);
    }
    return false;
  };

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white p-8">
      {/* Header */}
      <div className="max-w-7xl mx-auto mb-8">
        <div className="flex items-center justify-between mb-4">
          <div>
            <h1 className="text-4xl font-black mb-2">Compare Jobs</h1>
            <p className="text-gray-400">Side-by-side comparison of {jobs.length} opportunities</p>
          </div>
          <Link href="/jobs">
            <button className="px-4 py-2 bg-gray-800 hover:bg-gray-700 rounded-xl text-sm font-medium transition-colors flex items-center gap-2">
              <X className="w-4 h-4" /> Close
            </button>
          </Link>
        </div>
      </div>

      {/* Comparison Grid */}
      <div className="max-w-7xl mx-auto">
        <div className={`grid gap-6 ${jobs.length === 2 ? 'grid-cols-2' : 'grid-cols-3'}`}>
          {jobs.map((job, idx) => (
            <div key={job.id} className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 space-y-6">
              {/* Job Header */}
              <div className="border-b border-gray-800 pb-4">
                <h2 className="text-2xl font-bold mb-2">{job.title}</h2>
                <p className="text-blue-400 font-semibold">{job.company}</p>
              </div>

              {/* Metrics */}
              <div className="space-y-4">
                {comparisonMetrics.map(metric => {
                  const Icon = metric.icon;
                  const value = metric.format(job[metric.key]);
                  const highlighted = isHighlighted(job, metric);
                  
                  return (
                    <div 
                      key={metric.key}
                      className={`p-4 rounded-xl border transition-all ${
                        highlighted 
                          ? 'bg-green-500/10 border-green-500/30' 
                          : 'bg-gray-800/30 border-gray-700/50'
                      }`}
                    >
                      <div className="flex items-center gap-2 mb-2">
                        <Icon className={`w-4 h-4 ${highlighted ? 'text-green-400' : 'text-gray-500'}`} />
                        <span className="text-xs text-gray-400 uppercase tracking-wider">{metric.label}</span>
                        {highlighted && <Check className="w-4 h-4 text-green-400 ml-auto" />}
                      </div>
                      <div className={`text-lg font-semibold ${highlighted ? 'text-green-300' : 'text-white'}`}>
                        {value}
                      </div>
                    </div>
                  );
                })}
              </div>

              {/* Tags */}
              <div className="border-t border-gray-800 pt-4">
                <p className="text-xs text-gray-500 uppercase mb-2">Skills Match</p>
                <div className="flex flex-wrap gap-2">
                  {job.tags?.slice(0, 4).map((tag, i) => (
                    <span 
                      key={i}
                      className="px-2 py-1 bg-blue-500/10 text-blue-400 border border-blue-500/20 rounded-md text-xs"
                    >
                      {tag}
                    </span>
                  ))}
                </div>
              </div>

              {/* Action Button */}
              <Link href={`/jobs/${job.id}`} className="block">
                <button className="w-full px-4 py-3 bg-white text-black hover:bg-gray-200 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 group">
                  View Job 
                  <ArrowRight className="w-4 h-4 group-hover:translate-x-1 transition-transform" />
                </button>
              </Link>
            </div>
          ))}
        </div>

        {/* Winner Badge */}
        {jobs.length >= 2 && (
          <div className="mt-12 p-8 bg-gradient-to-r from-blue-500/10 to-purple-500/10 border border-blue-500/20 rounded-3xl">
            <div className="flex items-center gap-4">
              <div className="w-16 h-16 bg-gradient-to-br from-yellow-400 to-yellow-600 rounded-full flex items-center justify-center">
                <Zap className="w-8 h-8 text-white" />
              </div>
              <div>
                <h3 className="text-2xl font-bold mb-1">Best Overall Match</h3>
                <p className="text-gray-400">
                  Based on match score and salary: <span className="text-white font-semibold">{jobs[0].title} at {jobs[0].company}</span>
                </p>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// --- 2. Main Page Component (Wraps in Suspense) ---
export default function JobComparePage() {
  return (
    <Suspense fallback={
      <div className="min-h-screen bg-[#0A0A0A] text-white flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-400">Loading...</p>
        </div>
      </div>
    }>
      <CompareContent />
    </Suspense>
  );
}
===== ./src/app/dashboard/page.tsx =====
"use client";

import AnalyticsDashboard from '@/components/AnalyticsDashboard';
import { useEffect, useState, useMemo, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { 
  collection, 
  query, 
  where, 
  orderBy, 
  limit, 
  getDocs, 
  getCountFromServer, 
  documentId,
  writeBatch,
  doc,
  getDoc 
} from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { useAuth } from '@/contexts/AuthContext';
import { 
  Target, 
  Briefcase, 
  TrendingUp, 
  Sparkles, 
  Building2, 
  MapPin, 
  Calendar, 
  Zap, 
  Loader2, 
  ArrowRight, 
  AlertCircle, 
  Bug, 
  RefreshCw 
} from 'lucide-react';
import Link from 'next/link';
import { formatDistanceToNow } from 'date-fns';

// --- Interfaces ---
interface JobMatch {
  id: string;
  jobId: string;
  matchScore: number;
  matchReasons: string[];
  job: {
    title: string;
    company: string;
    location: string;
    url: string;
    postedAt: any;
    salary?: string;
  };
  notifiedAt: any;
  viewed: boolean;
}

interface UserStats {
  jobsFound: number;
  jobsApplied: number;
  interviews: number;
}

export default function DashboardPage() {
  // --- Hooks & State ---
  const { user, loading } = useAuth();
  const router = useRouter();
  
  // Real Data State
  const [jobMatches, setJobMatches] = useState<JobMatch[]>([]);
  const [excludedKeywords, setExcludedKeywords] = useState<string[]>([]);
  const [stats, setStats] = useState<UserStats>({
    jobsFound: 0,
    jobsApplied: 0,
    interviews: 0,
  });
  
  const [loadingData, setLoadingData] = useState(true);
  const [showingGlobalJobs, setShowingGlobalJobs] = useState(false);
  const [isNewUser, setIsNewUser] = useState(false);
  const [isResetting, setIsResetting] = useState(false); 
  
  const hasTriggeredScraper = useRef(false);

  // UI State
  const [sortBy, setSortBy] = useState<'match' | 'latest'>('match');
  const [searchQuery, setSearchQuery] = useState('');

  // --- Auth Protection ---
  useEffect(() => {
    if (!loading && !user) {
      router.replace('/auth/signin');
    }
  }, [user, loading, router]);

  // --- Helper: Trigger Scraper ---
  async function triggerScraperForNewUser(email: string | null) {
    if (hasTriggeredScraper.current) return;
    try {
      console.log('ðŸŽ¯ Triggering scraper for new user:', email);
      hasTriggeredScraper.current = true;
      
      const response = await fetch('/api/trigger-scraper', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userEmail: email })
      });
      
      if (response.ok) {
        console.log('âœ… Scraper triggered successfully');
      } else {
        console.error('âŒ Failed to trigger scraper:', await response.text());
      }
    } catch (error) {
      console.error('âŒ Error triggering scraper:', error);
    }
  }

  // --- RESET VIEWED STATUS ---
  const handleResetViews = async () => {
    if (!user || jobMatches.length === 0) return;
    setIsResetting(true);
    try {
      console.log("ðŸ”„ Resetting 'viewed' status for displayed jobs...");
      const batch = writeBatch(db);
      
      jobMatches.forEach(match => {
        if (!showingGlobalJobs) {
            const ref = doc(db, 'user_job_matches', match.id);
            batch.update(ref, { viewed: false });
        }
      });

      await batch.commit();
      console.log("âœ… Reset complete. Reloading...");
      window.location.reload();
    } catch (error) {
      console.error("âŒ Error resetting views:", error);
      setIsResetting(false);
    }
  };

  // --- Data Loading ---
  useEffect(() => {
    if (!user) return;
    const userId = user.uid;

    async function fetchGlobalJobs() {
      try {
        console.log('ðŸ“Š No user matches found, showing global jobs');
        setShowingGlobalJobs(true);
        
        const jobsRef = collection(db, 'jobs');
        const globalQuery = query(
          jobsRef,
          orderBy('postedAt', 'desc'),
          limit(20)
        );
        
        const globalJobsSnapshot = await getDocs(globalQuery);
        
        const globalJobs = globalJobsSnapshot.docs.map(doc => {
          const data = doc.data();
          return {
            id: doc.id,
            jobId: doc.id,
            matchScore: 75,
            matchReasons: ['Recently posted', 'Top company'],
            notifiedAt: data.postedAt, 
            viewed: false,
            job: {
              title: data.title,
              company: data.company,
              location: data.location,
              url: data.url,
              postedAt: data.postedAt,
              salary: data.salary
            }
          } as JobMatch;
        });
        
        setJobMatches(globalJobs);
      } catch (error) {
        console.error('Error fetching global jobs:', error);
      }
    }

    async function fetchData() {
      setLoadingData(true);

      try {
        const userProfileRef = doc(db, 'users', userId);
        const userProfileSnap = await getDoc(userProfileRef);
        const userData = userProfileSnap.exists() ? userProfileSnap.data() : null;
        
        const hasPreferences = userData?.jobTitles && userData.jobTitles.length > 0;

        if (userData?.excludedKeywords && Array.isArray(userData.excludedKeywords)) {
           setExcludedKeywords(userData.excludedKeywords);
        } else if (userData?.negativeFilters && Array.isArray(userData.negativeFilters)) {
           setExcludedKeywords(userData.negativeFilters);
        }

        const [matchesCount, appsCount, interviewsCount] = await Promise.all([
          getCountFromServer(
              query(collection(db, 'user_job_matches'), where('userId', '==', userId))
          ),
          getCountFromServer(
              query(collection(db, 'applications'), where('userId', '==', userId))
          ),
          getCountFromServer(
              query(
              collection(db, 'applications'),
              where('userId', '==', userId),
              where('status', '==', 'interview')
              )
          )
        ]);

        const matchCount = matchesCount.data().count;

        setStats({
            jobsFound: matchCount,
            jobsApplied: appsCount.data().count,
            interviews: interviewsCount.data().count
        });

        if (matchCount === 0) {
          if (hasPreferences) {
            console.log('â³ Preferences found, waiting for AI matches...');
            setJobMatches([]); 
            setShowingGlobalJobs(false); 
            triggerScraperForNewUser(user?.email || null);
          } else {
            console.log('ðŸ†• No preferences found, showing global fallback');
            setIsNewUser(true);
            triggerScraperForNewUser(user?.email || null);
            await fetchGlobalJobs();
          }
          setLoadingData(false);
          return;
        }

        const matchesRef = collection(db, 'user_job_matches');
        const q = query(
          matchesRef,
          where('userId', '==', userId),
          orderBy('notifiedAt', 'desc'), 
          limit(50) 
        );

        const matchesSnapshot = await getDocs(q);
        
        if (matchesSnapshot.empty) {
            if (!hasPreferences) await fetchGlobalJobs();
            setLoadingData(false);
            return;
        }

        const jobIds = matchesSnapshot.docs
          .map(doc => doc.data().jobId)
          .filter(Boolean);

        if (jobIds.length === 0) {
           if (!hasPreferences) await fetchGlobalJobs();
           setLoadingData(false);
           return;
        }

        const chunks = [];
        for (let i = 0; i < jobIds.length; i += 10) {
            chunks.push(jobIds.slice(i, i + 10));
        }

        const jobsPromises = chunks.map(chunk => 
            getDocs(query(collection(db, 'jobs'), where(documentId(), 'in', chunk)))
        );
        
        const jobsSnapshots = await Promise.all(jobsPromises);
        
        const jobsMap = new Map();
        jobsSnapshots.forEach(snap => {
            snap.docs.forEach(doc => {
                jobsMap.set(doc.id, doc.data());
            });
        });

        const matches = matchesSnapshot.docs.map(doc => {
          const data = doc.data();
          const job = jobsMap.get(data.jobId);
          if (!job) return null;
          return { 
            id: doc.id, 
            jobId: data.jobId,
            matchScore: data.matchScore || 0,
            matchReasons: data.matchReasons || [],
            notifiedAt: data.notifiedAt,
            viewed: data.viewed || false,
            job 
          } as JobMatch;
        }).filter(match => match !== null) as JobMatch[];

        setJobMatches(matches);
        setShowingGlobalJobs(false);

      } catch (error) {
        console.error('Error fetching dashboard data:', error);
      } finally {
        setLoadingData(false);
      }
    }

    fetchData();
  }, [user]);

  // --- Poll for personalized matches ---
  useEffect(() => {
    if (!user) return;
    const shouldPoll = showingGlobalJobs || (jobMatches.length === 0 && !loadingData);

    if (!shouldPoll) return;
    
    const pollInterval = setInterval(async () => {
      try {
        const matchesRef = collection(db, 'user_job_matches');
        const q = query(
          matchesRef,
          where('userId', '==', user.uid),
          limit(1)
        );
        
        const snapshot = await getDocs(q);
        
        if (!snapshot.empty) {
          console.log('âœ¨ Personalized matches are ready! Reloading...');
          window.location.reload();
          clearInterval(pollInterval);
        }
      } catch (error) {
        console.error('Error polling for matches:', error);
      }
    }, 10000); 
    
    const timeout = setTimeout(() => {
      clearInterval(pollInterval);
    }, 300000); 
    
    return () => {
      clearInterval(pollInterval);
      clearTimeout(timeout);
    };
  }, [showingGlobalJobs, jobMatches.length, loadingData, user]);

  // --- Filtering & Sorting Logic ---
  const filteredAndSortedMatches = useMemo(() => {
    // 1. Filter Logic (Exclusions + Search)
    let results = jobMatches.filter(match => {
      // Exclusions
      if (excludedKeywords.length > 0) {
        const title = match.job.title.toLowerCase();
        const isExcluded = excludedKeywords.some(keyword => title.includes(keyword.toLowerCase()));
        if (isExcluded) return false;
      }

      // Search
      const queryStr = searchQuery.toLowerCase();
      if (!queryStr) return true;
      
      const matchesSearch = 
        match.job.title.toLowerCase().includes(queryStr) || 
        match.job.company.toLowerCase().includes(queryStr) ||
        (match.matchReasons?.some?.(r => r.toLowerCase().includes(queryStr)) ?? false);

      return matchesSearch;
    });

    // 2. Sorting Logic (Best Match vs Latest)
    return results.sort((a, b) => {
        if (sortBy === 'match') {
            // Sort by Match Score (High to Low)
            return (b.matchScore || 0) - (a.matchScore || 0);
        } else {
            // Sort by Date (Newest to Oldest)
            const getSafeDate = (d: any) => {
                if (!d) return 0;
                if (d.toDate) return d.toDate().getTime();
                if (d.seconds) return d.seconds * 1000;
                return new Date(d).getTime();
            };
            return getSafeDate(b.notifiedAt) - getSafeDate(a.notifiedAt);
        }
    });

  }, [sortBy, searchQuery, jobMatches, excludedKeywords]);

  const getTier = (score: number) => {
    if (score >= 95) return 'S';
    if (score >= 85) return 'A';
    if (score >= 75) return 'B';
    return 'C';
  };

  const formatJobDate = (postedAt: any) => {
    if (!postedAt) return 'Recently';
    try {
      let date;
      if (postedAt.toDate) date = postedAt.toDate();
      else if (postedAt.seconds) date = new Date(postedAt.seconds * 1000);
      else date = new Date(postedAt);
      return formatDistanceToNow(date, { addSuffix: true });
    } catch (error) {
      return 'Recently';
    }
  };

  // --- Render ---
  if (loading || (!user && !loading)) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-[#050505]">
        <Loader2 className="h-12 w-12 text-blue-500 animate-spin" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#050505] text-white font-sans selection:bg-blue-500/30 pb-20">
      
      {/* Background Decor (Neo-Glass Effect) */}
      <div className="fixed inset-0 -z-10 overflow-hidden pointer-events-none">
        <div className="absolute top-[-10%] left-[-10%] w-[500px] h-[500px] bg-blue-600/10 rounded-full blur-[120px]" />
        <div className="absolute top-[20%] right-[-10%] w-[400px] h-[400px] bg-purple-600/10 rounded-full blur-[100px]" />
      </div>

      <div className="max-w-7xl mx-auto p-6 space-y-10">
        
        {/* 1. HEADER SECTION */}
        <div className="flex flex-col md:flex-row md:items-end justify-between gap-6 pt-6">
          <div className="space-y-1">
            <div className="flex items-center gap-2 text-emerald-400 mb-2">
                <span className="relative flex h-2 w-2">
                  <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-emerald-400 opacity-75"></span>
                  <span className="relative inline-flex rounded-full h-2 w-2 bg-emerald-500"></span>
                </span>
                <span className="text-xs font-bold tracking-wider">SYSTEM ACTIVE</span>
            </div>
            <h1 className="text-5xl font-black tracking-tighter text-white">
              Hello, <span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-purple-400 to-pink-400 animate-gradient-x">{user?.displayName?.split(' ')[0] || 'Hunter'}</span>
            </h1>
            <p className="text-gray-400 text-lg max-w-xl">
              Your AI agent has scanned <span className="text-white font-bold">8,000+</span> jobs today. Here is your briefing.
            </p>
          </div>
          
          <Link href="/pricing">
            <button className="group relative px-6 py-3 bg-white text-black rounded-xl font-bold hover:scale-105 transition-transform duration-300 shadow-[0_0_20px_rgba(255,255,255,0.3)]">
              <span className="relative flex items-center justify-center gap-2">
                <Sparkles className="w-4 h-4 text-purple-600" />
                Upgrade Plan
              </span>
            </button>
          </Link>
        </div>

        {/* New User Banner */}
        {showingGlobalJobs && isNewUser && (
          <div className="bg-gradient-to-r from-blue-500/10 to-purple-500/10 border border-blue-500/30 rounded-2xl p-6">
            <div className="flex items-start gap-4">
              <div className="p-3 bg-blue-500/20 rounded-xl">
                <Sparkles className="w-6 h-6 text-blue-400" />
              </div>
              <div className="flex-1">
                <h3 className="text-xl font-bold mb-2 flex items-center gap-2">
                  ðŸŽ¯ Setting up your feed...
                  <Loader2 className="w-5 h-5 animate-spin text-blue-400" />
                </h3>
                <p className="text-gray-300 mb-2">
                  We are scanning jobs for you. In the meantime, check out these trending roles!
                </p>
              </div>
            </div>
          </div>
        )}

        {/* 2. STATS GRID (NEO-GLASS) */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          
          {/* Matches Card */}
          <Link href="/jobs" className="group">
            <div className="relative overflow-hidden bg-[#0A0A0A] rounded-[24px] p-1 h-full hover:-translate-y-1 transition-transform duration-300">
              <div className="absolute inset-0 bg-gradient-to-br from-blue-500/20 via-transparent to-transparent opacity-50 group-hover:opacity-100 transition-opacity" />
              <div className="relative h-full bg-[#0F0F10] rounded-[20px] p-6 border border-white/5 group-hover:border-blue-500/30 transition-colors">
                <div className="flex justify-between items-start mb-8">
                    <div className="p-3 bg-blue-500/10 rounded-2xl text-blue-400">
                        <Target className="w-6 h-6" />
                    </div>
                    <span className="bg-blue-500/10 text-blue-400 text-xs font-bold px-2 py-1 rounded-lg">LIVE</span>
                </div>
                <div>
                    <div className="text-5xl font-black text-white mb-1">{stats.jobsFound}</div>
                    <div className="text-gray-400 font-medium">New Matches</div>
                </div>
              </div>
            </div>
          </Link>

          {/* Applications Card */}
          <Link href="/applications" className="group">
            <div className="relative overflow-hidden bg-[#0A0A0A] rounded-[24px] p-1 h-full hover:-translate-y-1 transition-transform duration-300">
              <div className="absolute inset-0 bg-gradient-to-br from-purple-500/20 via-transparent to-transparent opacity-50 group-hover:opacity-100 transition-opacity" />
              <div className="relative h-full bg-[#0F0F10] rounded-[20px] p-6 border border-white/5 group-hover:border-purple-500/30 transition-colors">
                <div className="flex justify-between items-start mb-8">
                    <div className="p-3 bg-purple-500/10 rounded-2xl text-purple-400">
                        <Briefcase className="w-6 h-6" />
                    </div>
                </div>
                <div>
                    <div className="text-5xl font-black text-white mb-1">{stats.jobsApplied}</div>
                    <div className="text-gray-400 font-medium">Applications</div>
                </div>
              </div>
            </div>
          </Link>

          {/* Interviews Card */}
          <Link href="/applications?filter=interview" className="group">
            <div className="relative overflow-hidden bg-[#0A0A0A] rounded-[24px] p-1 h-full hover:-translate-y-1 transition-transform duration-300">
              <div className="absolute inset-0 bg-gradient-to-br from-amber-500/20 via-transparent to-transparent opacity-50 group-hover:opacity-100 transition-opacity" />
              <div className="relative h-full bg-[#0F0F10] rounded-[20px] p-6 border border-white/5 group-hover:border-amber-500/30 transition-colors">
                <div className="flex justify-between items-start mb-8">
                    <div className="p-3 bg-amber-500/10 rounded-2xl text-amber-400">
                        <TrendingUp className="w-6 h-6" />
                    </div>
                </div>
                <div>
                    <div className="text-5xl font-black text-white mb-1">{stats.interviews}</div>
                    <div className="text-gray-400 font-medium">Interviews</div>
                </div>
              </div>
            </div>
          </Link>
        </div>

        {/* 3. MARKET INTELLIGENCE */}
        <section>
            <div className="flex items-center gap-3 mb-6">
                <div className="h-8 w-1 bg-blue-500 rounded-full" />
                <h2 className="text-2xl font-bold text-white">Market Intelligence</h2>
            </div>
            <AnalyticsDashboard />
        </section>

        {/* 4. JOB FEED */}
        <section>
            <div className="flex items-center justify-between mb-6">
                <div className="flex items-center gap-3">
                    <div className="h-8 w-1 bg-purple-500 rounded-full" />
                    <h2 className="text-2xl font-bold text-white">
                        {showingGlobalJobs ? 'Trending Opportunities' : 'Your Feed'}
                    </h2>
                </div>

                {/* Fixed Sort Tabs */}
                {!showingGlobalJobs && jobMatches.length > 0 && (
                    <div className="bg-gray-900 p-1 rounded-xl border border-white/10 flex gap-1">
                        <button onClick={() => setSortBy('match')} className={`px-4 py-2 rounded-lg text-sm font-bold transition-all ${sortBy === 'match' ? 'bg-gray-800 text-white shadow-lg' : 'text-gray-500 hover:text-gray-300'}`}>
                            ðŸ”¥ Best Match
                        </button>
                        <button onClick={() => setSortBy('latest')} className={`px-4 py-2 rounded-lg text-sm font-bold transition-all ${sortBy === 'latest' ? 'bg-gray-800 text-white shadow-lg' : 'text-gray-500 hover:text-gray-300'}`}>
                            ðŸ“… Latest
                        </button>
                    </div>
                )}
            </div>

            <div className="space-y-4">
                {/* DEBUGGING AID + RESET BUTTON */}
                {!loadingData && jobMatches.length > 0 && filteredAndSortedMatches.length === 0 && !showingGlobalJobs && (
                  <div className="p-4 bg-gray-800/50 rounded-xl border border-yellow-500/20 flex flex-col sm:flex-row items-center justify-between gap-4">
                    <div className="flex items-center gap-3 text-xs text-yellow-500 font-mono">
                        <Bug className="w-4 h-4 flex-shrink-0" />
                        <span>Debug: Loaded matches, but filters (including exclusions) hid them all.</span>
                    </div>
                    
                    <button 
                      onClick={handleResetViews}
                      disabled={isResetting}
                      className="flex items-center gap-2 px-4 py-2 bg-yellow-500/10 hover:bg-yellow-500/20 text-yellow-500 text-xs font-bold uppercase tracking-wider rounded-lg border border-yellow-500/20 transition-all disabled:opacity-50"
                    >
                      {isResetting ? <Loader2 className="w-3 h-3 animate-spin" /> : <RefreshCw className="w-3 h-3" />}
                      {isResetting ? "Resetting..." : "Reset All to 'New'"}
                    </button>
                  </div>
                )}

                {/* LIST */}
                {loadingData ? (
                    [1,2,3].map(i => <div key={i} className="h-32 bg-gray-900/50 rounded-3xl animate-pulse" />)
                ) : filteredAndSortedMatches.length > 0 ? (
                    <>
                        {filteredAndSortedMatches.slice(0, 5).map(match => (
                            <Link key={match.id} href={`/jobs/${match.jobId}`}>
                                <div className="group relative bg-[#0F0F10] hover:bg-[#141415] rounded-3xl p-6 border border-white/5 hover:border-white/10 transition-all cursor-pointer">
                                    <div className="flex flex-col md:flex-row justify-between gap-6">
                                        <div className="flex items-start gap-4">
                                            <div className="w-12 h-12 bg-white/5 rounded-2xl flex items-center justify-center text-2xl">
                                                {match.job.company.charAt(0)}
                                            </div>
                                            <div>
                                                <h3 className="text-xl font-bold text-white group-hover:text-blue-400 transition-colors mb-1">{match.job.title}</h3>
                                                <div className="flex items-center gap-2 text-sm text-gray-400 mb-3">
                                                    <span className="text-white font-medium">{match.job.company}</span>
                                                    <span>â€¢</span>
                                                    <span>{match.job.location}</span>
                                                    <span>â€¢</span>
                                                    <span>{formatJobDate(match.job.postedAt)}</span>
                                                </div>
                                                <div className="flex gap-2">
                                                    {match.job.salary && (
                                                        <span className="px-2 py-1 bg-green-900/20 text-green-400 text-xs font-bold rounded-lg border border-green-900/30">
                                                            {match.job.salary}
                                                        </span>
                                                    )}
                                                    {match.matchReasons.slice(0, 2).map(r => (
                                                        <span key={r} className="px-2 py-1 bg-white/5 text-gray-400 text-xs font-medium rounded-lg border border-white/5">
                                                            {r}
                                                        </span>
                                                    ))}
                                                </div>
                                            </div>
                                        </div>

                                        <div className="flex flex-col items-end justify-center min-w-[80px]">
                                            <div className={`text-2xl font-black ${getTier(match.matchScore) === 'S' ? 'text-yellow-400' : 'text-blue-400'}`}>
                                                {match.matchScore}%
                                            </div>
                                            <div className="text-xs font-bold text-gray-500 uppercase tracking-widest">Match</div>
                                        </div>
                                    </div>
                                </div>
                            </Link>
                        ))}
                        
                        <div className="pt-4 flex justify-center">
                            <Link href="/jobs">
                                <button className="px-8 py-3 bg-white text-black font-bold rounded-xl hover:bg-gray-200 transition-colors">
                                    View All {stats.jobsFound} Jobs
                                </button>
                            </Link>
                        </div>
                    </>
                ) : (
                    // EMPTY STATE
                    <div className="p-12 text-center border border-dashed border-gray-800 rounded-3xl">
                        <div className="p-4 bg-gray-800/50 rounded-full mb-4 inline-block">
                            <AlertCircle className="w-8 h-8 text-gray-500" />
                        </div>
                        <h3 className="text-xl font-bold text-gray-300 mb-2">No matches found</h3>
                        <p className="text-gray-500 mb-4 text-center max-w-sm mx-auto">
                            {excludedKeywords.length > 0 && jobMatches.length > 0 
                            ? `Hidden ${jobMatches.length - filteredAndSortedMatches.length} jobs matching your exclusions.`
                            : "We couldn't find any jobs matching your criteria right now."}
                        </p>
                        <button onClick={() => {setSearchQuery(''); setSortBy('match');}} className="text-blue-400 hover:underline">Clear Filters</button>
                    </div>
                )}
            </div>
        </section>

      </div>
    </div>
  );
}
===== ./src/app/forgot-password/page.tsx =====
"use client";

import React, { useState } from 'react';
import Link from 'next/link';
import { sendPasswordResetEmail } from 'firebase/auth';
import { auth } from '@/lib/firebase';
import { 
  Mail, 
  ArrowLeft, 
  Loader2, 
  CheckCircle, 
  AlertCircle,
  Sparkles
} from 'lucide-react';

export default function ForgotPasswordPage() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    setSuccess(false);

    try {
      await sendPasswordResetEmail(auth, email);
      setSuccess(true);
    } catch (err: any) {
      if (err.code === 'auth/user-not-found') {
        setError("No account found with this email.");
      } else {
        setError(err.message || 'Failed to send reset email.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30 flex items-center justify-center p-4">
      
      {/* Background Gradients */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 right-1/4 w-96 h-96 bg-blue-500/10 rounded-full blur-[120px] animate-pulse" />
        <div className="absolute bottom-0 left-1/4 w-96 h-96 bg-purple-500/10 rounded-full blur-[120px] animate-pulse animation-delay-2000" />
        <div className="absolute inset-0 opacity-10" 
          style={{ backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`, backgroundSize: '40px 40px' }} 
        />
      </div>

      <div className="w-full max-w-md">
        
        {/* Header */}
        <div className="text-center mb-8">
          <div className="flex items-center justify-center gap-2 mb-3">
            <div className="p-2 bg-gradient-to-tr from-blue-600 to-purple-600 rounded-xl shadow-lg shadow-blue-900/20">
              <Sparkles className="w-6 h-6 text-white" />
            </div>
            <span className="text-2xl font-black tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-white to-gray-400">
              JobHunt AI
            </span>
          </div>
          <h2 className="text-xl font-bold text-white">Reset Password</h2>
          <p className="text-gray-400 text-sm mt-1">
            Enter your email and we'll send you a link to reset your password.
          </p>
        </div>

        {/* Card */}
        <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-8 shadow-2xl">
          
          {!success ? (
            <form onSubmit={handleSubmit} className="space-y-6">
              
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-300 ml-1">Email Address</label>
                <div className="relative">
                  <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
                  <input 
                    type="email" 
                    required
                    placeholder="name@example.com"
                    className="w-full bg-gray-800/50 border border-gray-700 text-white rounded-xl py-3 pl-10 pr-4 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all placeholder:text-gray-600"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                  />
                </div>
              </div>

              {error && (
                <div className="p-3 bg-red-500/10 border border-red-500/20 rounded-xl flex items-center gap-2 text-sm text-red-400 animate-in fade-in slide-in-from-top-1">
                  <AlertCircle className="w-4 h-4" /> {error}
                </div>
              )}

              <button 
                type="submit" 
                disabled={loading}
                className="w-full bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-3 rounded-xl shadow-lg shadow-blue-900/20 transition-all flex items-center justify-center gap-2"
              >
                {loading ? (
                  <>
                    <Loader2 className="w-5 h-5 animate-spin" />
                    Sending Link...
                  </>
                ) : (
                  'Send Reset Link'
                )}
              </button>
            </form>
          ) : (
            <div className="text-center py-4 animate-in fade-in zoom-in duration-300">
              <div className="w-16 h-16 bg-green-500/20 text-green-400 rounded-full flex items-center justify-center mx-auto mb-4 border border-green-500/30">
                <CheckCircle className="w-8 h-8" />
              </div>
              <h3 className="text-lg font-bold text-white mb-2">Check your email</h3>
              <p className="text-gray-400 text-sm mb-6">
                We have sent a password reset link to <span className="text-white font-medium">{email}</span>.
              </p>
              <button 
                onClick={() => setSuccess(false)}
                className="text-blue-400 hover:text-blue-300 text-sm font-medium transition-colors"
              >
                Try a different email
              </button>
            </div>
          )}

        </div>

        {/* Back Link */}
        <div className="text-center mt-8">
          <Link 
            href="/auth/signin" 
            className="inline-flex items-center text-gray-500 hover:text-white transition-colors text-sm font-medium"
          >
            <ArrowLeft className="w-4 h-4 mr-2" /> Back to Sign In
          </Link>
        </div>

      </div>
    </div>
  );
}
===== ./src/app/jobs/[id]/page.tsx =====
"use client";

import React, { useEffect, useState, useCallback, useRef } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { 
  doc, 
  getDoc, 
  collection, 
  addDoc, 
  serverTimestamp, 
  query, 
  where, 
  getDocs, 
  updateDoc, 
  limit, 
  increment
} from 'firebase/firestore';
import { db, auth } from '@/lib/firebase';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ArrowLeft, ArrowRight, Building2, MapPin, Clock, ExternalLink, CheckCircle, Bookmark, Check, Loader2, Zap, Download, DollarSign, Users, Layers, Target, AlertCircle, Sparkles } from 'lucide-react';
import Link from 'next/link';
import { formatDistanceToNow } from 'date-fns';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import ApplicationStatusTracker from '@/components/ApplicationStatusTracker';

interface Job {
  id: string;
  title: string;
  company: string;
  location: string;
  url: string;
  source: string;
  postedAt: any;
  tags: string[];
  description?: string;
  requirements?: string[];
  salary?: string;
  jobType?: string;
  experienceLevel?: string;
  skills?: string[];
}

interface UserProfile {
  uid: string;
  skills: string[];
  yearsOfExperience?: number;
  location?: string;
  desiredSalary?: string;
  resumeUrl?: string;
  name?: string;
}

export default function JobDetailsPage() {
  const { id } = useParams();
  const router = useRouter();
  const { user } = useAuth();
  
  const [job, setJob] = useState<Job | null>(null);
  const [loading, setLoading] = useState(true);
  const [applying, setApplying] = useState(false);
  const [saving, setSaving] = useState(false);
  const [isSaved, setIsSaved] = useState(false);
  const [autoApplying, setAutoApplying] = useState(false);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [matchScore, setMatchScore] = useState<number>(0);
  const [matchDetails, setMatchDetails] = useState<{
    reasons: string[];
    weaknesses: string[];
    suggestions: string[];
  }>({ reasons: [], weaknesses: [], suggestions: [] });
  const [applicationId, setApplicationId] = useState<string | null>(null);
  const [showApplicationStatus, setShowApplicationStatus] = useState(false);
  
  // AI Analysis State
  const [aiAnalysis, setAiAnalysis] = useState<string>('');
  const [aiLoading, setAiLoading] = useState(false); // Changed to false initially
  const [aiError, setAiError] = useState<string | null>(null);
  
  // Navigation state - track where user came from
  const [referrer, setReferrer] = useState<string>('/dashboard');
  
  // Ref to prevent duplicate AI calls
  const aiCallMadeRef = useRef(false);

  // Store referrer on mount
  useEffect(() => {
    if (typeof window !== 'undefined' && document.referrer) {
      const ref = new URL(document.referrer).pathname;
      if (ref.includes('/jobs')) {
        setReferrer('/jobs');
      } else if (ref.includes('/dashboard')) {
        setReferrer('/dashboard');
      }
    }
  }, []);

  const parseSalary = useCallback((salaryStr: string): number | null => {
    if (!salaryStr) return null;
    
    try {
      const numbers = salaryStr.match(/\d+/g);
      if (numbers && numbers.length > 0) {
        let salary = parseInt(numbers[0]);
        
        if (salaryStr.toLowerCase().includes('k')) {
          salary *= 1000;
        }
        
        if (salaryStr.toLowerCase().includes('hour') || salaryStr.includes('/hr')) {
          salary *= 2000;
        }
        
        return salary;
      }
    } catch (error) {
      console.error('Error parsing salary:', error);
    }
    
    return null;
  }, []);

  // IMPROVED: More robust match score calculation with fallbacks
  const calculateMatchScore = useCallback((job: Job, userProfile: UserProfile): number => {
    if (!job || !userProfile) return 0;
    
    console.log('Calculating match score:', { 
      userSkills: userProfile.skills?.length || 0, 
      jobTags: job.tags?.length || 0,
      userExp: userProfile.yearsOfExperience 
    });
    
    // If no user skills, provide a basic score
    if (!userProfile.skills || userProfile.skills.length === 0) {
      return 50; // Base score when profile is incomplete
    }
    
    let score = 0;
    const userSkills = userProfile.skills || [];
    const jobTags = job.tags || [];
    const jobSkills = job.skills || [];
    
    const weights = {
      skills: 0.40,
      experience: 0.25,
      location: 0.15,
      salary: 0.10,
      roleFit: 0.10
    };
    
    // 1. Skill Match
    const allJobKeywords = [...new Set([...jobTags, ...jobSkills])];
    if (allJobKeywords.length > 0) {
      const matchedSkills = userSkills.filter((skill: string) => 
        allJobKeywords.some(keyword => 
          keyword.toLowerCase().includes(skill.toLowerCase()) || 
          skill.toLowerCase().includes(keyword.toLowerCase())
        )
      );
      score += (matchedSkills.length / allJobKeywords.length) * 100 * weights.skills;
      console.log('Skill match:', matchedSkills.length, '/', allJobKeywords.length);
    }
    
    // 2. Experience Level Match
    const userExperience = userProfile.yearsOfExperience || 0;
    if (job.experienceLevel) {
      const level = job.experienceLevel.toLowerCase();
      if (level.includes('senior') && userExperience >= 5) {
        score += 100 * weights.experience;
      } else if (level.includes('mid') && userExperience >= 2 && userExperience < 5) {
        score += 75 * weights.experience;
      } else if (level.includes('entry') && userExperience <= 2) {
        score += 100 * weights.experience;
      } else if (userExperience >= 3) {
        score += Math.min(userExperience / 10, 1) * 100 * weights.experience;
      }
    }
    
    // 3. Location Match
    const userLocation = (userProfile.location || '').toLowerCase();
    const jobLocation = (job.location || '').toLowerCase();
    const isRemote = jobLocation.includes('remote') || jobLocation.includes('anywhere');
    const isHybrid = jobLocation.includes('hybrid');
    
    if (isRemote) {
      score += 100 * weights.location;
    } else if (isHybrid) {
      score += 50 * weights.location;
    } else if (userLocation) {
      const userCity = userLocation.split(',')[0]?.trim();
      const jobCity = jobLocation.split(',')[0]?.trim();
      if (userCity && jobCity && (jobLocation.includes(userCity) || userLocation.includes(jobCity))) {
        score += 100 * weights.location;
      }
    }
    
    // 4. Salary Match
    if (job.salary && userProfile.desiredSalary) {
      const jobSalary = parseSalary(job.salary);
      const userSalary = parseSalary(userProfile.desiredSalary);
      if (jobSalary && userSalary) {
        const salaryRatio = jobSalary / userSalary;
        if (salaryRatio >= 1) {
          score += 100 * weights.salary;
        } else if (salaryRatio >= 0.8) {
          score += 80 * weights.salary;
        } else if (salaryRatio >= 0.6) {
          score += 50 * weights.salary;
        }
      }
    }
    
    // 5. Role Fit
    const titleKeywords = job.title.toLowerCase().split(/[\s\-]+/);
    const commonRoles = ['engineer', 'developer', 'manager', 'analyst', 'designer', 'specialist'];
    const userRoleMatch = commonRoles.some(role => 
      userSkills.some(skill => skill.toLowerCase().includes(role)) ||
      titleKeywords.some(keyword => keyword.includes(role))
    );
    if (userRoleMatch) {
      score += 100 * weights.roleFit;
    }
    
    const finalScore = Math.min(Math.round(score), 100);
    console.log('Final calculated score:', finalScore);
    return finalScore;
  }, [parseSalary]);

  const handleApplyAndTrack = async (applicationData: {
    jobId: string;
    jobTitle: string;
    company: string;
    jobUrl: string;
    matchScore?: number;
    salary?: string;
    location?: string;
    method?: string;
    status?: string;
  }) => {
    if (!user) return null;

    try {
      const docRef = await addDoc(collection(db, 'applications'), {
        userId: user.uid,
        ...applicationData,
        status: applicationData.status || 'applied',
        appliedAt: serverTimestamp(),
        source: 'jobhunt-ai',
        notes: applicationData.method === 'auto-apply' ? 'AI auto-apply' : 'Applied via company website',
        progress: 0,
        progressMessage: 'Application submitted',
        matchDetails: matchDetails,
        aiAnalysis: aiAnalysis
      });

      const userRef = doc(db, 'users', user.uid);
      await updateDoc(userRef, {
        'stats.applications': increment(1),
        'stats.lastAppliedAt': serverTimestamp()
      });

      return docRef.id;
    } catch (error) {
      console.error('Error tracking application:', error);
      return null;
    }
  };

  // OPTIMIZED: Load job and profile data FIRST, AI analysis in background
  useEffect(() => {
    if (!id || !user) return;
    const currentUser = user; // narrowed: guaranteed non-null from here down
    
    let isMounted = true;
    
    async function loadJobAndProfile() {
      setLoading(true);
      try {
        // Parallel load of job and profile
        const [jobSnapshot, userSnapshot] = await Promise.all([
          getDoc(doc(db, 'jobs', id as string)),
          getDoc(doc(db, 'users', currentUser.uid))
        ]);
        
        if (!isMounted) return;
        
        if (jobSnapshot.exists()) {
          const jobData = { id: jobSnapshot.id, ...jobSnapshot.data() } as Job;
          setJob(jobData);
          
          let calculatedScore = 0;
          
          if (userSnapshot.exists()) {
            const userData = { uid: userSnapshot.id, ...userSnapshot.data() } as UserProfile;
            setUserProfile(userData);
            
            // Calculate score immediately for instant display
            calculatedScore = calculateMatchScore(jobData, userData);
            setMatchScore(calculatedScore);
            console.log('Set initial match score:', calculatedScore);
            
            // Provide basic match details immediately
            const basicReasons = [];
            if (calculatedScore >= 70) {
              basicReasons.push(`Strong ${calculatedScore}% match based on your profile`);
              if (userData.skills?.length > 0) {
                basicReasons.push(`Your skills align with ${jobData.tags?.length || 0} required technologies`);
              }
            } else if (calculatedScore >= 50) {
              basicReasons.push(`Good ${calculatedScore}% match - some skills align`);
            } else {
              basicReasons.push(`${calculatedScore}% match - consider developing relevant skills`);
            }
            
            setMatchDetails({
              reasons: basicReasons,
              weaknesses: ['AI analysis loading...'],
              suggestions: ['Detailed suggestions coming soon...']
            });
          }

          // Mark as viewed (non-blocking)
          const markAsViewed = async () => {
            try {
              const matchQuery = query(
                collection(db, 'user_job_matches'), 
                where('userId', '==', currentUser.uid), 
                where('jobId', '==', id), 
                limit(1)
              );
              const snapshot = await getDocs(matchQuery);
              if (!snapshot.empty) {
                await updateDoc(snapshot.docs[0].ref, { 
                  viewed: true, 
                  viewedAt: serverTimestamp() 
                });
              }
            } catch (err) {
              console.error("Error marking as viewed:", err);
            }
          };
          markAsViewed();
          
          // Check if saved (non-blocking)
          const checkSaved = async () => {
            try {
              const savedQuery = query(
                collection(db, 'saved_jobs'),
                where('userId', '==', currentUser.uid),
                where('jobId', '==', id)
              );
              const savedSnapshot = await getDocs(savedQuery);
              if (isMounted) setIsSaved(!savedSnapshot.empty);
            } catch (err) {
              console.error("Error checking saved status:", err);
            }
          };
          checkSaved();
        }
        
      } catch (error) {
        console.error("Error loading data:", error);
      } finally {
        if (isMounted) setLoading(false);
      }
    }
    
    loadJobAndProfile();
    
    return () => {
      isMounted = false;
    };
  }, [id, user, calculateMatchScore]);

  // SEPARATE EFFECT: Load AI analysis in background (non-blocking)
  useEffect(() => {
    if (!job || !userProfile || aiCallMadeRef.current) return;
    
    let isMounted = true;
    const aiController = new AbortController();
    
    async function loadAIAnalysis() {
      aiCallMadeRef.current = true;
      setAiLoading(true);
      setAiError(null);
      
      try {
        const response = await fetch('/api/analyze-job', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userProfile, job }),
          signal: aiController.signal
        });
        
        if (!isMounted) return;
        
        if (!response.ok) {
          throw new Error(`API returned ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.matchResult) {
          setMatchDetails({
            reasons: data.matchResult.reasons || [],
            weaknesses: data.matchResult.weaknesses || [],
            suggestions: data.matchResult.suggestions || []
          });
          
          // Update score if AI provides a better one
          if (data.matchResult.score && data.matchResult.score !== matchScore) {
            console.log('Updating score from AI:', data.matchResult.score);
            setMatchScore(data.matchResult.score);
          }
        }
        
        if (data.analysis) {
          setAiAnalysis(data.analysis);
        }
        
      } catch (err: any) {
        if (err.name === 'AbortError') return;
        
        if (!isMounted) return;
        
        console.error('AI API error:', err);
        setAiError('AI analysis unavailable');
        
        // Keep the basic analysis we set earlier
        
      } finally {
        if (isMounted) setAiLoading(false);
      }
    }
    
    // Small delay to let page render first
    const timer = setTimeout(loadAIAnalysis, 300);
    
    return () => {
      clearTimeout(timer);
      isMounted = false;
      aiController.abort();
    };
  }, [job, userProfile, matchScore]);

  const handleTrackApplication = async () => {
    if (!user || !job) return;
    
    setApplying(true);
    
    try {
      await handleApplyAndTrack({
        jobId: job.id,
        jobTitle: job.title,
        company: job.company,
        jobUrl: job.url,
        location: job.location || 'Location not specified',
        salary: job.salary || 'Salary not specified',
        matchScore: matchScore,
        method: 'manual',
        status: 'applied'
      });

      window.open(job.url, '_blank', 'noopener,noreferrer');
      
      setTimeout(() => {
        router.push('/applications');
      }, 2000);
      
    } catch (error) {
      console.error("Error in application flow:", error);
      alert('âŒ Failed to track application. Please try again.');
    } finally {
      setApplying(false);
    }
  };

  const handleAutoApply = async () => {
    if (!user || !job) return;
    
    setAutoApplying(true);
    
    try {
      if (!userProfile?.resumeUrl) {
        alert("âš ï¸ Please upload your master resume in Settings â†’ Resume first!");
        router.push('/settings/resume');
        setAutoApplying(false);
        return;
      }

      const applicationId = await handleApplyAndTrack({
        jobId: job.id,
        jobTitle: job.title,
        company: job.company,
        jobUrl: job.url,
        location: job.location || 'Location not specified',
        salary: job.salary || 'Salary not specified',
        matchScore: matchScore,
        method: 'auto-apply',
        status: 'queued'
      });

      if (applicationId) {
        setApplicationId(applicationId);
        setShowApplicationStatus(true);
      } else {
        throw new Error('Failed to create application record');
      }
      
    } catch (error) {
      console.error("Auto-apply error:", error);
      alert("âŒ Failed to start auto-apply. Please try again.");
    } finally {
      setAutoApplying(false);
    }
  };

  const handleApplicationComplete = (finalStatus: string) => {
    if (finalStatus === 'applied') {
      setTimeout(() => {
        router.push('/applications');
      }, 3000);
    }
  };

  const handleSaveJob = async () => {
    if (!user || !job || isSaved) return;
    setSaving(true);
    try {
      await addDoc(collection(db, 'saved_jobs'), {
        userId: user.uid,
        jobId: job.id,
        jobTitle: job.title,
        company: job.company,
        location: job.location || 'Location not specified',
        salary: job.salary || 'Salary not specified',
        matchScore: matchScore,
        matchDetails: matchDetails,
        savedAt: serverTimestamp()
      });
      setIsSaved(true);
    } catch (error) {
      console.error("Error saving job:", error);
    } finally {
      setSaving(false);
    }
  };

  if (loading) return (
    <div className="flex justify-center items-center min-h-screen bg-gradient-to-br from-slate-50 to-blue-50">
      <div className="text-center">
        <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-blue-600 mx-auto mb-4"></div>
        <p className="text-slate-600">Loading job details...</p>
      </div>
    </div>
  );
  
  if (!job) return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-blue-50 flex items-center justify-center">
      <div className="text-center p-12 max-w-md">
        <AlertCircle className="w-16 h-16 text-amber-500 mx-auto mb-6" />
        <h2 className="text-2xl font-bold text-slate-900 mb-4">Job not found</h2>
        <p className="text-slate-600 mb-8">The job you're looking for may have been removed or doesn't exist.</p>
        <Link href="/dashboard" className="inline-flex items-center px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
          <ArrowLeft className="w-4 h-4 mr-2" />
          Back to Dashboard
        </Link>
      </div>
    </div>
  );

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-blue-50 py-8 px-4 sm:px-6 lg:px-8">
      <div className="max-w-6xl mx-auto">
        {/* IMPROVED: Dual Navigation */}
        <div className="flex items-center justify-between mb-8">
          <Link href={referrer} className="inline-flex items-center text-slate-600 hover:text-slate-900 group">
            <ArrowLeft className="w-4 h-4 mr-2 group-hover:-translate-x-1 transition-transform" />
            Back to {referrer === '/jobs' ? 'Jobs' : 'Dashboard'}
          </Link>
          
          {referrer !== '/dashboard' && (
            <Link href="/dashboard" className="inline-flex items-center text-blue-600 hover:text-blue-800 text-sm font-medium">
              Dashboard
              <ArrowRight className="w-4 h-4 ml-1" />
            </Link>
          )}
        </div>

        <div className="bg-white rounded-2xl shadow-lg border border-slate-200 overflow-hidden mb-8">
          <div className="p-8 border-b border-slate-100">
            <div className="flex flex-col gap-8">
              {/* Job Header */}
              <div>
                <div className="flex flex-col md:flex-row md:items-start justify-between gap-6 mb-6">
                  <div className="flex-1">
                    <div className="inline-flex items-center gap-2 bg-blue-50 text-blue-700 px-3 py-1 rounded-full text-sm font-medium mb-4">
                      <span className="w-2 h-2 bg-blue-500 rounded-full"></span>
                      {job.source}
                    </div>
                    
                    <h1 className="text-3xl md:text-4xl font-bold text-slate-900 mb-3">{job.title}</h1>
                    
                    <div className="flex flex-wrap items-center gap-4 text-slate-600 mb-6">
                      <div className="flex items-center gap-2 bg-slate-50 px-3 py-1.5 rounded-lg">
                        <Building2 className="w-4 h-4 text-blue-600" />
                        <span className="font-medium">{job.company}</span>
                      </div>
                      <div className="flex items-center gap-2 bg-slate-50 px-3 py-1.5 rounded-lg">
                        <MapPin className="w-4 h-4 text-slate-400" />
                        <span>{job.location || 'Location not specified'}</span>
                      </div>
                      <div className="flex items-center gap-2 bg-slate-50 px-3 py-1.5 rounded-lg">
                        <Clock className="w-4 h-4 text-slate-400" />
                        <span>
                          {job.postedAt?.seconds 
                            ? formatDistanceToNow(new Date(job.postedAt.seconds * 1000), { addSuffix: true }) 
                            : 'Recently'}
                        </span>
                      </div>
                    </div>
                  </div>
                  
                  {/* Match Score Card - Shows immediately */}
                  <div className="bg-gradient-to-r from-blue-50 to-purple-50 px-6 py-4 rounded-xl border border-blue-100 min-w-[180px]">
                    <div className="flex items-center gap-3 mb-2">
                      <Target className="w-5 h-5 text-blue-600" />
                      <span className="text-sm font-medium text-blue-600">AI Match Score</span>
                    </div>
                    <div className={`text-3xl font-bold mb-1 ${
                      matchScore >= 85 ? 'text-green-600' :
                      matchScore >= 70 ? 'text-blue-600' :
                      matchScore >= 50 ? 'text-amber-600' : 'text-red-600'
                    }`}>
                      {matchScore}%
                    </div>
                    <div className="text-xs text-blue-800">
                      {matchScore >= 85 ? 'Excellent Match' :
                       matchScore >= 70 ? 'Strong Match' :
                       matchScore >= 50 ? 'Good Match' : 'Low Match'}
                    </div>
                  </div>
                </div>

                {/* Job Tags and Details */}
                <div className="flex flex-col gap-6">
                  <div className="flex flex-wrap gap-2">
                    {job.tags?.map((tag, i) => (
                      <Badge key={i} variant="secondary" className="bg-slate-100 text-slate-600 hover:bg-slate-200 px-3 py-1.5">
                        {tag}
                      </Badge>
                    ))}
                  </div>

                  {/* Additional Job Details Grid */}
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    {job.salary && (
                      <div className="bg-gradient-to-r from-green-50 to-emerald-50 border border-green-100 rounded-xl p-4">
                        <div className="flex items-center gap-3 mb-2">
                          <DollarSign className="w-5 h-5 text-green-600" />
                          <span className="font-medium text-green-700">Salary</span>
                        </div>
                        <p className="text-green-900 font-semibold">{job.salary}</p>
                      </div>
                    )}
                    
                    {job.jobType && (
                      <div className="bg-gradient-to-r from-purple-50 to-pink-50 border border-purple-100 rounded-xl p-4">
                        <div className="flex items-center gap-3 mb-2">
                          <Layers className="w-5 h-5 text-purple-600" />
                          <span className="font-medium text-purple-700">Job Type</span>
                        </div>
                        <p className="text-purple-900 font-semibold">{job.jobType}</p>
                      </div>
                    )}
                    
                    {job.experienceLevel && (
                      <div className="bg-gradient-to-r from-amber-50 to-orange-50 border border-amber-100 rounded-xl p-4">
                        <div className="flex items-center gap-3 mb-2">
                          <Users className="w-5 h-5 text-amber-600" />
                          <span className="font-medium text-amber-700">Experience Level</span>
                        </div>
                        <p className="text-amber-900 font-semibold">{job.experienceLevel}</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* AI Analysis Section - Loads in background */}
              {aiLoading ? (
                <div className="bg-blue-50 border border-blue-100 rounded-xl p-6 flex items-center justify-center gap-3">
                  <Loader2 className="w-5 h-5 text-blue-600 animate-spin" />
                  <span className="text-blue-700 font-medium">Loading AI analysis...</span>
                </div>
              ) : aiError ? (
                <Alert className="bg-amber-50 border-amber-200">
                  <AlertCircle className="w-5 h-5" />
                  <AlertDescription className="text-amber-800">
                    <strong>{aiError}</strong>. Basic match analysis is shown instead.
                  </AlertDescription>
                </Alert>
              ) : aiAnalysis && (
                <div className="bg-gradient-to-r from-blue-50 to-cyan-50 border border-blue-100 rounded-xl p-6">
                  <h3 className="flex items-center gap-2 font-semibold text-blue-900 mb-3">
                    <Sparkles className="w-5 h-5 text-blue-600" />
                    AI Career Coach Analysis
                  </h3>
                  <p className="text-blue-800 leading-relaxed">{aiAnalysis}</p>
                  
                  {matchDetails.suggestions.length > 0 && (
                    <div className="mt-4">
                      <h4 className="text-sm font-medium text-blue-700 mb-2">Suggestions to improve match:</h4>
                      <ul className="space-y-1.5">
                        {matchDetails.suggestions.map((suggestion, idx) => (
                          <li key={idx} className="flex items-start gap-2 text-sm text-blue-800">
                            <div className="w-1.5 h-1.5 bg-blue-500 rounded-full mt-1.5 flex-shrink-0"></div>
                            <span>{suggestion}</span>
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              )}

              {/* Resume Warning */}
              {!userProfile?.resumeUrl && (
                <Alert className="bg-gradient-to-r from-amber-50 to-orange-50 border-amber-200">
                  <AlertDescription className="text-amber-800 flex items-center gap-2">
                    <AlertCircle className="w-5 h-5 flex-shrink-0" />
                    <div>
                      <strong>No master resume uploaded.</strong> Upload your resume in Settings â†’ Resume to enable PDF generation and Auto-Apply.
                    </div>
                  </AlertDescription>
                </Alert>
              )}

              {/* Application Status Tracker */}
              {showApplicationStatus && applicationId && (
                <div className="mt-4">
                  <ApplicationStatusTracker 
                    applicationId={applicationId}
                    onComplete={handleApplicationComplete}
                  />
                </div>
              )}

              {/* Action Buttons Grid */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Auto-Apply Button */}
                {userProfile?.resumeUrl ? (
                  <Button 
                    size="lg" 
                    onClick={handleAutoApply} 
                    disabled={autoApplying || showApplicationStatus}
                    className="bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 shadow-lg h-14"
                  >
                    {autoApplying ? (
                      <>
                        <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                        Starting Auto-Apply...
                      </>
                    ) : showApplicationStatus ? (
                      <>
                        <CheckCircle className="w-5 h-5 mr-2" />
                        Auto-Apply Started
                      </>
                    ) : (
                      <>
                        <Zap className="w-5 h-5 mr-2" />
                        Auto-Apply Now
                      </>
                    )}
                  </Button>
                ) : (
                  <Button 
                    size="lg" 
                    onClick={() => router.push('/settings/resume')}
                    className="bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 shadow-lg h-14"
                  >
                    <Download className="w-5 h-5 mr-2" />
                    Upload Resume to Auto-Apply
                  </Button>
                )}
                
                {/* Manual Apply Button */}
                <Button 
                  size="lg" 
                  onClick={handleTrackApplication} 
                  disabled={applying}
                  className="bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 shadow-lg h-14"
                >
                  {applying ? (
                    <>
                      <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                      Redirecting...
                    </>
                  ) : (
                    <>
                      <ExternalLink className="w-5 h-5 mr-2" />
                      Apply Manually
                    </>
                  )}
                </Button>
                
                {/* Save Job Button */}
                <Button 
                  variant={isSaved ? "secondary" : "outline"} 
                  size="lg" 
                  onClick={handleSaveJob} 
                  disabled={saving || isSaved} 
                  className={`h-14 ${isSaved ? 'bg-gradient-to-r from-green-50 to-emerald-50 text-green-700 border-green-200 hover:bg-green-100' : 'border-slate-200 hover:bg-slate-50'}`}
                >
                  {isSaved ? (
                    <>
                      <Check className="w-5 h-5 mr-2" />
                      Saved to Library
                    </>
                  ) : (
                    <>
                      <Bookmark className="w-5 h-5 mr-2" />
                      {saving ? 'Saving...' : 'Save for Later'}
                    </>
                  )}
                </Button>

                {/* View Job Page Button */}
                <Button 
                  variant="outline" 
                  size="lg" 
                  onClick={() => window.open(job.url, '_blank', 'noopener,noreferrer')}
                  className="border-slate-200 hover:bg-slate-50 h-14"
                >
                  <ExternalLink className="w-5 h-5 mr-2" />
                  View Job Page
                </Button>
              </div>
            </div>
          </div>

          {/* Job Description Section */}
          <div className="p-8 border-b border-slate-100">
            <h3 className="text-xl font-bold text-slate-900 mb-6 flex items-center gap-2">
              <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
              Job Description
            </h3>
            <div className="prose max-w-none">
              <div className="bg-slate-50 p-6 rounded-xl border border-slate-200 whitespace-pre-wrap text-slate-700 leading-relaxed">
                {job.description || 'No description available for this job.'}
              </div>
              
              {/* Match Analysis Details */}
              <div className="bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-100 rounded-xl p-6 my-8">
                <h4 className="flex items-center gap-2 font-semibold text-blue-900 mb-4 text-lg">
                  <Target className="w-5 h-5 text-blue-600" />
                  Your Match Analysis
                </h4>
                <div className="mb-6">
                  <div className="flex items-center justify-between text-sm font-medium text-blue-800 mb-2">
                    <span>AI Match Score</span>
                    <span className={`font-bold ${
                      matchScore >= 85 ? 'text-green-600' :
                      matchScore >= 70 ? 'text-blue-600' :
                      matchScore >= 50 ? 'text-amber-600' : 'text-red-600'
                    }`}>
                      {matchScore}%
                    </span>
                  </div>
                  <Progress 
                    value={matchScore} 
                    className={`h-2.5 ${
                      matchScore >= 85 ? 'bg-green-100' :
                      matchScore >= 70 ? 'bg-blue-100' :
                      matchScore >= 50 ? 'bg-amber-100' : 'bg-red-100'
                    }`}
                  />
                </div>
                
                {/* Match Reasons */}
                {matchDetails.reasons.length > 0 && (
                  <div className="mb-4">
                    <h5 className="text-sm font-medium text-green-700 mb-2">Strengths</h5>
                    <ul className="space-y-2">
                      {matchDetails.reasons.slice(0, 3).map((reason, idx) => (
                        <li key={idx} className="flex items-start gap-2 text-sm text-green-800">
                          <CheckCircle className="w-4 h-4 text-green-500 mt-0.5 flex-shrink-0" />
                          <span>{reason}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
                
                {/* Weaknesses */}
                {matchDetails.weaknesses.length > 0 && !matchDetails.weaknesses[0].includes('loading') && (
                  <div>
                    <h5 className="text-sm font-medium text-amber-700 mb-2">Areas to Improve</h5>
                    <ul className="space-y-2">
                      {matchDetails.weaknesses.slice(0, 2).map((weakness, idx) => (
                        <li key={idx} className="flex items-start gap-2 text-sm text-amber-800">
                          <AlertCircle className="w-4 h-4 text-amber-500 mt-0.5 flex-shrink-0" />
                          <span>{weakness}</span>
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Requirements Section */}
          {job.requirements && job.requirements.length > 0 && (
            <div className="p-8">
              <h3 className="text-xl font-bold text-slate-900 mb-6 flex items-center gap-2">
                <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
                Requirements
              </h3>
              <ul className="space-y-3">
                {job.requirements.map((req, index) => (
                  <li key={index} className="flex items-start gap-4 p-4 bg-slate-50 rounded-lg border border-slate-200">
                    <div className="w-6 h-6 rounded-full bg-blue-100 flex items-center justify-center flex-shrink-0">
                      <span className="text-blue-600 font-bold text-sm">{index + 1}</span>
                    </div>
                    <span className="text-slate-700 pt-0.5">{req}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>

        {/* Bottom Navigation */}
        <div className="flex flex-col sm:flex-row justify-between items-center gap-4 pt-8 border-t border-slate-200">
          <Link 
            href="/jobs" 
            className="inline-flex items-center text-blue-600 hover:text-blue-800 hover:underline font-medium"
          >
            <ArrowLeft className="w-4 h-4 mr-2" />
            Browse more jobs
          </Link>
          <Link 
            href="/applications" 
            className="inline-flex items-center text-blue-600 hover:text-blue-800 hover:underline font-medium"
          >
            View your applications
            <ExternalLink className="w-4 h-4 ml-2" />
          </Link>
        </div>
      </div>
    </div>
  );
}
===== ./src/app/jobs/page.tsx =====
"use client";

import React, { useState, useEffect, useCallback } from 'react';
import Link from 'next/link';
import { useAuth } from '@/contexts/AuthContext';
import { db } from '@/lib/firebase';
import { 
  collection, 
  query, 
  orderBy, 
  where, 
  getDocs, 
  addDoc, 
  serverTimestamp, 
  documentId,
  doc,
  getDoc
} from 'firebase/firestore';
import { 
  Search, MapPin, Clock, Building2, Plus, DollarSign, 
  ArrowRight, Target, ChevronLeft, ChevronRight, Sparkles, 
  X, Briefcase, Zap, Bookmark, Filter, Scale // Added Scale icon
} from 'lucide-react';
// Added isToday and isThisWeek for better filtering
import { formatDistanceToNow, isToday, isThisWeek } from 'date-fns';

// --- Interfaces ---
interface Job {
  id: string;
  title: string;
  company: string;
  location: string;
  type: string;
  salary: string;
  postedAt: any;
  tags: string[];
  url?: string;
  description?: string;
  requirements?: string[];
  source?: string;
}

interface MatchedJob extends Job {
  matchScore?: number;
  matchReasons?: string[];
  matchedKeywords?: string[];
  notifiedAt?: any;
  viewed?: boolean;
}

// Define explicit interface for Firestore Match Data to fix TypeScript inference
interface FirestoreMatchData {
  matchId: string;
  jobId: string;
  matchScore?: number;
  matchReasons?: string[];
  matchedKeywords?: string[];
  notifiedAt?: any;
  viewed?: boolean;
  [key: string]: any;
}

// --- Component: Circular Progress ---
const CircularProgress = ({ score, color }: { score: number; color: string }) => {
  const radius = 18;
  const circumference = 2 * Math.PI * radius;
  const offset = circumference - (score / 100) * circumference;

  return (
    <div className="relative w-12 h-12 flex items-center justify-center">
      <svg className="transform -rotate-90 w-12 h-12">
        <circle
          className="text-gray-800"
          strokeWidth="3"
          stroke="currentColor"
          fill="transparent"
          r={radius}
          cx="24"
          cy="24"
        />
        <circle
          className={color}
          strokeWidth="3"
          strokeDasharray={circumference}
          strokeDashoffset={offset}
          strokeLinecap="round"
          stroke="currentColor"
          fill="transparent"
          r={radius}
          cx="24"
          cy="24"
          style={{ transition: "stroke-dashoffset 1s ease-out" }}
        />
      </svg>
      <span className="absolute text-[10px] font-bold text-white">{score}%</span>
    </div>
  );
};

// --- Component: Skeleton Loader ---
const JobCardSkeleton = () => (
  <div className="relative bg-gray-900/40 border border-gray-800 rounded-3xl p-6 overflow-hidden">
    <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/5 to-transparent animate-shimmer" style={{ backgroundSize: '200% 100%' }} />
    <div className="flex gap-4">
      <div className="w-12 h-12 bg-gray-800 rounded-2xl" />
      <div className="flex-1 space-y-3">
        <div className="h-6 bg-gray-800 rounded w-3/4" />
        <div className="flex gap-2">
          <div className="h-4 bg-gray-800 rounded w-20" />
          <div className="h-4 bg-gray-800 rounded w-24" />
        </div>
      </div>
    </div>
  </div>
);

export default function JobsPage() {
  const { user } = useAuth();
  
  // Data State
  const [allJobs, setAllJobs] = useState<MatchedJob[]>([]);
  const [loading, setLoading] = useState(true);
  const [negativeFilters, setNegativeFilters] = useState<string[]>([]);
  const [profileLoaded, setProfileLoaded] = useState(false);

  // Pagination State
  const [page, setPage] = useState(1);
  // Comparison State
  const [compareList, setCompareList] = useState<string[]>([]);

  // --- JOBS PER PAGE ---
  const JOBS_PER_PAGE = 50;

  // UI State
  const [searchTerm, setSearchTerm] = useState('');
  
  // Filter States
  const [salaryFilter, setSalaryFilter] = useState<string>('all');
  const [companyFilter, setCompanyFilter] = useState<string>('all');
  const [remoteFilter, setRemoteFilter] = useState<string>('all');
  const [matchScoreFilter, setMatchScoreFilter] = useState<string>('all');
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [sortBy, setSortBy] = useState<string>('match'); // 'match' | 'latest' | 'company'

  // --- Helper: Chunk Array ---
  const chunkArray = <T,>(array: T[], size: number): T[][] => {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  };

  // --- Spotlight Effect Handler ---
  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    e.currentTarget.style.setProperty("--mouse-x", `${x}px`);
    e.currentTarget.style.setProperty("--mouse-y", `${y}px`);
  };

  // --- Helper: Robust Date Parsing (Same as Dashboard) ---
  const getJobDate = (postedAt: any) => {
    if (!postedAt) return new Date(); // Fallback to now
    if (postedAt.toDate) return postedAt.toDate(); // Firestore Timestamp
    if (postedAt.seconds) return new Date(postedAt.seconds * 1000); // Seconds timestamp
    if (typeof postedAt === 'string') return new Date(postedAt); // String format
    return new Date(); // Fallback
  };

  // --- Comparison Handler ---
  const toggleCompare = (e: React.MouseEvent, jobId: string) => {
    e.preventDefault(); // Prevent navigating to job details
    e.stopPropagation();
    
    setCompareList(prev => {
      if (prev.includes(jobId)) {
        return prev.filter(id => id !== jobId);
      }
      if (prev.length >= 4) {
        // Optional: limit to 4 items
        alert("You can compare up to 4 jobs at a time.");
        return prev;
      }
      return [...prev, jobId];
    });
  };

  // --- 1. Fetch User Profile ---
  useEffect(() => {
    const fetchUserProfile = async () => {
      if (user) {
        try {
          const userDoc = await getDoc(doc(db, 'users', user.uid));
          if (userDoc.exists()) {
            const userData = userDoc.data();
            const allExclusions = Array.from(new Set([
              ...(userData.excludedKeywords || []), 
              ...(userData.excludeKeywords || []),
              ...(userData.negativeFilters || [])
            ]));
            setNegativeFilters(allExclusions);
          }
        } catch (error) {
          console.error("Error fetching user profile:", error);
        } finally {
          setProfileLoaded(true);
        }
      }
    };
    fetchUserProfile();
  }, [user]);

  // --- 2. Main Fetch â€” loads ALL matched jobs once, client-side pagination after ---
  const fetchAllMatchedJobs = useCallback(async () => {
    if (!user) return;
    setLoading(true);

    try {
      // Fetch ALL matches for this user â€” no limit, so sort/filter works across everything
      const matchesQuery = query(
        collection(db, 'user_job_matches'),
        where('userId', '==', user.uid),
        orderBy('matchScore', 'desc'),
        orderBy('notifiedAt', 'desc')
      );

      const matchesSnapshot = await getDocs(matchesQuery);

      if (matchesSnapshot.empty) {
        setAllJobs([]);
        setLoading(false);
        return;
      }

      const matchesData: FirestoreMatchData[] = matchesSnapshot.docs.map(doc => {
        const data = doc.data();
        return { matchId: doc.id, jobId: data.jobId, ...data } as FirestoreMatchData;
      });

      const jobIds = matchesData.map(m => m.jobId).filter(Boolean);
      if (jobIds.length === 0) { setAllJobs([]); setLoading(false); return; }

      // Firestore 'in' queries are limited to 10 per chunk â€” batch them all
      const jobChunks = chunkArray(jobIds, 10);
      const jobsSnapshots = await Promise.all(
        jobChunks.map(chunk =>
          getDocs(query(collection(db, 'jobs'), where(documentId(), 'in', chunk)))
        )
      );

      const allJobDocs = jobsSnapshots.flatMap(snap => snap.docs);

      const matchedJobs: MatchedJob[] = allJobDocs.map(jobDoc => {
        const jobData = jobDoc.data();
        const match = matchesData.find(m => m.jobId === jobDoc.id);
        return {
          ...jobData,
          id: jobDoc.id,
          title: jobData.title,
          company: jobData.company,
          location: jobData.location,
          type: jobData.type,
          salary: jobData.salary,
          postedAt: jobData.postedAt,
          tags: jobData.tags,
          url: jobData.url,
          description: jobData.description,
          requirements: jobData.requirements,
          source: jobData.source,
          matchScore: match?.matchScore || 0,
          matchReasons: match?.matchReasons || [],
          matchedKeywords: match?.matchedKeywords || [],
          notifiedAt: match?.notifiedAt,
          viewed: match?.viewed || false
        } as MatchedJob;
      });

      // Default order: best match score descending
      matchedJobs.sort((a, b) => (b.matchScore || 0) - (a.matchScore || 0));
      setAllJobs(matchedJobs);

    } catch (error) {
      console.error('Error fetching jobs:', error);
    } finally {
      setLoading(false);
    }
  }, [user]);

  useEffect(() => {
    if (user && allJobs.length === 0) fetchAllMatchedJobs();
  }, [user]);

  // --- Client-side page handlers (instant â€” no Firestore calls) ---
  const handleNextPage = () => {
    setPage(prev => prev + 1);
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };
  const handlePrevPage = () => {
    setPage(prev => Math.max(1, prev - 1));
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  const addTestJob = async () => {
    try {
      await addDoc(collection(db, 'jobs'), {
        title: "Senior AI Engineer",
        company: "TechFlow AI",
        location: "San Francisco, CA (Remote)",
        type: "Full-time",
        salary: "$160k - $220k",
        tags: ["Python", "TensorFlow", "React"],
        postedAt: serverTimestamp(),
      });
      fetchAllMatchedJobs();
    } catch (error) {
      console.error("Error adding job:", error);
    }
  };

  // Unique companies derived from ALL jobs â€” not just current page
  const uniqueCompanies = Array.from(new Set(allJobs.map(job => job.company).filter(Boolean))).sort();

  // --- Filter + Sort across ALL jobs, then paginate client-side ---
  const filteredJobs = allJobs.filter(job => {
    // FIX 1: Add safety check for job ID
    if (!job.id) return false;

    if (!profileLoaded && negativeFilters.length === 0) return false;
    
    // Robust Time Calculations
    const jobDate = getJobDate(job.postedAt);

    // Debugging (Remove in prod)
    if (statusFilter === 'today' || statusFilter === 'week') {
      console.log(`Checking Job: ${job.title}`, {
         jobDate: jobDate.toLocaleString(),
         isToday: isToday(jobDate),
         isThisWeek: isThisWeek(jobDate)
      });
    }

    // 1. Negative Filter
    if (negativeFilters.length > 0) {
      const titleLower = job.title.toLowerCase();
      const tagsLower = job.tags?.map(t => t.toLowerCase()) || [];
      const hasNegative = negativeFilters.some(term => {
        const t = term.toLowerCase().trim();
        return t && (titleLower.includes(t) || tagsLower.some(tag => tag.includes(t)));
      });
      if (hasNegative) return false; 
    }

    // 2. Search
    const matchesSearch = searchTerm === '' || 
      job.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
      job.company.toLowerCase().includes(searchTerm.toLowerCase());

    // 3. Company Filter
    const matchesCompany = companyFilter === 'all' || job.company === companyFilter;

    // 4. Status Filter (Fixed with isToday/isThisWeek)
    const matchesStatus = statusFilter === 'all' || 
      (statusFilter === 'new' && !job.viewed) ||
      (statusFilter === 'today' && isToday(jobDate)) ||
      (statusFilter === 'week' && isThisWeek(jobDate));

    // 5. Remote/Location
    const jobLocation = (job.location || '').toLowerCase();
    const matchesRemote = remoteFilter === 'all' || 
      (remoteFilter === 'remote' && jobLocation.includes('remote')) ||
      (remoteFilter === 'hybrid' && jobLocation.includes('hybrid')) ||
      (remoteFilter === 'onsite' && !jobLocation.includes('remote') && !jobLocation.includes('hybrid'));

    // 6. Salary
    let matchesSalary = true;
    if (salaryFilter !== 'all' && job.salary) {
      const numbers = job.salary.match(/\d+/g);
      if (numbers?.[0]) {
        const jobNum = parseInt(numbers[0]);
        const filterNum = parseInt(salaryFilter.replace('k', ''));
        const normalized = (jobNum > 1000 && jobNum < 1000000) ? jobNum / 1000 : jobNum;
        matchesSalary = normalized >= filterNum;
      }
    }

    // 7. Score
    let matchesScore = true;
    if (matchScoreFilter !== 'all') {
      matchesScore = (job.matchScore || 0) >= parseInt(matchScoreFilter);
    }

    return matchesSearch && matchesCompany && matchesStatus && matchesRemote && matchesSalary && matchesScore;
  }).sort((a, b) => {
    if (sortBy === 'latest') {
      return getJobDate(b.postedAt).getTime() - getJobDate(a.postedAt).getTime();
    }
    if (sortBy === 'company') {
      return (a.company || '').localeCompare(b.company || '');
    }
    // Default: best match score
    return (b.matchScore || 0) - (a.matchScore || 0);
  });

  // Client-side pagination slice
  const totalPages = Math.ceil(filteredJobs.length / JOBS_PER_PAGE);
  const hasMore = page < totalPages;
  const paginatedJobs = filteredJobs.slice((page - 1) * JOBS_PER_PAGE, page * JOBS_PER_PAGE);

  // Reset to page 1 whenever filters/sort change
  // (handled via useEffect below)

  const getTierColor = (score: number) => {
    if (score >= 95) return 'text-yellow-400';
    if (score >= 85) return 'text-green-400';
    if (score >= 75) return 'text-blue-400';
    return 'text-gray-400';
  };

  const clearAllFilters = () => {
    setSearchTerm('');
    setSalaryFilter('all');
    setCompanyFilter('all');
    setRemoteFilter('all');
    setMatchScoreFilter('all');
    setStatusFilter('all');
    setSortBy('match');
    setPage(1);
  };

  // Reset to page 1 whenever any filter or sort changes
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => { setPage(1); }, [searchTerm, salaryFilter, companyFilter, remoteFilter, matchScoreFilter, statusFilter, sortBy]);

  return (
    <div className="min-h-screen bg-[#050505] text-white relative font-sans selection:bg-blue-500/30">
      
      {/* Background */}
      <div className="fixed inset-0 -z-10 pointer-events-none overflow-hidden">
        <div className="absolute top-[-10%] left-[-10%] w-[500px] h-[500px] bg-blue-600/10 rounded-full blur-[120px] animate-pulse" />
        <div className="absolute top-[20%] right-[-10%] w-[600px] h-[600px] bg-purple-600/10 rounded-full blur-[120px] animate-pulse animation-delay-2000" />
        <div className="absolute inset-0 opacity-[0.03]" style={{ backgroundImage: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E")` }} />
      </div>

      <div className="max-w-7xl mx-auto p-4 md:p-8 space-y-8">
        
        {/* Header */}
        <div className="flex flex-col md:flex-row justify-between items-start md:items-end gap-6 pb-6 border-b border-white/5">
          <div className="space-y-2">
            <div className="inline-flex items-center gap-2 px-3 py-1 rounded-full bg-blue-500/10 border border-blue-500/20 backdrop-blur-md">
              <span className="relative flex h-2 w-2">
                <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-blue-400 opacity-75"></span>
                <span className="relative inline-flex rounded-full h-2 w-2 bg-blue-500"></span>
              </span>
              <span className="text-xs font-semibold text-blue-300 tracking-wide">AI AGENT ACTIVE</span>
            </div>
            <h1 className="text-5xl font-black tracking-tighter text-white">
              Job<span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">Hunt</span>
            </h1>
            <p className="text-gray-400 max-w-lg text-lg">Your personal AI recruiter has analyzed the market and found these top matches.</p>
          </div>
          <div className="flex gap-3">
             <button 
                onClick={addTestJob}
                className="hidden sm:flex items-center gap-2 px-5 py-2.5 bg-gray-800/50 hover:bg-gray-800 border border-white/10 rounded-xl text-sm font-medium transition-all hover:scale-105"
              >
                <Plus className="w-4 h-4" /> Add Test
              </button>
            <Link href="/dashboard">
              <button className="group px-5 py-2.5 bg-white text-black hover:bg-gray-100 rounded-xl text-sm font-bold transition-all hover:scale-105 shadow-[0_0_20px_rgba(255,255,255,0.2)]">
                Dashboard <ArrowRight className="w-4 h-4 inline ml-1 group-hover:translate-x-1 transition-transform" />
              </button>
            </Link>
          </div>
        </div>

        {/* Sticky Glass Filter Bar */}
        <div className="sticky top-4 z-40 space-y-4">
          <div className="p-2 bg-gray-900/60 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl ring-1 ring-white/5">
            <div className="flex flex-col lg:flex-row gap-3">
              {/* Search */}
              <div className="flex-1 relative group">
                <div className="absolute inset-0 bg-gradient-to-r from-blue-500/20 to-purple-500/20 rounded-xl blur transition-opacity opacity-0 group-hover:opacity-100" />
                <div className="relative flex items-center bg-black/40 border border-white/10 rounded-xl h-12 px-4 focus-within:border-blue-500/50 transition-colors">
                  <Search className="w-5 h-5 text-gray-500 mr-3" />
                  <input 
                    type="text"
                    placeholder="Search roles, companies, or keywords..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="w-full bg-transparent border-none focus:outline-none text-white placeholder-gray-500 font-medium"
                  />
                </div>
              </div>

              {/* Quick Filters */}
              <div className="flex gap-2 overflow-x-auto pb-1 lg:pb-0 scrollbar-hide">
                {[
                  { 
                    icon: Sparkles, 
                    val: statusFilter, 
                    set: setStatusFilter, 
                    // UPDATED OPTIONS
                    opts: [['all', 'All Status'], ['new', 'âœ¨ New Matches Only'], ['today', 'ðŸ”¥ Posted Today'], ['week', 'ðŸ“… This Week']] 
                  },
                  { 
                    icon: Building2, 
                    val: companyFilter, 
                    set: setCompanyFilter, 
                    opts: [['all', 'All Companies'], ...uniqueCompanies.map(c => [c, c])] 
                  },
                  { 
                    icon: Target, 
                    val: matchScoreFilter, 
                    set: setMatchScoreFilter, 
                    opts: [['all','All Scores'], ['95','95%+ S-Tier'], ['85','85%+ A-Tier'], ['75','75%+ B-Tier']] 
                  },
                  { 
                    icon: DollarSign, 
                    val: salaryFilter, 
                    set: setSalaryFilter, 
                    opts: [['all','Any Salary'], ['100k','$100k+'], ['150k','$150k+'], ['200k','$200k+']] 
                  },
                  { 
                    icon: MapPin, 
                    val: remoteFilter, 
                    set: setRemoteFilter, 
                    opts: [['all','Any Location'], ['remote','Remote'], ['hybrid','Hybrid'], ['onsite','On-site']] 
                  },
                ].map((f, i) => (
                  <div key={i} className="relative min-w-[160px]">
                    <div className="absolute left-3 top-1/2 -translate-y-1/2 pointer-events-none text-gray-400">
                      <f.icon className="w-4 h-4" />
                    </div>
                    <select 
                      value={f.val}
                      onChange={(e) => f.set(e.target.value)}
                      className="w-full appearance-none bg-black/40 hover:bg-white/5 border border-white/10 rounded-xl h-12 pl-10 pr-8 text-sm font-medium text-gray-300 focus:outline-none focus:border-blue-500/50 transition-colors cursor-pointer"
                    >
                      {f.opts.map(([v, l]) => <option key={String(v)} value={String(v)} className="bg-gray-900">{l}</option>)}
                    </select>
                  </div>
                ))}

                {/* Sort By */}
                <div className="relative min-w-[160px]">
                  <div className="absolute left-3 top-1/2 -translate-y-1/2 pointer-events-none text-gray-400">
                    <Zap className="w-4 h-4" />
                  </div>
                  <select
                    value={sortBy}
                    onChange={(e) => setSortBy(e.target.value)}
                    className="w-full appearance-none bg-blue-500/10 hover:bg-blue-500/20 border border-blue-500/30 rounded-xl h-12 pl-10 pr-8 text-sm font-medium text-blue-300 focus:outline-none focus:border-blue-500/60 transition-colors cursor-pointer"
                  >
                    <option value="match" className="bg-gray-900 text-white">âš¡ Best Match</option>
                    <option value="latest" className="bg-gray-900 text-white">ðŸ• Latest Posted</option>
                    <option value="company" className="bg-gray-900 text-white">ðŸ¢ Company Aâ€“Z</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Content Area */}
        <div className="min-h-[400px]">
          {loading || !profileLoaded ? (
            <div className="grid grid-cols-1 gap-4">
              {[1, 2, 3].map((i) => <JobCardSkeleton key={i} />)}
            </div>
          ) : filteredJobs.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-20 bg-gray-900/20 border border-dashed border-gray-800 rounded-3xl">
              <div className="w-20 h-20 bg-gray-800/50 rounded-full flex items-center justify-center mb-4 animate-bounce">
                <Filter className="w-8 h-8 text-gray-500" />
              </div>
              <h3 className="text-2xl font-bold text-white mb-2">No matches found</h3>
              <p className="text-gray-500 mb-6 text-center max-w-md">
                {statusFilter === 'new' 
                  ? "You're all caught up! No new matches found." 
                  : "We couldn't find jobs matching those exact filters."}
              </p>
              <button onClick={clearAllFilters} className="px-6 py-2 bg-white text-black rounded-lg font-bold hover:bg-gray-200 transition-colors">
                Reset Filters
              </button>
            </div>
          ) : (
            <div className="space-y-4">
              <div className="flex flex-col sm:flex-row items-center justify-between px-2 gap-4">
                <div className="flex items-center gap-4 flex-wrap">
                  <p className="text-gray-400 text-sm font-medium">
                    Found <span className="text-white">{filteredJobs.length}</span> matches
                    {totalPages > 1 && (
                      <span className="text-gray-600 ml-2 text-xs">Â· page {page} of {totalPages}</span>
                    )}
                  </p>
                  {statusFilter === 'new' && (
                    <span className="px-3 py-1 bg-blue-500/20 text-blue-300 text-xs font-bold rounded-full border border-blue-500/30">
                      Showing New Matches Only
                    </span>
                  )}
                  {/* Active Sort Badge */}
                  <span className="px-3 py-1 bg-white/5 text-gray-400 text-xs font-semibold rounded-full border border-white/10 flex items-center gap-1.5">
                    {sortBy === 'latest' && <><Clock className="w-3 h-3 text-amber-400" /> Sorted: Latest Posted</>}
                    {sortBy === 'company' && <><Building2 className="w-3 h-3 text-blue-400" /> Sorted: Company Aâ€“Z</>}
                    {sortBy === 'match' && <><Zap className="w-3 h-3 text-purple-400" /> Sorted: Best Match</>}
                  </span>
                  {/* Active Company Filter Badge */}
                  {companyFilter !== 'all' && (
                    <button
                      onClick={() => setCompanyFilter('all')}
                      className="px-3 py-1 bg-blue-500/15 text-blue-300 text-xs font-bold rounded-full border border-blue-500/30 flex items-center gap-1.5 hover:bg-blue-500/25 transition-colors"
                    >
                      <Building2 className="w-3 h-3" /> {companyFilter} <X className="w-3 h-3" />
                    </button>
                  )}
                </div>

                {/* --- TOP PAGINATION --- */}
                <div className="flex items-center gap-3">
                  <button onClick={handlePrevPage} disabled={page <= 1 || loading} className="px-3 py-1.5 bg-gray-900 border border-gray-800 rounded-lg text-xs font-bold disabled:opacity-30 hover:bg-gray-800 transition-colors">Prev</button>
                  <div className="text-gray-500 font-mono text-xs">Page <span className="text-white">{page}</span></div>
                  <button onClick={handleNextPage} disabled={!hasMore || loading} className="px-3 py-1.5 bg-white text-black hover:bg-gray-200 rounded-lg text-xs font-bold disabled:opacity-30 transition-colors">Next</button>
                </div>
              </div>

              {/* Company Quick-Filter Pills (visible when there are companies to show) */}
              {uniqueCompanies.length > 0 && uniqueCompanies.length <= 20 && (
                <div className="flex flex-wrap gap-2 px-2 pb-1">
                  <button
                    onClick={() => setCompanyFilter('all')}
                    className={`px-3 py-1 rounded-full text-xs font-semibold border transition-all ${
                      companyFilter === 'all'
                        ? 'bg-white text-black border-white'
                        : 'bg-white/5 text-gray-400 border-white/10 hover:bg-white/10 hover:text-white'
                    }`}
                  >
                    All
                  </button>
                  {uniqueCompanies.map(company => (
                    <button
                      key={company}
                      onClick={() => setCompanyFilter(companyFilter === company ? 'all' : company)}
                      className={`px-3 py-1 rounded-full text-xs font-semibold border transition-all ${
                        companyFilter === company
                          ? 'bg-blue-600 text-white border-blue-500 shadow-lg shadow-blue-500/20'
                          : 'bg-white/5 text-gray-400 border-white/10 hover:bg-white/10 hover:text-white'
                      }`}
                    >
                      {company}
                    </button>
                  ))}
                </div>
              )}

              {/* Holographic Job Cards */}
              <div className="grid grid-cols-1 gap-5">
                {paginatedJobs.map((job) => (
                  // FIX 2: Added prefetch={false}
                  <Link key={job.id} href={`/jobs/${job.id}`} prefetch={false}>
                    <div 
                      onMouseMove={handleMouseMove}
                      className="group relative rounded-3xl p-[1px] overflow-hidden cursor-pointer transition-transform hover:scale-[1.01] active:scale-[0.99]"
                    >
                      {/* Spotlight Effect */}
                      <div className="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300"
                        style={{
                          background: `radial-gradient(600px circle at var(--mouse-x) var(--mouse-y), rgba(59, 130, 246, 0.4), transparent 40%)`
                        }}
                      />
                      
                      <div className="relative h-full bg-[#0F0F10] rounded-[23px] p-6 border border-white/5 overflow-hidden">
                        <div className="absolute top-0 right-0 w-64 h-64 bg-blue-500/5 rounded-full blur-[80px] group-hover:bg-blue-500/10 transition-colors" />

                        <div className="relative flex flex-col md:flex-row gap-6">
                          {/* Score Visual */}
                          <div className="shrink-0 flex flex-col items-center gap-2">
                            <CircularProgress score={job.matchScore || 0} color={getTierColor(job.matchScore || 0)} />
                            <div className="px-2 py-0.5 rounded-md bg-gray-800 border border-gray-700 text-[10px] font-bold text-gray-300 uppercase tracking-wider">
                              Match
                            </div>
                          </div>

                          {/* Info */}
                          <div className="flex-1 min-w-0">
                            <div className="flex items-start justify-between">
                              <div>
                                <h3 className="text-xl md:text-2xl font-bold text-white mb-1 group-hover:text-blue-400 transition-colors truncate">
                                  {job.title}
                                </h3>
                                <div className="flex items-center gap-2 text-gray-400 text-sm mb-4">
                                  <span className="font-semibold text-white flex items-center gap-1">
                                    <Briefcase className="w-3 h-3" /> {job.company}
                                  </span>
                                  <span>â€¢</span>
                                  <span className="flex items-center gap-1">
                                    <MapPin className="w-3 h-3" /> {job.location || 'Remote'}
                                  </span>
                                  <span>â€¢</span>
                                  <span className="text-gray-500 flex items-center gap-1">
                                    <Clock className="w-3 h-3" /> 
                                    {/* Robust display date */}
                                    {formatDistanceToNow(getJobDate(job.postedAt), { addSuffix: true })}
                                  </span>
                                </div>
                              </div>
                            </div>

                            {/* Tags */}
                            <div className="flex flex-wrap gap-2 items-center">
                              {job.salary && (
                                <span className="px-3 py-1 bg-green-500/10 text-green-400 border border-green-500/20 rounded-lg text-xs font-bold flex items-center gap-1">
                                  <DollarSign className="w-3 h-3" /> {job.salary}
                                </span>
                              )}

                              {/* NEW: Robust Freshness Badge */}
                              {isToday(getJobDate(job.postedAt)) && (
                                <span className="px-2 py-1 bg-amber-500/10 text-amber-400 border border-amber-500/20 rounded-lg text-[10px] font-bold uppercase tracking-wider flex items-center gap-1 animate-pulse">
                                  ðŸ”¥ Fresh
                                </span>
                              )}

                              {job.tags?.slice(0, 4).map((tag, idx) => (
                                <span key={idx} className="px-2.5 py-1 bg-white/5 hover:bg-white/10 text-gray-300 border border-white/5 rounded-lg text-xs transition-colors">
                                  {tag}
                                </span>
                              ))}
                              {!job.viewed && (
                                <span className="ml-auto px-2 py-1 bg-blue-600 text-white text-[10px] font-bold uppercase tracking-wider rounded-md animate-pulse">
                                  New
                                </span>
                              )}
                            </div>
                          </div>

                          {/* CTA (Updated with Compare Button) */}
                          <div className="flex items-end justify-end md:justify-center md:flex-col md:items-center md:border-l border-white/5 md:pl-6 gap-2">
                             
                             {/* COMPARE BUTTON */}
                             <button
                               onClick={(e) => toggleCompare(e, job.id)}
                               className={`mt-2 md:mt-0 mb-0 md:mb-3 px-3 py-1.5 rounded-lg text-xs font-bold flex items-center gap-2 transition-all z-20 relative ${
                                 compareList.includes(job.id)
                                   ? 'bg-blue-600 text-white shadow-lg shadow-blue-500/30'
                                   : 'bg-white/5 hover:bg-white/10 text-gray-400 border border-white/5'
                               }`}
                             >
                               <Scale className="w-3 h-3" />
                               {compareList.includes(job.id) ? 'Remove' : 'Compare'}
                             </button>

                             <div className="flex items-center text-sm font-bold text-blue-400 group-hover:translate-x-1 transition-transform">
                               View <ArrowRight className="w-4 h-4 ml-1" />
                             </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </Link>
                ))}
              </div>

              {/* Bottom Pagination */}
              <div className="flex items-center justify-center pt-8 pb-12 gap-4">
                <button onClick={handlePrevPage} disabled={page <= 1 || loading} className="px-6 py-3 bg-gray-900 border border-gray-800 rounded-xl text-sm font-bold disabled:opacity-30">Previous</button>
                <div className="px-4 text-gray-500 font-mono text-sm">Page <span className="text-white">{page}</span></div>
                <button onClick={handleNextPage} disabled={!hasMore || loading} className="px-6 py-3 bg-white text-black hover:bg-gray-200 rounded-xl text-sm font-bold disabled:opacity-30">Next Page</button>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* FLOATING ACTION BUTTON FOR COMPARISON */}
      {compareList.length >= 2 && (
        <div className="fixed bottom-8 right-8 z-50 animate-in fade-in slide-in-from-bottom-4 duration-300">
          <Link href={`/compare?jobs=${compareList.join(',')}`}>
            <button className="flex items-center gap-2 px-6 py-4 bg-gradient-to-r from-blue-600 to-purple-600 rounded-2xl font-bold text-white shadow-[0_0_30px_rgba(59,130,246,0.5)] hover:scale-105 transition-transform">
              <Scale className="w-5 h-5" />
              Compare {compareList.length} Jobs
            </button>
          </Link>
        </div>
      )}
      
      <style jsx global>{`
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        .animate-shimmer { animation: shimmer 2s infinite; }
        .animation-delay-2000 { animation-delay: 2s; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
      `}</style>
    </div>
  );
}
===== ./src/app/layout.tsx =====
import './globals.css';
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { Toaster } from '@/components/ui/toaster';
import { AuthProvider } from '@/contexts/AuthContext';
import { Navigation } from '@/components/Navigation';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'JobHunt AI - AI-Powered Job Search for Tech Professionals',
  description: 'Find your dream tech job with AI-powered matching, instant alerts, and personalized application assistance. Track 500+ top companies.',
  keywords: [
    'tech jobs',
    'job search',
    'AI job matching',
    'software engineer jobs',
    'machine learning jobs',
    'startup jobs',
    'remote jobs',
    'tech careers'
  ].join(', '),
  authors: [{ name: 'JobHunt AI' }],
  openGraph: {
    title: 'JobHunt AI - AI-Powered Job Search',
    description: 'Find your dream tech job with AI-powered matching and instant alerts',
    url: 'https://jobhunt.ai',
    siteName: 'JobHunt AI',
    images: [
      {
        url: '/og-image.png',
        width: 1200,
        height: 630,
        alt: 'JobHunt AI Platform',
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'JobHunt AI - AI-Powered Job Search',
    description: 'Find your dream tech job with AI-powered matching',
    images: ['/og-image.png'],
    creator: '@jobhuntai',
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
  verification: {
    google: 'your-google-verification-code',
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <link rel="icon" href="/favicon.ico" />
        <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
        <meta name="theme-color" content="#000000" />
      </head>
      <body className={inter.className}>
        {/* AuthProvider must wrap the entire application to share user state */}
        <AuthProvider>
          <div className="min-h-screen">
            <Navigation />
            <main>
              {children}
            </main>
          </div>
          <Toaster />
        </AuthProvider>

        {/* Analytics - Only loaded in production */}
        {process.env.NODE_ENV === 'production' && (
          <script
            defer
            data-domain="jobhunt.ai"
            src="https://plausible.io/js/script.js"
          />
        )}
      </body>
    </html>
  );
}
===== ./src/app/login/page.tsx =====
import { redirect } from 'next/navigation';

export default function LoginPage() {
  redirect('/auth/signin');
}
===== ./src/app/onboarding/page.tsx =====
"use client";

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/contexts/AuthContext';
import { doc, getDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase';

export default function OnboardingPage() {
  const { user } = useAuth();
  const router = useRouter();

  useEffect(() => {
    async function checkOnboarding() {
      if (!user) {
        router.push('/auth/signin');
        return;
      }

      try {
        const userDoc = await getDoc(doc(db, 'users', user.uid));
        const userData = userDoc.data();
        
        // Check if user has completed preferences (example check)
        const hasPreferences = userData?.searchKeywords && userData.searchKeywords.length > 0;

        if (hasPreferences) {
          router.push('/dashboard');
        } else {
          router.push('/settings/preferences');
        }
      } catch (error) {
        console.error("Error checking onboarding status:", error);
        // Fallback to dashboard if error
        router.push('/dashboard');
      }
    }

    checkOnboarding();
  }, [user, router]);

  return (
    <div className="flex items-center justify-center min-h-screen bg-black">
      <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-600"></div>
    </div>
  );
}
===== ./src/app/page.tsx =====
import Link from 'next/link';
import { adminDb } from '@/lib/firebase-admin'; 
import { Button } from '@/components/ui/button';
import SpotlightCard from '@/components/SpotlightCard'; 
import { 
  ArrowRight, FileText, Shield, Zap, Globe, TrendingUp
} from 'lucide-react';

export const revalidate = 0;

// --- REAL DATA FETCHING ---
async function getStats() {
  try {
    const usersSnapshot = await adminDb.collection('users').count().get();
    const userCount = usersSnapshot.data().count;

    const jobsSnapshot = await adminDb.collection('jobs').count().get();
    const jobCount = jobsSnapshot.data().count;

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const newJobsSnapshot = await adminDb
      .collection('jobs')
      .where('createdAt', '>=', today) 
      .count()
      .get();
    const newJobsToday = newJobsSnapshot.data().count;

    const estimatedCompanies = Math.floor(jobCount / 3) > 500 ? Math.floor(jobCount / 3) : "500+";

    return {
      userCount: userCount.toLocaleString(),
      jobCount: jobCount.toLocaleString(),
      companyCount: estimatedCompanies.toLocaleString(),
      newJobsToday: newJobsToday || 0,
      matchRate: "98%",
    };
  } catch (error) {
    console.error("Error fetching stats:", error);
    return {
      userCount: "2,042", 
      jobCount: "12,450",
      companyCount: "500+",
      newJobsToday: 142,
      matchRate: "98%"
    };
  }
}

export default async function Home() {
  const stats = await getStats();

  return (
    <main className="min-h-screen bg-black text-white p-4 md:p-6 font-sans selection:bg-purple-500/30 relative overflow-hidden">
      
      {/* Noise Texture Overlay */}
      <div className="fixed inset-0 opacity-[0.03] pointer-events-none z-50 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] mix-blend-overlay"></div>

      {/* spacer to push content down because Navbar is now 'fixed' at top */}
      <div className="h-24 md:h-32"></div>

      {/* THE 10x BENTO GRID */}
      <div className="max-w-[1600px] mx-auto grid grid-cols-1 md:grid-cols-4 lg:grid-cols-6 lg:grid-rows-3 gap-6 h-auto lg:h-[800px] relative z-0">
        
        {/* BLOCK A: Hero Title (Span 4 cols, 2 rows) */}
        <SpotlightCard className="col-span-1 md:col-span-4 lg:col-span-4 lg:row-span-2 bg-gradient-to-br from-gray-900/50 to-black/50">
            <div className="p-8 md:p-12 h-full flex flex-col justify-between relative z-10">
                <div className="absolute top-0 right-0 w-[600px] h-[600px] bg-purple-600/10 rounded-full blur-[120px] -translate-y-1/2 translate-x-1/2 pointer-events-none" />
                
                <div>
                  <div className="inline-flex items-center gap-2 px-3 py-1 rounded-full bg-white/5 border border-white/10 backdrop-blur-md mb-8 hover:bg-white/10 transition-colors cursor-default">
                      <span className="relative flex h-2 w-2">
                        <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                        <span className="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                      </span>
                      <span className="text-xs font-medium text-green-400 tracking-wide uppercase">Live: {stats.newJobsToday} New Jobs Today</span>
                  </div>
                  
                  <h1 className="text-5xl md:text-7xl font-bold tracking-tight leading-[1.1] mb-6">
                      Find your dream job <br />
                      <span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-purple-400 to-pink-400 animate-gradient">
                          without the chaos.
                      </span>
                  </h1>
                  
                  <p className="text-xl text-gray-400 mb-8 max-w-lg leading-relaxed">
                      Our AI analyzes thousands of listings to find the 1% that match your skills, values, and salary goals.
                  </p>
                </div>

                <div className="flex flex-wrap gap-6 items-center">
                    <Link href="/signup">
                        <Button className="h-16 px-10 rounded-full text-lg bg-white text-black hover:bg-gray-100 transition-all hover:scale-105 shadow-[0_0_40px_-10px_rgba(255,255,255,0.3)]">
                            Start Searching Free
                            <ArrowRight className="ml-2 h-5 w-5" />
                        </Button>
                    </Link>
                    <div className="flex items-center gap-4 text-sm text-gray-500">
                        <div className="flex -space-x-3">
                             {[1,2,3].map(i => <div key={i} className="w-10 h-10 rounded-full border-4 border-black bg-gray-800" />)}
                        </div>
                        <p>{stats.userCount} users joined</p>
                    </div>
                </div>
            </div>
        </SpotlightCard>

        {/* BLOCK B: Stats "Ticker" */}
        <div className="col-span-1 md:col-span-2 lg:col-span-2 lg:row-span-2 flex flex-col gap-6">
            <SpotlightCard className="flex-1 flex flex-col justify-center items-center text-center group">
                <div className="p-8">
                  <h3 className="text-7xl font-black text-transparent bg-clip-text bg-gradient-to-b from-white to-white/40 mb-2 group-hover:from-blue-400 group-hover:to-purple-400 transition-all duration-500">{stats.matchRate}</h3>
                  <p className="text-sm font-medium text-gray-400 uppercase tracking-widest">Match Accuracy</p>
                </div>
            </SpotlightCard>

            <SpotlightCard className="flex-1 flex flex-col justify-center items-center text-center group">
                <div className="p-8">
                  <h3 className="text-7xl font-black text-transparent bg-clip-text bg-gradient-to-b from-white to-white/40 mb-2 group-hover:from-pink-400 group-hover:to-orange-400 transition-all duration-500">{stats.jobCount}</h3>
                  <p className="text-sm font-medium text-gray-400 uppercase tracking-widest">Active Listings</p>
                </div>
            </SpotlightCard>
        </div>

        {/* BLOCK C: Feature Cards */}
        <SpotlightCard className="col-span-1 md:col-span-2 lg:col-span-2 lg:row-span-1 cursor-pointer">
            <div className="p-8 flex flex-col justify-between h-full">
              <div className="h-12 w-12 bg-purple-500/10 rounded-full flex items-center justify-center mb-4 border border-purple-500/20">
                  <FileText className="h-6 w-6 text-purple-400" />
              </div>
              <div>
                  <h4 className="text-xl font-bold mb-2">Resume Optimizer</h4>
                  <p className="text-sm text-gray-400">AI re-writes your resume for every application.</p>
              </div>
            </div>
        </SpotlightCard>

        <SpotlightCard className="col-span-1 md:col-span-2 lg:col-span-2 lg:row-span-1 cursor-pointer">
            <div className="p-8 flex flex-col justify-between h-full">
              <div className="h-12 w-12 bg-blue-500/10 rounded-full flex items-center justify-center mb-4 border border-blue-500/20">
                  <Zap className="h-6 w-6 text-blue-400" />
              </div>
              <div>
                  <h4 className="text-xl font-bold mb-2">10x Faster Applying</h4>
                  <p className="text-sm text-gray-400">Auto-fill applications in seconds, not hours.</p>
              </div>
            </div>
        </SpotlightCard>

        <SpotlightCard className="col-span-1 md:col-span-2 lg:col-span-2 lg:row-span-1 bg-gradient-to-br from-[#0F0F0F] to-[#050505]">
             <div className="p-8 flex flex-col justify-between h-full relative z-10">
                <div className="flex items-center justify-between mb-4">
                    <h4 className="text-lg font-bold">Top Companies</h4>
                    <span className="text-xs bg-white/10 px-2 py-1 rounded text-gray-300 border border-white/5">{stats.companyCount} tracked</span>
                </div>
                <div className="flex flex-wrap gap-2">
                    {['Google', 'Meta', 'Netflix', 'Airbnb'].map((co) => (
                        <span key={co} className="text-xs font-medium px-3 py-1.5 rounded-lg border border-white/5 bg-white/5 text-gray-300 hover:bg-white/10 transition-colors cursor-default">
                            {co}
                        </span>
                    ))}
                </div>
            </div>
        </SpotlightCard>

      </div>
      
      {/* Footer */}
      <div className="max-w-[1600px] mx-auto mt-12 flex flex-col md:flex-row justify-between items-center text-sm text-gray-600 px-4 pb-8 relative z-10">
        <p>Â© 2026 JobHunt AI Inc.</p>
        <div className="flex gap-8 mt-4 md:mt-0">
            <span className="flex items-center gap-2 hover:text-gray-400 transition-colors cursor-pointer"><Shield className="h-4 w-4" /> Secure Data</span>
            <span className="flex items-center gap-2 hover:text-gray-400 transition-colors cursor-pointer"><Globe className="h-4 w-4" /> Global Search</span>
            <span className="flex items-center gap-2 hover:text-gray-400 transition-colors cursor-pointer"><TrendingUp className="h-4 w-4" /> Real-time Updates</span>
        </div>
      </div>
    </main>
  );
}
===== ./src/app/pricing/page.tsx =====
"use client"; // <--- This is important for buttons to work!

import React, { useState } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { Check, X, ArrowLeft, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';

export default function PricingPage() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const handleUpgrade = async () => {
    setLoading(true);
    
    // Simulate API call to Stripe
    await new Promise(resolve => setTimeout(resolve, 2000));

    // In a real app, this is where you'd redirect to the Stripe Checkout URL
    alert("ðŸŽ‰ Upgrade Successful! (This is a demo)");
    
    setLoading(false);
    router.push('/dashboard');
  };

  return (
    <div className="min-h-screen bg-slate-50 py-12 px-4 sm:px-6 lg:px-8">
      {/* Back Button */}
      <div className="max-w-7xl mx-auto mb-8">
        <Link href="/dashboard" className="inline-flex items-center text-slate-600 hover:text-slate-900 transition-colors">
          <ArrowLeft className="w-4 h-4 mr-2" />
          Back to Dashboard
        </Link>
      </div>

      <div className="text-center mb-16">
        <h1 className="text-4xl font-bold text-slate-900 mb-4">Simple, transparent pricing</h1>
        <p className="text-xl text-slate-600">Choose the plan that's right for your career goals</p>
      </div>

      <div className="max-w-5xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-8">
        {/* Free Plan */}
        <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-8 flex flex-col">
          <div className="mb-8">
            <h3 className="text-xl font-semibold text-slate-900 mb-2">Free Starter</h3>
            <p className="text-slate-600 mb-6">Perfect for casual job seekers</p>
            <div className="flex items-baseline">
              <span className="text-5xl font-bold text-slate-900">$0</span>
              <span className="text-slate-600 ml-2">/month</span>
            </div>
          </div>

          <ul className="space-y-4 mb-8 flex-1">
            <FeatureItem text="5 Job Matches per day" included={true} />
            <FeatureItem text="Basic Match Score" included={true} />
            <FeatureItem text="Application Tracking" included={true} />
            <FeatureItem text="AI Cover Letter Generator" included={false} />
            <FeatureItem text="Priority Email Alerts" included={false} />
            <FeatureItem text="Resume Optimization" included={false} />
          </ul>

          <Button variant="outline" className="w-full py-6 text-lg" disabled>
            Current Plan
          </Button>
        </div>

        {/* Pro Plan */}
        <div className="bg-slate-900 rounded-2xl shadow-xl border border-slate-800 p-8 flex flex-col relative overflow-hidden">
          <div className="absolute top-0 right-0 bg-gradient-to-r from-blue-500 to-purple-600 text-white text-xs font-bold px-3 py-1 rounded-bl-lg">
            MOST POPULAR
          </div>

          <div className="mb-8">
            <h3 className="text-xl font-semibold text-white mb-2">Pro Career</h3>
            <p className="text-slate-400 mb-6">For serious job hunters who want results fast</p>
            <div className="flex items-baseline">
              <span className="text-5xl font-bold text-white">$49</span>
              <span className="text-slate-400 ml-2">/month</span>
            </div>
          </div>

          <ul className="space-y-4 mb-8 flex-1">
            <FeatureItem text="Unlimited Job Matches" included={true} dark />
            <FeatureItem text="Advanced AI Match Analysis" included={true} dark />
            <FeatureItem text="Unlimited Application Tracking" included={true} dark />
            <FeatureItem text="AI Cover Letter Generator" included={true} dark />
            <FeatureItem text="Instant Job Alerts" included={true} dark />
            <FeatureItem text="Resume Optimization" included={true} dark />
          </ul>

          <Button 
            onClick={handleUpgrade}
            disabled={loading}
            className="w-full py-6 text-lg bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 border-0 flex items-center justify-center gap-2"
          >
            {loading ? (
              <>
                <Loader2 className="w-5 h-5 animate-spin" />
                Processing...
              </>
            ) : (
              "Upgrade Now"
            )}
          </Button>
          <p className="text-center text-slate-500 text-sm mt-4">
            7-day money-back guarantee
          </p>
        </div>
      </div>
    </div>
  );
}

function FeatureItem({ text, included, dark }: { text: string; included: boolean; dark?: boolean }) {
  return (
    <li className="flex items-center">
      {included ? (
        <div className={`flex-shrink-0 w-5 h-5 rounded-full flex items-center justify-center mr-3 ${dark ? 'bg-green-500/20 text-green-400' : 'bg-green-100 text-green-600'}`}>
          <Check className="w-3 h-3" />
        </div>
      ) : (
        <div className="flex-shrink-0 w-5 h-5 rounded-full bg-slate-100 text-slate-400 flex items-center justify-center mr-3">
          <X className="w-3 h-3" />
        </div>
      )}
      <span className={dark ? 'text-slate-300' : included ? 'text-slate-700' : 'text-slate-400'}>
        {text}
      </span>
    </li>
  );
}
===== ./src/app/settings/auto-apply/page.tsx =====
"use client";

import React, { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { doc, setDoc, getDoc } from 'firebase/firestore';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { 
  Save, Plus, Trash2, Loader2, CheckCircle, Zap, 
  Briefcase, Globe, User, Settings, FileText, 
  Download, ArrowLeft, X, MessageSquare
} from 'lucide-react';
import Link from 'next/link';

// Interfaces
interface WorkExperience {
  company: string;
  title: string;
  startDate: string;
  endDate: string;
  current: boolean;
  description: string;
}

interface Education {
  school: string;
  degree: string;
  field: string;
  graduationYear: string;
}

interface CustomQuestion {
  keyword: string;
  answer: string;
}

export default function AutoApplySetupPage() {
  const { user } = useAuth();
  const [saving, setSaving] = useState(false);
  const [saved, setSaved] = useState(false);
  const [activeTab, setActiveTab] = useState("profile");

  // --- 1. Personal & Contact ---
  const [phone, setPhone] = useState('');
  const [location, setLocation] = useState('');
  const [linkedinUrl, setLinkedinUrl] = useState('');
  const [portfolioUrl, setPortfolioUrl] = useState('');
  const [githubUrl, setGithubUrl] = useState('');

  // --- 2. Professional Info ---
  const [currentTitle, setCurrentTitle] = useState('');
  const [yearsOfExperience, setYearsOfExperience] = useState('');
  const [skills, setSkills] = useState<string[]>([]);
  const [newSkill, setNewSkill] = useState('');

  // --- 3. Experience & Education ---
  const [workHistory, setWorkHistory] = useState<WorkExperience[]>([{
    company: '', title: '', startDate: '', endDate: '', current: false, description: ''
  }]);
  const [education, setEducation] = useState<Education[]>([{
    school: '', degree: '', field: '', graduationYear: ''
  }]);

  // --- 4. Job Preferences & Custom Q&A ---
  const [desiredSalary, setDesiredSalary] = useState('');
  const [workplaceType, setWorkplaceType] = useState('remote');
  const [relocation, setRelocation] = useState(false);
  
  // NEW: Custom Questions State
  const [customQuestions, setCustomQuestions] = useState<CustomQuestion[]>([
    { keyword: 'Notice Period', answer: '2 weeks' },
    { keyword: 'Hear about us', answer: 'LinkedIn' },
    { keyword: 'Clearance', answer: 'None' }
  ]);

  // --- 5. Legal & EEOC ---
  const [eligibleToWorkInUS, setEligibleToWorkInUS] = useState<boolean>(true);
  const [requiresSponsorship, setRequiresSponsorship] = useState<boolean>(false);
  const [gender, setGender] = useState('');
  const [race, setRace] = useState('');
  const [veteranStatus, setVeteranStatus] = useState('');
  const [disabilityStatus, setDisabilityStatus] = useState('');

  // --- 6. Application Config ---
  const [coverLetterTemplate, setCoverLetterTemplate] = useState(
    "Dear Hiring Manager at {COMPANY},\n\nI am excited to apply for the {POSITION} role..."
  );

  // Load Data
  useEffect(() => {
    async function loadProfile() {
      if (!user) return;
      try {
        const docRef = doc(db, 'users', user.uid);
        const docSnap = await getDoc(docRef);
        if (docSnap.exists()) {
          const data = docSnap.data();
          setPhone(data.phone || '');
          setLocation(data.location || '');
          setLinkedinUrl(data.linkedinUrl || '');
          setPortfolioUrl(data.portfolioUrl || '');
          setGithubUrl(data.githubUrl || '');
          setCurrentTitle(data.currentTitle || '');
          setYearsOfExperience(data.yearsOfExperience?.toString() || '');
          setSkills(data.skills || []);
          setWorkHistory(data.workHistory || []);
          setEducation(data.education || []);
          setDesiredSalary(data.desiredSalary || '');
          setWorkplaceType(data.workplaceType || 'remote');
          setRelocation(data.relocation || false);
          
          // Load custom questions or fallback to defaults if empty
          if (data.customQuestions && data.customQuestions.length > 0) {
            setCustomQuestions(data.customQuestions);
          }

          setEligibleToWorkInUS(data.eligibleToWorkInUS ?? true);
          setRequiresSponsorship(data.requiresSponsorship ?? false);
          setGender(data.gender || '');
          setRace(data.race || '');
          setVeteranStatus(data.veteranStatus || '');
          setDisabilityStatus(data.disabilityStatus || '');
          if (data.coverLetterTemplate) setCoverLetterTemplate(data.coverLetterTemplate);
        }
      } catch (error) {
        console.error("Error loading profile:", error);
      }
    }
    loadProfile();
  }, [user]);

  // Handlers
  const handleAddSkill = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && newSkill.trim()) {
      e.preventDefault();
      if (!skills.includes(newSkill.trim())) {
        setSkills([...skills, newSkill.trim()]);
      }
      setNewSkill('');
    }
  };

  const removeSkill = (skillToRemove: string) => {
    setSkills(skills.filter(s => s !== skillToRemove));
  };

  const handleSave = async () => {
    if (!user) return;
    setSaving(true);
    setSaved(false);
    try {
      await setDoc(doc(db, 'users', user.uid), {
        phone, location, linkedinUrl, portfolioUrl, githubUrl,
        currentTitle, yearsOfExperience, skills,
        workHistory, education,
        desiredSalary, workplaceType, relocation,
        customQuestions, // Save custom Q&A
        eligibleToWorkInUS, requiresSponsorship,
        gender, race, veteranStatus, disabilityStatus,
        coverLetterTemplate,
        autoApplySetupComplete: true,
        updatedAt: new Date(),
      }, { merge: true });
      setSaved(true);
      setTimeout(() => setSaved(false), 3000);
    } catch (error) {
      console.error("Error saving profile:", error);
      alert("Failed to save.");
    } finally {
      setSaving(false);
    }
  };

  const exportForExtension = () => {
    const profileData = {
      user: { name: user?.displayName, email: user?.email },
      contact: { phone, location, linkedinUrl, portfolioUrl, githubUrl },
      professional: { currentTitle, yearsOfExperience, skills },
      history: { workHistory, education },
      preferences: { desiredSalary, workplaceType, relocation, customQuestions },
      legal: { eligibleToWorkInUS, requiresSponsorship, gender, race, veteranStatus, disabilityStatus },
      coverLetter: coverLetterTemplate
    };
    const blob = new Blob([JSON.stringify(profileData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'jobhunt-auto-apply-profile.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };

  if (!user) return <div className="min-h-screen bg-[#0A0A0A] flex items-center justify-center"><Loader2 className="w-8 h-8 text-yellow-500 animate-spin" /></div>;

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-yellow-500/30">
      {/* Background Gradients */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-yellow-500/10 rounded-full blur-[120px] animate-pulse" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-purple-500/10 rounded-full blur-[120px] animate-pulse animation-delay-2000" />
        <div className="absolute inset-0 opacity-10" style={{ backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`, backgroundSize: '40px 40px' }} />
      </div>

      <div className="max-w-5xl mx-auto p-4 md:p-8 space-y-8">
        
        {/* Header */}
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
          <div>
            <Link href="/settings" className="inline-flex items-center text-sm text-gray-400 hover:text-white mb-2 transition-colors">
              <ArrowLeft className="w-4 h-4 mr-2" /> Back to Settings
            </Link>
            <h1 className="text-3xl font-black tracking-tight flex items-center gap-3">
              <span className="bg-gradient-to-r from-yellow-200 via-orange-200 to-red-200 bg-clip-text text-transparent">
                Auto-Apply Profile
              </span>
              <Badge className="bg-yellow-500/20 text-yellow-400 hover:bg-yellow-500/30 border-yellow-500/50">
                <Zap className="w-3 h-3 mr-1" /> Pro
              </Badge>
            </h1>
            <p className="text-gray-400 mt-1">Complete your profile once to unlock 1-click applications.</p>
          </div>
          
          <div className="flex gap-3">
             <Button onClick={exportForExtension} variant="outline" className="bg-gray-800 border-gray-700 text-gray-300 hover:text-white hover:bg-gray-700 gap-2">
              <Download className="w-4 h-4" /> Export JSON
            </Button>
            <Button onClick={handleSave} disabled={saving} className="bg-yellow-600 hover:bg-yellow-500 text-white gap-2 font-bold shadow-lg shadow-yellow-900/20">
              {saving ? <Loader2 className="animate-spin w-4 h-4" /> : <Save className="w-4 h-4" />}
              Save Profile
            </Button>
          </div>
        </div>

        {saved && (
          <div className="bg-green-500/10 border border-green-500/20 text-green-400 px-4 py-3 rounded-xl flex items-center gap-2 animate-in fade-in slide-in-from-top-2">
            <CheckCircle className="w-5 h-5" /> Changes saved successfully!
          </div>
        )}

        <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-6">
          <TabsList className="bg-gray-900/50 border border-gray-800 p-1 h-auto flex-wrap justify-start w-full rounded-xl">
            <TabsTrigger value="profile" className="gap-2 data-[state=active]:bg-gray-800 data-[state=active]:text-white text-gray-400"> <User className="w-4 h-4" /> Profile</TabsTrigger>
            <TabsTrigger value="experience" className="gap-2 data-[state=active]:bg-gray-800 data-[state=active]:text-white text-gray-400"> <Briefcase className="w-4 h-4" /> Experience</TabsTrigger>
            <TabsTrigger value="preferences" className="gap-2 data-[state=active]:bg-gray-800 data-[state=active]:text-white text-gray-400"> <Settings className="w-4 h-4" /> Preferences</TabsTrigger>
            <TabsTrigger value="legal" className="gap-2 data-[state=active]:bg-gray-800 data-[state=active]:text-white text-gray-400"> <Globe className="w-4 h-4" /> Legal</TabsTrigger>
            <TabsTrigger value="coverletter" className="gap-2 data-[state=active]:bg-gray-800 data-[state=active]:text-white text-gray-400"> <FileText className="w-4 h-4" /> Cover Letter</TabsTrigger>
          </TabsList>

          {/* --- TAB 1: PROFILE --- */}
          <TabsContent value="profile" className="space-y-6">
            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <h2 className="text-xl font-bold text-white mb-6">Basic Information</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-2">
                  <Label className="text-gray-300">Phone Number *</Label>
                  <Input className="bg-gray-800/50 border-gray-700 text-white" value={phone} onChange={e => setPhone(e.target.value)} placeholder="+1 (555) 000-0000" />
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">Location (City, State) *</Label>
                  <Input className="bg-gray-800/50 border-gray-700 text-white" value={location} onChange={e => setLocation(e.target.value)} placeholder="New York, NY" />
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">Current Job Title</Label>
                  <Input className="bg-gray-800/50 border-gray-700 text-white" value={currentTitle} onChange={e => setCurrentTitle(e.target.value)} />
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">Years of Experience</Label>
                  <Input className="bg-gray-800/50 border-gray-700 text-white" type="number" value={yearsOfExperience} onChange={e => setYearsOfExperience(e.target.value)} />
                </div>
              </div>
            </div>

            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <h2 className="text-xl font-bold text-white mb-6">Professional Links</h2>
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label className="text-gray-300">LinkedIn URL</Label>
                  <Input className="bg-gray-800/50 border-gray-700 text-white" value={linkedinUrl} onChange={e => setLinkedinUrl(e.target.value)} placeholder="https://linkedin.com/in/..." />
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">Portfolio / Website</Label>
                  <Input className="bg-gray-800/50 border-gray-700 text-white" value={portfolioUrl} onChange={e => setPortfolioUrl(e.target.value)} placeholder="https://myportfolio.com" />
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">GitHub URL</Label>
                  <Input className="bg-gray-800/50 border-gray-700 text-white" value={githubUrl} onChange={e => setGithubUrl(e.target.value)} placeholder="https://github.com/..." />
                </div>
              </div>
            </div>
          </TabsContent>

          {/* --- TAB 2: EXPERIENCE --- */}
          <TabsContent value="experience" className="space-y-6">
            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <div className="flex flex-row items-center justify-between mb-6">
                <div>
                  <h2 className="text-xl font-bold text-white">Work History</h2>
                  <p className="text-gray-400 text-sm">Most recent roles are most important</p>
                </div>
                <Button onClick={() => setWorkHistory([...workHistory, { company: '', title: '', startDate: '', endDate: '', current: false, description: '' }])} variant="outline" size="sm" className="bg-gray-800 border-gray-700 text-white hover:bg-gray-700">
                  <Plus className="w-4 h-4 mr-2" /> Add Job
                </Button>
              </div>
              <div className="space-y-6">
                {workHistory.map((work, idx) => (
                  <div key={idx} className="p-6 border border-gray-700 bg-gray-800/30 rounded-2xl space-y-4 relative">
                    <Button variant="ghost" size="sm" className="absolute top-4 right-4 text-red-400 hover:text-red-300 hover:bg-red-900/20" onClick={() => setWorkHistory(workHistory.filter((_, i) => i !== idx))}>
                      <Trash2 className="w-4 h-4" />
                    </Button>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="space-y-2"><Label className="text-gray-300">Company</Label><Input className="bg-gray-900/50 border-gray-700 text-white" value={work.company} onChange={e => { const newH = [...workHistory]; newH[idx].company = e.target.value; setWorkHistory(newH); }} /></div>
                      <div className="space-y-2"><Label className="text-gray-300">Job Title</Label><Input className="bg-gray-900/50 border-gray-700 text-white" value={work.title} onChange={e => { const newH = [...workHistory]; newH[idx].title = e.target.value; setWorkHistory(newH); }} /></div>
                    </div>
                    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                      <div className="space-y-2"><Label className="text-gray-300">Start Date</Label><Input className="bg-gray-900/50 border-gray-700 text-white" type="month" value={work.startDate} onChange={e => { const newH = [...workHistory]; newH[idx].startDate = e.target.value; setWorkHistory(newH); }} /></div>
                      <div className="space-y-2"><Label className="text-gray-300">End Date</Label><Input className="bg-gray-900/50 border-gray-700 text-white" type="month" value={work.endDate} disabled={work.current} onChange={e => { const newH = [...workHistory]; newH[idx].endDate = e.target.value; setWorkHistory(newH); }} /></div>
                      <div className="flex items-center pt-8"><input type="checkbox" className="mr-2 w-4 h-4 rounded border-gray-600 bg-gray-700" checked={work.current} onChange={e => { const newH = [...workHistory]; newH[idx].current = e.target.checked; setWorkHistory(newH); }} /><Label className="text-gray-300">Current Role</Label></div>
                    </div>
                    <div className="space-y-2">
                      <Label className="text-gray-300">Description</Label>
                      <Textarea className="bg-gray-900/50 border-gray-700 text-white min-h-[100px]" value={work.description} onChange={e => { const newH = [...workHistory]; newH[idx].description = e.target.value; setWorkHistory(newH); }} placeholder="â€¢ Led a team of..." />
                    </div>
                  </div>
                ))}
              </div>
            </div>
            
            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <div className="flex flex-row items-center justify-between mb-6">
                <h2 className="text-xl font-bold text-white">Education</h2>
                <Button onClick={() => setEducation([...education, { school: '', degree: '', field: '', graduationYear: '' }])} variant="outline" size="sm" className="bg-gray-800 border-gray-700 text-white hover:bg-gray-700">
                  <Plus className="w-4 h-4 mr-2" /> Add Education
                </Button>
              </div>
              <div className="space-y-6">
                {education.map((edu, idx) => (
                  <div key={idx} className="p-6 border border-gray-700 bg-gray-800/30 rounded-2xl space-y-4 relative">
                     <Button variant="ghost" size="sm" className="absolute top-4 right-4 text-red-400 hover:text-red-300 hover:bg-red-900/20" onClick={() => setEducation(education.filter((_, i) => i !== idx))}><Trash2 className="w-4 h-4" /></Button>
                     <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div className="space-y-2"><Label className="text-gray-300">School</Label><Input className="bg-gray-900/50 border-gray-700 text-white" value={edu.school} onChange={e => { const newE = [...education]; newE[idx].school = e.target.value; setEducation(newE); }} /></div>
                        <div className="space-y-2"><Label className="text-gray-300">Degree</Label><Input className="bg-gray-900/50 border-gray-700 text-white" value={edu.degree} onChange={e => { const newE = [...education]; newE[idx].degree = e.target.value; setEducation(newE); }} /></div>
                        <div className="space-y-2"><Label className="text-gray-300">Field of Study</Label><Input className="bg-gray-900/50 border-gray-700 text-white" value={edu.field} onChange={e => { const newE = [...education]; newE[idx].field = e.target.value; setEducation(newE); }} /></div>
                        <div className="space-y-2"><Label className="text-gray-300">Graduation Year</Label><Input className="bg-gray-900/50 border-gray-700 text-white" value={edu.graduationYear} onChange={e => { const newE = [...education]; newE[idx].graduationYear = e.target.value; setEducation(newE); }} /></div>
                     </div>
                  </div>
                ))}
              </div>
            </div>
          </TabsContent>

          {/* --- TAB 3: PREFERENCES & SKILLS --- */}
          <TabsContent value="preferences" className="space-y-6">
            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <h2 className="text-xl font-bold text-white mb-2">Skills</h2>
              <p className="text-gray-400 mb-6 text-sm">Type a skill and press Enter to add it.</p>
              <Input 
                value={newSkill} 
                onChange={e => setNewSkill(e.target.value)} 
                onKeyDown={handleAddSkill} 
                placeholder="e.g. React, Python, Product Management (Press Enter)" 
                className="bg-gray-800/50 border-gray-700 text-white mb-4"
              />
              <div className="flex flex-wrap gap-2">
                {skills.map(skill => (
                  <Badge key={skill} className="px-3 py-1.5 text-sm flex items-center gap-2 bg-yellow-500/20 text-yellow-300 border-yellow-500/30 hover:bg-yellow-500/30">
                    {skill} <X className="w-3 h-3 cursor-pointer hover:text-white" onClick={() => removeSkill(skill)} />
                  </Badge>
                ))}
                {skills.length === 0 && <span className="text-sm text-gray-500 italic">No skills added yet.</span>}
              </div>
            </div>

            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <h2 className="text-xl font-bold text-white mb-6">Job Preferences</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-2">
                  <Label className="text-gray-300">Desired Salary (Annual USD)</Label>
                  <Input className="bg-gray-800/50 border-gray-700 text-white" value={desiredSalary} onChange={e => setDesiredSalary(e.target.value)} placeholder="120000" />
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">Workplace Type</Label>
                  <Select value={workplaceType} onValueChange={setWorkplaceType}>
                    <SelectTrigger className="bg-gray-800/50 border-gray-700 text-white"><SelectValue placeholder="Select type" /></SelectTrigger>
                    <SelectContent className="bg-gray-800 border-gray-700 text-white">
                      <SelectItem value="remote">Remote Only</SelectItem>
                      <SelectItem value="hybrid">Hybrid</SelectItem>
                      <SelectItem value="onsite">On-site</SelectItem>
                      <SelectItem value="any">Open to Any</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="flex items-center space-x-3 pt-4">
                  <input type="checkbox" id="reloc" checked={relocation} onChange={e => setRelocation(e.target.checked)} className="w-5 h-5 rounded border-gray-600 bg-gray-700" />
                  <Label htmlFor="reloc" className="cursor-pointer text-gray-300">I am willing to relocate</Label>
                </div>
              </div>
            </div>

            {/* NEW: Custom Common Questions Section */}
            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4">
                <div>
                  <h2 className="text-xl font-bold text-white flex items-center gap-2">
                    <MessageSquare className="w-5 h-5 text-purple-400" />
                    Common Questions & Answers
                  </h2>
                  <p className="text-gray-400 text-sm mt-1">
                    Pre-fill answers for common application questions to avoid using AI for basic facts.
                  </p>
                </div>
                <Button 
                  onClick={() => setCustomQuestions([...customQuestions, { keyword: '', answer: '' }])}
                  variant="outline" 
                  size="sm" 
                  className="bg-gray-800 border-gray-700 text-white hover:bg-gray-700"
                >
                  <Plus className="w-4 h-4 mr-2" /> Add Question
                </Button>
              </div>

              <div className="space-y-4">
                {customQuestions.map((q, idx) => (
                  <div key={idx} className="flex gap-4 items-start p-4 bg-gray-800/30 rounded-xl border border-gray-700/50">
                    <div className="flex-1 space-y-2">
                      <Label className="text-xs text-gray-400">If question contains keyword:</Label>
                      <Input 
                        placeholder="e.g. Notice Period" 
                        value={q.keyword}
                        onChange={e => {
                          const newQ = [...customQuestions];
                          newQ[idx].keyword = e.target.value;
                          setCustomQuestions(newQ);
                        }}
                        className="bg-gray-900/50 border-gray-700 text-white"
                      />
                    </div>
                    <div className="flex-1 space-y-2">
                      <Label className="text-xs text-gray-400">Auto-fill this answer:</Label>
                      <Input 
                        placeholder="e.g. 2 weeks" 
                        value={q.answer}
                        onChange={e => {
                          const newQ = [...customQuestions];
                          newQ[idx].answer = e.target.value;
                          setCustomQuestions(newQ);
                        }}
                        className="bg-gray-900/50 border-gray-700 text-white"
                      />
                    </div>
                    <div className="pt-8">
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        onClick={() => setCustomQuestions(customQuestions.filter((_, i) => i !== idx))}
                        className="text-gray-500 hover:text-red-400 hover:bg-red-900/20"
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    </div>
                  </div>
                ))}
                
                {customQuestions.length === 0 && (
                  <div className="text-center py-8 text-gray-500 border border-dashed border-gray-800 rounded-xl">
                    No custom questions added yet. Add "Notice Period" or "Clearance" to speed up applications.
                  </div>
                )}
              </div>
            </div>
          </TabsContent>

           {/* --- TAB 4: LEGAL & EEOC --- */}
           <TabsContent value="legal" className="space-y-6">
            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <h2 className="text-xl font-bold text-white mb-6">Work Authorization</h2>
              <div className="space-y-4">
                <div className="flex items-center space-x-3 p-4 border border-gray-700 bg-gray-800/30 rounded-xl hover:bg-gray-800/50 transition-colors">
                  <input type="checkbox" checked={eligibleToWorkInUS} onChange={e => setEligibleToWorkInUS(e.target.checked)} className="w-5 h-5 rounded border-gray-600 bg-gray-700" />
                  <Label className="text-gray-300 cursor-pointer">I am authorized to work in the United States</Label>
                </div>
                <div className="flex items-center space-x-3 p-4 border border-gray-700 bg-gray-800/30 rounded-xl hover:bg-gray-800/50 transition-colors">
                  <input type="checkbox" checked={requiresSponsorship} onChange={e => setRequiresSponsorship(e.target.checked)} className="w-5 h-5 rounded border-gray-600 bg-gray-700" />
                  <Label className="text-gray-300 cursor-pointer">I will require visa sponsorship now or in the future</Label>
                </div>
              </div>
            </div>

            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <h2 className="text-xl font-bold text-white mb-2">EEOC Information (Voluntary)</h2>
              <p className="text-gray-400 mb-6 text-sm">Standard questions asked by 99% of ATS systems. Providing this allows for fuller auto-completion.</p>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div className="space-y-2">
                  <Label className="text-gray-300">Gender</Label>
                  <Select value={gender} onValueChange={setGender}>
                    <SelectTrigger className="bg-gray-800/50 border-gray-700 text-white"><SelectValue placeholder="Select..." /></SelectTrigger>
                    <SelectContent className="bg-gray-800 border-gray-700 text-white">
                      <SelectItem value="male">Male</SelectItem>
                      <SelectItem value="female">Female</SelectItem>
                      <SelectItem value="non-binary">Non-binary</SelectItem>
                      <SelectItem value="decline">Decline to Self-Identify</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">Race / Ethnicity</Label>
                  <Select value={race} onValueChange={setRace}>
                    <SelectTrigger className="bg-gray-800/50 border-gray-700 text-white"><SelectValue placeholder="Select..." /></SelectTrigger>
                    <SelectContent className="bg-gray-800 border-gray-700 text-white">
                      <SelectItem value="white">White</SelectItem>
                      <SelectItem value="black">Black or African American</SelectItem>
                      <SelectItem value="hispanic">Hispanic or Latino</SelectItem>
                      <SelectItem value="asian">Asian</SelectItem>
                      <SelectItem value="two_or_more">Two or More Races</SelectItem>
                      <SelectItem value="decline">Decline to Self-Identify</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">Veteran Status</Label>
                  <Select value={veteranStatus} onValueChange={setVeteranStatus}>
                    <SelectTrigger className="bg-gray-800/50 border-gray-700 text-white"><SelectValue placeholder="Select..." /></SelectTrigger>
                    <SelectContent className="bg-gray-800 border-gray-700 text-white">
                      <SelectItem value="veteran">I am a Veteran</SelectItem>
                      <SelectItem value="not_veteran">I am not a Veteran</SelectItem>
                      <SelectItem value="decline">Decline to Self-Identify</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label className="text-gray-300">Disability Status</Label>
                  <Select value={disabilityStatus} onValueChange={setDisabilityStatus}>
                    <SelectTrigger className="bg-gray-800/50 border-gray-700 text-white"><SelectValue placeholder="Select..." /></SelectTrigger>
                    <SelectContent className="bg-gray-800 border-gray-700 text-white">
                      <SelectItem value="yes">Yes, I have a disability</SelectItem>
                      <SelectItem value="no">No, I do not have a disability</SelectItem>
                      <SelectItem value="decline">Decline to Self-Identify</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </div>
           </TabsContent>

          {/* --- TAB 5: COVER LETTER --- */}
          <TabsContent value="coverletter" className="space-y-6">
            <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
              <h2 className="text-xl font-bold text-white mb-2">Master Cover Letter Template</h2>
              <p className="text-gray-400 mb-6 text-sm">This template is used when the AI generates a letter. Use the variables below to make it dynamic.</p>
              
              <div className="flex gap-2 flex-wrap mb-4">
                <Badge variant="outline" className="cursor-pointer border-gray-600 text-gray-300 hover:bg-gray-800 hover:text-white" onClick={() => setCoverLetterTemplate(prev => prev + "{COMPANY}")}>+ {"{COMPANY}"}</Badge>
                <Badge variant="outline" className="cursor-pointer border-gray-600 text-gray-300 hover:bg-gray-800 hover:text-white" onClick={() => setCoverLetterTemplate(prev => prev + "{POSITION}")}>+ {"{POSITION}"}</Badge>
                <Badge variant="outline" className="cursor-pointer border-gray-600 text-gray-300 hover:bg-gray-800 hover:text-white" onClick={() => setCoverLetterTemplate(prev => prev + "{YOUR_NAME}")}>+ {"{YOUR_NAME}"}</Badge>
              </div>
              <Textarea 
                rows={15} 
                className="font-mono text-sm leading-relaxed bg-gray-800/50 border-gray-700 text-gray-200 focus:ring-yellow-500/50"
                value={coverLetterTemplate} 
                onChange={e => setCoverLetterTemplate(e.target.value)} 
              />
            </div>
          </TabsContent>

        </Tabs>
      </div>
    </div>
  );
}
===== ./src/app/settings/billing/page.tsx =====
"use client";

import React, { useState } from 'react';
import Link from 'next/link';
import { CreditCard, Clock, Shield, ArrowLeft, Loader2, Sparkles, CheckCircle } from 'lucide-react';

export default function BillingPage() {
  const [loading, setLoading] = useState(false);

  const handleManageSubscription = async () => {
    setLoading(true);
    // Simulate opening Stripe Customer Portal
    await new Promise(resolve => setTimeout(resolve, 1500));
    alert("This would open the Stripe Customer Portal to update card/cancel plan.");
    setLoading(false);
  };

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30">
      {/* --- Background Gradients --- */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 right-0 w-[500px] h-[500px] bg-green-500/10 rounded-full blur-[120px]" />
        <div className="absolute bottom-0 left-0 w-[500px] h-[500px] bg-blue-500/10 rounded-full blur-[120px]" />
        <div className="absolute inset-0 opacity-10"
          style={{
            backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`,
            backgroundSize: '40px 40px'
          }}
        />
      </div>

      <div className="max-w-4xl mx-auto p-4 md:p-8 space-y-8">
        
        {/* Header */}
        <div>
          <Link href="/settings" className="inline-flex items-center text-sm text-gray-400 hover:text-white mb-4 transition-colors">
            <ArrowLeft className="w-4 h-4 mr-2" /> Back to Settings
          </Link>
          <h1 className="text-4xl font-black tracking-tight mb-2">
            <span className="bg-gradient-to-r from-white via-green-200 to-blue-200 bg-clip-text text-transparent">
              Billing & Subscription
            </span>
          </h1>
          <p className="text-gray-400 text-lg">Manage your plan, payment methods, and billing history.</p>
        </div>

        {/* Current Plan Card */}
        <div className="group relative">
          <div className="absolute inset-0 bg-gradient-to-r from-blue-500/20 to-purple-500/20 rounded-3xl blur-xl opacity-50" />
          <div className="relative bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
            
            <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-8">
              <div>
                <div className="flex items-center gap-3 mb-2">
                  <h2 className="text-2xl font-bold text-white">Current Plan</h2>
                  <span className="px-3 py-1 rounded-full text-xs font-bold bg-green-500/20 text-green-400 border border-green-500/30">
                    Active
                  </span>
                </div>
                <p className="text-gray-400">Renews on Feb 3, 2026</p>
              </div>
              <div className="text-right">
                <div className="flex items-baseline justify-end gap-1">
                  <span className="text-4xl font-black text-white">$0</span>
                  <span className="text-gray-500 font-medium">/month</span>
                </div>
              </div>
            </div>

            {/* Plan Details Box */}
            <div className="bg-gray-800/50 rounded-2xl p-6 mb-8 border border-gray-700/50">
              <div className="flex items-start gap-4">
                <div className="p-3 bg-blue-500/10 rounded-xl">
                  <Shield className="w-6 h-6 text-blue-400" />
                </div>
                <div>
                  <h3 className="text-lg font-bold text-white mb-1">Free Starter</h3>
                  <p className="text-gray-400 leading-relaxed">
                    You are currently on the free plan. Upgrade to Pro to unlock unlimited job matches, AI cover letters, and priority support.
                  </p>
                </div>
              </div>
            </div>

            {/* Actions */}
            <div className="flex flex-col sm:flex-row gap-4">
              <Link href="/pricing" className="flex-1">
                <button className="w-full py-4 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 rounded-xl font-bold text-white shadow-lg hover:shadow-blue-500/25 transition-all transform hover:scale-[1.02] flex items-center justify-center gap-2">
                  <Sparkles className="w-5 h-5" />
                  Upgrade Plan
                </button>
              </Link>
              <button 
                onClick={handleManageSubscription}
                disabled={loading}
                className="flex-1 py-4 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded-xl font-bold text-gray-300 transition-all flex items-center justify-center gap-2"
              >
                {loading ? <Loader2 className="w-5 h-5 animate-spin" /> : "Manage Subscription"}
              </button>
            </div>
          </div>
        </div>

        {/* Payment Method */}
        <div className="bg-gray-900/40 backdrop-blur-xl border border-gray-800 rounded-3xl overflow-hidden">
          <div className="p-6 border-b border-gray-800">
            <h2 className="text-xl font-bold text-white flex items-center gap-3">
              <CreditCard className="w-6 h-6 text-purple-400" />
              Payment Method
            </h2>
          </div>
          <div className="p-6">
            <div className="flex items-center justify-between p-4 bg-gray-800/30 border border-gray-700 rounded-xl">
              <div className="flex items-center gap-4">
                <div className="w-14 h-10 bg-gray-800 rounded-lg border border-gray-700 flex items-center justify-center">
                  <span className="text-xs font-bold text-gray-500">CARD</span>
                </div>
                <div>
                  <p className="text-sm font-medium text-white">No payment method added</p>
                  <p className="text-xs text-gray-500">Add a card to upgrade your plan</p>
                </div>
              </div>
              <button className="text-sm font-bold text-blue-400 hover:text-blue-300 transition-colors">
                Add Card
              </button>
            </div>
          </div>
        </div>

        {/* Billing History */}
        <div className="bg-gray-900/40 backdrop-blur-xl border border-gray-800 rounded-3xl overflow-hidden">
          <div className="p-6 border-b border-gray-800">
            <h2 className="text-xl font-bold text-white flex items-center gap-3">
              <Clock className="w-6 h-6 text-green-400" />
              Billing History
            </h2>
          </div>
          <div className="divide-y divide-gray-800">
            {/* Empty State */}
            <div className="p-12 text-center">
              <div className="w-16 h-16 bg-gray-800 rounded-full flex items-center justify-center mx-auto mb-4">
                <Clock className="w-8 h-8 text-gray-600" />
              </div>
              <p className="text-gray-500 font-medium">No invoices available yet.</p>
            </div>
          </div>
        </div>

      </div>
    </div>
  );
}
===== ./src/app/settings/page.tsx =====
'use client';

import React from 'react';
import Link from 'next/link';
import { 
  User, 
  FileText, 
  CreditCard, 
  Bell, 
  ChevronRight, 
  Shield,
  Target,
  Zap,
  LogOut
} from 'lucide-react';
import { useAuth } from '@/contexts/AuthContext';

export default function SettingsPage() {
  const { signOut } = useAuth();

  const settingsOptions = [
    {
      title: "Job Preferences",
      description: "Set your job search criteria and match preferences",
      icon: Target,
      href: "/settings/preferences",
      color: "text-blue-400",
      bgColor: "bg-blue-400/10"
    },
    {
      title: "Profile Information",
      description: "Update your name, email, and contact info",
      icon: User,
      href: "/settings/profile",
      color: "text-purple-400",
      bgColor: "bg-purple-400/10"
    },
    {
      title: "Resume & Documents",
      description: "Upload your master resume for applications",
      icon: FileText,
      href: "/settings/resume",
      color: "text-pink-400",
      bgColor: "bg-pink-400/10"
    },
    {
      title: "Auto-Apply Setup",
      description: "Configure one-click job applications",
      icon: Zap,
      href: "/settings/auto-apply",
      color: "text-yellow-400",
      bgColor: "bg-yellow-400/10"
    },
    {
      title: "Billing & Subscription",
      description: "Manage your Pro plan and payment methods",
      icon: CreditCard,
      href: "/settings/billing", 
      color: "text-green-400",
      bgColor: "bg-green-400/10"
    },
    {
      title: "Notifications",
      description: "Configure your job alert emails",
      icon: Bell,
      href: "/settings/notifications",
      color: "text-orange-400",
      bgColor: "bg-orange-400/10"
    },
  ];

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30">
      {/* --- Background Gradients (Premium Look) --- */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 right-0 w-[500px] h-[500px] bg-blue-500/10 rounded-full blur-[120px]" />
        <div className="absolute bottom-0 left-0 w-[500px] h-[500px] bg-purple-500/10 rounded-full blur-[120px]" />
        <div className="absolute inset-0 opacity-10"
          style={{
            backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`,
            backgroundSize: '40px 40px'
          }}
        />
      </div>

      <div className="max-w-4xl mx-auto p-4 md:p-8 space-y-10">
        
        {/* Header */}
        <div>
          <h1 className="text-4xl font-black tracking-tight mb-2">
            <span className="bg-gradient-to-r from-white via-gray-200 to-gray-400 bg-clip-text text-transparent">
              Settings
            </span>
          </h1>
          <p className="text-gray-400 text-lg">Manage your account preferences and AI configurations.</p>
        </div>

        {/* Settings Grid */}
        <div className="grid gap-4">
          {settingsOptions.map((option, index) => (
            <Link key={index} href={option.href}>
              <div className="group relative bg-gray-900/40 hover:bg-gray-800/60 backdrop-blur-xl border border-gray-800 hover:border-gray-600 rounded-2xl p-4 transition-all duration-300 flex items-center gap-4 cursor-pointer">
                <div className={`p-3 rounded-xl ${option.bgColor} group-hover:scale-110 transition-transform duration-300`}>
                  <option.icon className={`w-6 h-6 ${option.color}`} />
                </div>
                <div className="flex-1">
                  <h3 className="font-semibold text-white group-hover:text-blue-400 transition-colors">{option.title}</h3>
                  <p className="text-sm text-gray-400">{option.description}</p>
                </div>
                <ChevronRight className="w-5 h-5 text-gray-600 group-hover:text-white group-hover:translate-x-1 transition-all" />
              </div>
            </Link>
          ))}
        </div>

        {/* Security Section */}
        <div>
          <h2 className="text-xl font-bold text-white mb-4">Security</h2>
          <div className="group relative bg-gray-900/40 backdrop-blur-xl border border-gray-800 rounded-2xl p-6 flex items-center justify-between">
             <div className="flex items-center gap-4">
                <div className="p-3 rounded-xl bg-gray-800/50">
                  <Shield className="w-6 h-6 text-gray-400" />
                </div>
                <div>
                  <h3 className="font-semibold text-white">Password & Authentication</h3>
                  <p className="text-sm text-gray-400">Managed via Firebase Auth</p>
                </div>
              </div>
              <button className="text-sm font-medium text-blue-400 hover:text-blue-300 transition-colors">
                Change Password
              </button>
          </div>
        </div>

         {/* Sign Out Button */}
         <div className="pt-4">
             <button 
               onClick={() => signOut()}
               className="flex items-center gap-2 text-red-400 hover:text-red-300 transition-colors px-4 py-2 rounded-lg hover:bg-red-400/10"
             >
               <LogOut className="w-5 h-5" />
               <span className="font-medium">Sign Out</span>
             </button>
          </div>

      </div>
    </div>
  );
}
===== ./src/app/settings/preferences/page.tsx =====
"use client";

import React, { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { doc, setDoc, getDoc } from 'firebase/firestore';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Slider } from '@/components/ui/slider';
import { Badge } from '@/components/ui/badge'; // Kept Badge for consistent behavior
import { 
  Sparkles, 
  Plus, 
  X, 
  MapPin, 
  Briefcase, 
  Target,
  Save,
  Loader2,
  CheckCircle,
  Ban, // Exclusions icon
  ArrowLeft
} from 'lucide-react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';

// --- Constants (Preserved Exactly) ---
const POPULAR_KEYWORDS = [
  'Product Manager', 'Software Engineer', 'Data Scientist', 
  'Network Engineer', 'DevOps Engineer', 'Frontend Developer',
  'Backend Developer', 'Full Stack', 'Machine Learning',
  'Security Engineer', 'Cloud Architect', 'UI/UX Designer'
];

const SENIORITY_LEVELS = [
  { value: 'junior', label: 'Junior (0-2 years)' },
  { value: 'mid', label: 'Mid-Level (2-5 years)' },
  { value: 'senior', label: 'Senior (5-8 years)' },
  { value: 'staff', label: 'Staff (8-12 years)' },
  { value: 'principal', label: 'Principal (12+ years)' },
  { value: 'lead', label: 'Lead' },
  { value: 'executive', label: 'Director/VP/C-Level' }
];

const US_LOCATIONS = [
  'Remote', 'San Francisco', 'Bay Area', 'New York', 'Seattle',
  'Austin', 'Boston', 'Los Angeles', 'Chicago', 'Denver',
  'Portland', 'San Diego', 'Washington DC', 'Miami', 'Atlanta'
];

export default function PreferencesPage() {
  // --- Hooks & State ---
  const { user } = useAuth();
  const router = useRouter();
  const [saving, setSaving] = useState(false);
  const [saved, setSaved] = useState(false);
  
  // Job Keywords State
  const [keywords, setKeywords] = useState<string[]>([]);
  const [customKeyword, setCustomKeyword] = useState('');
  
  // Exclude Keywords State
  const [excludeKeywords, setExcludeKeywords] = useState<string[]>([]);
  const [customExcludeKeyword, setCustomExcludeKeyword] = useState('');

  // Other Preferences State
  const [seniority, setSeniority] = useState<string[]>([]);
  const [locations, setLocations] = useState<string[]>([]);
  const [customLocation, setCustomLocation] = useState('');
  const [minMatchScore, setMinMatchScore] = useState(60);

  // --- Load Existing Preferences ---
  useEffect(() => {
    async function loadPreferences() {
      if (!user) return;
      
      try {
        const docRef = doc(db, 'users', user.uid);
        const docSnap = await getDoc(docRef);
        
        if (docSnap.exists()) {
          const data = docSnap.data();
          setKeywords(data.searchKeywords || []);
          setExcludeKeywords(data.excludedKeywords || []); // Load exclusions
          setSeniority(data.seniorityLevels || []);
          setLocations(data.preferredLocations || []);
          setMinMatchScore(data.minMatchScore || 60);
        }
      } catch (error) {
        console.error("Error loading preferences:", error);
      }
    }
    
    loadPreferences();
  }, [user]);

  // --- Handlers ---

  // Add Keyword Handler
  const addKeyword = (keyword: string) => {
    const normalized = keyword.toLowerCase().trim();
    if (normalized && !keywords.some(k => k.toLowerCase() === normalized)) {
      setKeywords([...keywords, keyword.trim()]);
      setCustomKeyword('');
    }
  };

  // Remove Keyword Handler
  const removeKeyword = (keyword: string) => {
    setKeywords(keywords.filter(k => k !== keyword));
  };

  // Add Exclude Keyword Handler
  const addExcludeKeyword = (keyword: string) => {
    const normalized = keyword.toLowerCase().trim();
    if (normalized && !excludeKeywords.some(k => k.toLowerCase() === normalized)) {
      setExcludeKeywords([...excludeKeywords, keyword.trim()]);
      setCustomExcludeKeyword('');
    }
  };

  // Remove Exclude Keyword Handler
  const removeExcludeKeyword = (keyword: string) => {
    setExcludeKeywords(excludeKeywords.filter(k => k !== keyword));
  };

  // Toggle Seniority Handler
  const toggleSeniority = (level: string) => {
    if (seniority.includes(level)) {
      setSeniority(seniority.filter(s => s !== level));
    } else {
      setSeniority([...seniority, level]);
    }
  };

  // Add Location Handler
  const addLocation = (location: string) => {
    const normalized = location.toLowerCase().trim();
    if (normalized && !locations.some(l => l.toLowerCase() === normalized)) {
      setLocations([...locations, location.trim()]);
      setCustomLocation('');
    }
  };

  // Remove Location Handler
  const removeLocation = (location: string) => {
    setLocations(locations.filter(l => l !== location));
  };

  // Save Preferences Handler
  const handleSave = async () => {
    if (!user) return;
    
    setSaving(true);
    setSaved(false);
    
    try {
      await setDoc(doc(db, 'users', user.uid), {
        email: user.email,
        displayName: user.displayName,
        searchKeywords: keywords,
        excludeKeywords: excludeKeywords, // Save exclusions to Firestore
        seniorityLevels: seniority,
        preferredLocations: locations,
        minMatchScore: minMatchScore,
        preferencesUpdatedAt: new Date(),
      }, { merge: true });
      
      setSaved(true);
      setTimeout(() => router.push('/dashboard'), 1500);
      
    } catch (error) {
      console.error("Error saving preferences:", error);
      alert("Failed to save preferences. Please try again.");
    } finally {
      setSaving(false);
    }
  };

  if (!user) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-[#0A0A0A]">
        <Loader2 className="w-8 h-8 text-blue-500 animate-spin" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30">
      {/* --- Background Gradients (Premium Look) --- */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-blue-500/20 rounded-full blur-[120px] animate-pulse" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-purple-500/20 rounded-full blur-[120px] animate-pulse animation-delay-2000" />
        <div className="absolute inset-0 opacity-10"
          style={{
            backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`,
            backgroundSize: '40px 40px'
          }}
        />
      </div>

      <div className="max-w-4xl mx-auto p-4 md:p-8 space-y-8">
        
        {/* Header */}
        <div>
          <Link href="/settings" className="inline-flex items-center text-sm text-gray-400 hover:text-white mb-4 transition-colors">
            <ArrowLeft className="w-4 h-4 mr-2" /> Back to Settings
          </Link>
          <div className="flex items-center gap-3 mb-2">
            <Sparkles className="w-8 h-8 text-blue-400" />
            <h1 className="text-4xl font-black tracking-tight">
              <span className="bg-gradient-to-r from-white via-blue-200 to-purple-200 bg-clip-text text-transparent">
                Job Preferences
              </span>
            </h1>
          </div>
          <p className="text-gray-400 text-lg">
            Tell us what you're looking for. Our AI will match you with perfect opportunities.
          </p>
        </div>

        {saved && (
          <div className="p-4 bg-green-500/10 border border-green-500/20 rounded-xl flex items-center gap-3 animate-in fade-in slide-in-from-top-2">
            <CheckCircle className="w-5 h-5 text-green-400" />
            <span className="text-green-300 font-medium">
              Preferences saved! Redirecting to dashboard...
            </span>
          </div>
        )}

        <div className="space-y-6">
          
          {/* =======================
              KEYWORDS SECTION 
             ======================= */}
          <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
            <div className="flex items-center gap-2 mb-2">
              <Target className="w-5 h-5 text-blue-400" />
              <h2 className="text-xl font-bold text-white">Job Titles & Keywords</h2>
            </div>
            <p className="text-gray-400 mb-6 text-sm">
              What roles are you interested in? Add keywords that describe your ideal position.
            </p>

            {/* Selected Keywords Area */}
            {keywords.length > 0 && (
              <div className="flex flex-wrap gap-2 mb-6 p-4 bg-gray-800/50 rounded-xl border border-gray-700/50">
                {keywords.map((keyword, idx) => (
                  <Badge 
                    key={idx} 
                    className="flex items-center gap-2 px-3 py-1.5 bg-blue-600/20 text-blue-300 border-blue-500/30 hover:bg-blue-600/30 rounded-lg text-sm font-medium"
                  >
                    {keyword}
                    <button 
                      onClick={() => removeKeyword(keyword)}
                      className="ml-1 hover:text-white rounded-full p-0.5"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            )}

            {/* Quick Select Buttons */}
            <div className="mb-6">
              <p className="text-xs font-bold text-gray-500 uppercase tracking-wider mb-3">
                Quick Select (Popular Roles)
              </p>
              <div className="flex flex-wrap gap-2">
                {POPULAR_KEYWORDS.map((keyword) => (
                  <button
                    key={keyword}
                    onClick={() => addKeyword(keyword)}
                    disabled={keywords.includes(keyword)}
                    className={`px-3 py-1.5 text-sm rounded-lg border transition-all ${
                      keywords.includes(keyword)
                        ? 'bg-gray-800 text-gray-500 border-gray-700 cursor-not-allowed'
                        : 'bg-gray-900/50 text-gray-300 border-gray-700 hover:border-gray-500 hover:text-white'
                    }`}
                  >
                    {keyword}
                  </button>
                ))}
              </div>
            </div>

            {/* Custom Keyword Input */}
            <div>
              <p className="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">
                Add Custom Keyword
              </p>
              <div className="flex gap-2">
                <Input
                  placeholder="e.g., Technical Product Manager"
                  value={customKeyword}
                  onChange={(e) => setCustomKeyword(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      e.preventDefault();
                      addKeyword(customKeyword);
                    }
                  }}
                  className="bg-gray-800/50 border-gray-700 text-white placeholder-gray-500"
                />
                <Button 
                  onClick={() => addKeyword(customKeyword)} 
                  disabled={!customKeyword.trim()} 
                  className="bg-blue-600 hover:bg-blue-500"
                >
                  <Plus className="w-4 h-4" />
                </Button>
              </div>
            </div>
          </div>

          {/* =======================
              EXCLUSIONS SECTION (NEW)
             ======================= */}
          <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
            <div className="flex items-center gap-2 mb-2">
              <Ban className="w-5 h-5 text-red-400" />
              <h2 className="text-xl font-bold text-white">Exclusions & Negative Filters</h2>
            </div>
            <p className="text-gray-400 mb-6 text-sm">
              Are there specific terms you want to avoid? Jobs containing these words will be hidden.
            </p>

            <div className="flex gap-2 mb-4">
              <Input
                value={customExcludeKeyword}
                onChange={e => setCustomExcludeKeyword(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault();
                    addExcludeKeyword(customExcludeKeyword);
                  }
                }}
                placeholder="e.g., Intern, Unpaid, Sales"
                className="bg-gray-800/50 border-gray-700 text-white placeholder-gray-500"
              />
              <Button 
                onClick={() => addExcludeKeyword(customExcludeKeyword)} 
                disabled={!customExcludeKeyword.trim()} 
                className="bg-gray-700 hover:bg-gray-600"
              >
                <Plus className="w-4 h-4" />
              </Button>
            </div>
            
            {excludeKeywords.length > 0 && (
              <div className="flex flex-wrap gap-2 mt-2 p-4 bg-gray-800/30 rounded-xl border border-gray-700/30">
                {excludeKeywords.map(kw => (
                  <Badge key={kw} className="flex items-center gap-2 px-3 py-1.5 bg-red-500/10 text-red-400 border-red-500/20 hover:bg-red-500/20 rounded-lg text-sm">
                    {kw} 
                    <button 
                      onClick={() => removeExcludeKeyword(kw)}
                      className="ml-1 hover:text-red-200 rounded-full p-0.5"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            )}
          </div>

          {/* =======================
              SENIORITY SECTION 
             ======================= */}
          <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
            <div className="flex items-center gap-2 mb-2">
              <Briefcase className="w-5 h-5 text-purple-400" />
              <h2 className="text-xl font-bold text-white">Experience Level</h2>
            </div>
            <p className="text-gray-400 mb-6 text-sm">
              Select all seniority levels you're open to.
            </p>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {SENIORITY_LEVELS.map((level) => (
                <button
                  key={level.value}
                  onClick={() => toggleSeniority(level.value)}
                  className={`p-4 rounded-xl border text-left transition-all ${
                    seniority.includes(level.value)
                      ? 'bg-purple-500/20 border-purple-500/50 text-white shadow-lg shadow-purple-900/20'
                      : 'bg-gray-800/30 border-gray-700 text-gray-400 hover:bg-gray-800 hover:text-gray-200'
                  }`}
                >
                  <div className="flex items-center justify-between">
                    <span className="font-medium">{level.label}</span>
                    {seniority.includes(level.value) && (
                      <CheckCircle className="w-5 h-5 text-purple-400" />
                    )}
                  </div>
                </button>
              ))}
            </div>
          </div>

          {/* =======================
              LOCATIONS SECTION 
             ======================= */}
          <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
            <div className="flex items-center gap-2 mb-2">
              <MapPin className="w-5 h-5 text-green-400" />
              <h2 className="text-xl font-bold text-white">Preferred Locations</h2>
            </div>
            <p className="text-gray-400 mb-6 text-sm">
              Where would you like to work? Select multiple locations or add custom ones.
            </p>
            
            {/* Selected Locations */}
            {locations.length > 0 && (
              <div className="flex flex-wrap gap-2 mb-6 p-4 bg-gray-800/50 rounded-xl border border-gray-700/50">
                {locations.map((loc, idx) => (
                  <Badge 
                    key={idx} 
                    className="flex items-center gap-2 px-3 py-1.5 bg-green-500/10 text-green-400 border-green-500/20 hover:bg-green-500/20 rounded-lg text-sm"
                  >
                    {loc}
                    <button 
                      onClick={() => removeLocation(loc)}
                      className="ml-1 hover:text-green-200 rounded-full p-0.5"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            )}

            {/* Quick Select Locations */}
            <div className="mb-6">
               <p className="text-xs font-bold text-gray-500 uppercase tracking-wider mb-3">
                 Popular US Locations
               </p>
               <div className="flex flex-wrap gap-2">
                {US_LOCATIONS.map((loc) => (
                  <button
                    key={loc}
                    onClick={() => addLocation(loc)}
                    disabled={locations.some(l => l.toLowerCase() === loc.toLowerCase())}
                    className={`px-3 py-1.5 text-sm rounded-lg border transition-all ${
                      locations.some(l => l.toLowerCase() === loc.toLowerCase())
                        ? 'bg-gray-800 text-gray-500 border-gray-700'
                        : 'bg-gray-900/50 text-gray-300 border-gray-700 hover:text-white'
                    }`}
                  >
                    {loc}
                  </button>
                ))}
               </div>
            </div>

            {/* Custom Location Input */}
            <div>
              <p className="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">
                Add Custom Location
              </p>
              <div className="flex gap-2">
                <Input
                  placeholder="e.g., London, Canada, Europe"
                  value={customLocation}
                  onChange={(e) => setCustomLocation(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      e.preventDefault();
                      addLocation(customLocation);
                    }
                  }}
                  className="bg-gray-800/50 border-gray-700 text-white placeholder-gray-500"
                />
                <Button 
                  onClick={() => addLocation(customLocation)} 
                  disabled={!customLocation.trim()} 
                  className="bg-green-600 hover:bg-green-500"
                >
                  <Plus className="w-4 h-4" />
                </Button>
              </div>
            </div>
          </div>

          {/* =======================
              MATCH SCORE SECTION 
             ======================= */}
          <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
            <div className="flex items-center gap-2 mb-2">
                <Sparkles className="w-5 h-5 text-yellow-500" />
                <h2 className="text-xl font-bold text-white">Match Score Threshold</h2>
            </div>
            <p className="text-gray-400 mb-6 text-sm">
              Only show jobs with at least this match score (higher = more selective).
            </p>
            
            <div className="flex items-center justify-between mb-4">
              <span className="text-sm font-medium text-gray-400">Minimum Score:</span>
              <span className="text-2xl font-bold text-blue-400">{minMatchScore}%</span>
            </div>
            <Slider
              value={[minMatchScore]}
              onValueChange={(value) => setMinMatchScore(value[0])}
              min={30}
              max={90}
              step={5}
              className="w-full"
            />
            <div className="flex justify-between text-xs text-gray-500 mt-2">
              <span>30% (More jobs)</span>
              <span>90% (Perfect matches only)</span>
            </div>
          </div>

          {/* =======================
              SAVE ACTIONS 
             ======================= */}
          <div className="flex gap-4 pt-4 sticky bottom-4 z-10">
            <Button
              onClick={handleSave}
              disabled={saving || keywords.length === 0}
              className="flex-1 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-6 rounded-xl shadow-lg shadow-purple-900/20"
            >
              {saving ? (
                <>
                  <Loader2 className="w-5 h-5 mr-2 animate-spin" />
                  Saving...
                </>
              ) : (
                <>
                  <Save className="w-5 h-5 mr-2" />
                  Save Preferences
                </>
              )}
            </Button>
            <Link href="/settings">
              <Button 
                variant="outline" 
                className="h-full bg-gray-800 border-gray-700 text-gray-300 hover:bg-gray-700 hover:text-white rounded-xl px-8"
              >
                Cancel
              </Button>
            </Link>
          </div>

          {/* Keyword Warning */}
          {keywords.length === 0 && (
            <div className="p-4 bg-yellow-500/10 border border-yellow-500/20 rounded-xl text-yellow-200 text-sm">
              âš ï¸ Please add at least one job keyword to start receiving matches
            </div>
          )}

        </div>
      </div>
    </div>
  );
}
===== ./src/app/settings/profile/page.tsx =====
"use client";

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import { useAuth } from '@/contexts/AuthContext';
import { db } from '@/lib/firebase';
import { doc, getDoc, setDoc } from 'firebase/firestore';
import { updateProfile } from 'firebase/auth';
import { 
  User, 
  Mail, 
  Phone, 
  Camera, 
  Save, 
  Loader2, 
  ArrowLeft,
  CheckCircle,
  Shield
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';

export default function ProfilePage() {
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);

  // Form State
  const [displayName, setDisplayName] = useState('');
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');
  const [photoURL, setPhotoURL] = useState('');

  // Load User Data
  useEffect(() => {
    async function loadProfile() {
      if (!user) return;

      // Set defaults from Auth
      setDisplayName(user.displayName || '');
      setEmail(user.email || '');
      setPhotoURL(user.photoURL || '');

      // Fetch extended data from Firestore (like phone)
      try {
        const docRef = doc(db, 'users', user.uid);
        const docSnap = await getDoc(docRef);
        if (docSnap.exists()) {
          const data = docSnap.data();
          if (data.phoneNumber) setPhone(data.phoneNumber);
        }
      } catch (error) {
        console.error("Error loading profile:", error);
      }
    }
    loadProfile();
  }, [user]);

  const handleSave = async () => {
    if (!user) return;
    setLoading(true);
    setSuccess(false);

    try {
      // 1. Update Firebase Auth Profile (Display Name)
      if (displayName !== user.displayName) {
        await updateProfile(user, { displayName });
      }

      // 2. Update Firestore Document (Phone, etc.)
      await setDoc(doc(db, 'users', user.uid), {
        displayName,
        email,
        phoneNumber: phone,
        updatedAt: new Date()
      }, { merge: true });

      setSuccess(true);
      
      // Reset success message after 3 seconds
      setTimeout(() => setSuccess(false), 3000);

    } catch (error) {
      console.error("Error updating profile:", error);
      alert("Failed to update profile.");
    } finally {
      setLoading(false);
    }
  };

  if (!user) {
    return (
      <div className="min-h-screen bg-[#0A0A0A] flex items-center justify-center">
        <Loader2 className="w-8 h-8 text-blue-500 animate-spin" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30">
      {/* --- Background Gradients --- */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 right-0 w-[500px] h-[500px] bg-purple-500/10 rounded-full blur-[120px]" />
        <div className="absolute bottom-0 left-0 w-[500px] h-[500px] bg-blue-500/10 rounded-full blur-[120px]" />
        <div className="absolute inset-0 opacity-10"
          style={{
            backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`,
            backgroundSize: '40px 40px'
          }}
        />
      </div>

      <div className="max-w-3xl mx-auto p-4 md:p-8 space-y-8">
        
        {/* Header */}
        <div>
          <Link href="/settings" className="inline-flex items-center text-sm text-gray-400 hover:text-white mb-4 transition-colors">
            <ArrowLeft className="w-4 h-4 mr-2" /> Back to Settings
          </Link>
          <h1 className="text-4xl font-black tracking-tight mb-2">
            <span className="bg-gradient-to-r from-white via-purple-200 to-blue-200 bg-clip-text text-transparent">
              Profile Information
            </span>
          </h1>
          <p className="text-gray-400 text-lg">Update your personal details and public profile.</p>
        </div>

        {/* Success Message */}
        {success && (
          <div className="p-4 bg-green-500/10 border border-green-500/20 rounded-xl flex items-center gap-3 animate-in fade-in slide-in-from-top-2">
            <CheckCircle className="w-5 h-5 text-green-400" />
            <span className="text-green-300 font-medium">Profile updated successfully!</span>
          </div>
        )}

        <div className="space-y-6">
          
          {/* Main Profile Card */}
          <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
            
            {/* Avatar Section */}
            <div className="flex items-center gap-6 mb-8 pb-8 border-b border-gray-800">
              <div className="relative group">
                <div className="w-24 h-24 rounded-full bg-gradient-to-br from-purple-600 to-blue-600 p-1">
                  <div className="w-full h-full rounded-full bg-gray-900 flex items-center justify-center overflow-hidden">
                    {photoURL ? (
                      <img src={photoURL} alt="Profile" className="w-full h-full object-cover" />
                    ) : (
                      <User className="w-10 h-10 text-gray-400" />
                    )}
                  </div>
                </div>
                <button className="absolute bottom-0 right-0 p-2 bg-blue-600 hover:bg-blue-500 text-white rounded-full shadow-lg transition-all transform hover:scale-110">
                  <Camera className="w-4 h-4" />
                </button>
              </div>
              <div>
                <h2 className="text-xl font-bold text-white">{displayName || 'User'}</h2>
                <p className="text-sm text-gray-400">Personal Account</p>
              </div>
            </div>

            {/* Form Fields */}
            <div className="space-y-6">
              
              {/* Full Name */}
              <div className="space-y-2">
                <Label className="text-gray-300 font-medium">Full Name</Label>
                <div className="relative">
                  <User className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
                  <Input 
                    value={displayName}
                    onChange={(e) => setDisplayName(e.target.value)}
                    className="bg-gray-800/50 border-gray-700 text-white pl-10 h-12 focus:border-blue-500"
                    placeholder="Enter your full name"
                  />
                </div>
              </div>

              {/* Email Address (Read Only) */}
              <div className="space-y-2">
                <Label className="text-gray-300 font-medium">Email Address</Label>
                <div className="relative opacity-70 cursor-not-allowed">
                  <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
                  <Input 
                    value={email}
                    disabled
                    className="bg-gray-800/30 border-gray-800 text-gray-400 pl-10 h-12"
                  />
                  <div className="absolute right-3 top-1/2 -translate-y-1/2">
                    <Shield className="w-4 h-4 text-green-500" />
                  </div>
                </div>
                <p className="text-xs text-gray-500 mt-1">Email cannot be changed manually for security reasons.</p>
              </div>

              {/* Phone Number */}
              <div className="space-y-2">
                <Label className="text-gray-300 font-medium">Phone Number</Label>
                <div className="relative">
                  <Phone className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
                  <Input 
                    value={phone}
                    onChange={(e) => setPhone(e.target.value)}
                    className="bg-gray-800/50 border-gray-700 text-white pl-10 h-12 focus:border-blue-500"
                    placeholder="+1 (555) 000-0000"
                  />
                </div>
              </div>

            </div>

            {/* Actions */}
            <div className="mt-8 pt-6 border-t border-gray-800 flex justify-end gap-4">
              <Link href="/settings">
                <Button variant="outline" className="bg-transparent border-gray-700 text-gray-300 hover:bg-gray-800 hover:text-white">
                  Cancel
                </Button>
              </Link>
              <Button 
                onClick={handleSave} 
                disabled={loading}
                className="bg-blue-600 hover:bg-blue-500 text-white px-8"
              >
                {loading ? (
                  <><Loader2 className="w-4 h-4 mr-2 animate-spin" /> Saving...</>
                ) : (
                  <><Save className="w-4 h-4 mr-2" /> Save Changes</>
                )}
              </Button>
            </div>

          </div>
        </div>
      </div>
    </div>
  );
}
===== ./src/app/settings/resume/page.tsx =====
"use client";

import React, { useState, useEffect } from 'react';
import { db, storage } from '@/lib/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { doc, setDoc, getDoc } from 'firebase/firestore';
import { useAuth } from '@/contexts/AuthContext';
import { 
  FileText, 
  Upload, 
  CheckCircle, 
  Loader2, 
  ArrowLeft, 
  Sparkles, 
  UploadCloud // FIXED: Changed from CloudUpload to UploadCloud
} from 'lucide-react';
import Link from 'next/link';

export default function ResumePage() {
  const { user } = useAuth();
  const [file, setFile] = useState<File | null>(null);
  const [uploading, setUploading] = useState(false);
  const [currentResume, setCurrentResume] = useState<string | null>(null);
  const [resumeName, setResumeName] = useState<string | null>(null);
  const [lastUpdated, setLastUpdated] = useState<any>(null);

  // Load existing resume
  useEffect(() => {
    async function fetchResume() {
      if (!user) return;
      try {
        const docRef = doc(db, 'users', user.uid);
        const docSnap = await getDoc(docRef);
        if (docSnap.exists() && docSnap.data().resumeUrl) {
          setCurrentResume(docSnap.data().resumeUrl);
          setResumeName(docSnap.data().resumeName || "Master Resume.pdf");
          setLastUpdated(docSnap.data().resumeUpdatedAt);
        }
      } catch (error) {
        console.error("Error fetching resume:", error);
      }
    }
    fetchResume();
  }, [user]);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setFile(e.target.files[0]);
    }
  };

  const handleUpload = async () => {
    if (!file || !user) return;
    setUploading(true);

    try {
      // 1. Upload to Firebase Storage
      const storageRef = ref(storage, `resumes/${user.uid}/${file.name}`);
      await uploadBytes(storageRef, file);
      const downloadURL = await getDownloadURL(storageRef);

      // 2. Save Link to Firestore User Profile
      await setDoc(doc(db, 'users', user.uid), {
        resumeUrl: downloadURL,
        resumeName: file.name,
        resumeUpdatedAt: new Date()
      }, { merge: true });

      setCurrentResume(downloadURL);
      setResumeName(file.name);
      setLastUpdated(new Date());
      setFile(null);

    } catch (error) {
      console.error("Error uploading resume:", error);
      alert("Failed to upload resume. Please try again.");
    } finally {
      setUploading(false);
    }
  };

  if (!user) {
    return (
      <div className="min-h-screen bg-[#0A0A0A] flex items-center justify-center">
        <Loader2 className="w-8 h-8 text-blue-500 animate-spin" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30">
      {/* --- Background Gradients --- */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 right-0 w-[500px] h-[500px] bg-pink-500/10 rounded-full blur-[120px]" />
        <div className="absolute bottom-0 left-0 w-[500px] h-[500px] bg-purple-500/10 rounded-full blur-[120px]" />
        <div className="absolute inset-0 opacity-10"
          style={{
            backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`,
            backgroundSize: '40px 40px'
          }}
        />
      </div>

      <div className="max-w-3xl mx-auto p-4 md:p-8 space-y-8">
        
        {/* Header */}
        <div>
          <Link href="/settings" className="inline-flex items-center text-sm text-gray-400 hover:text-white mb-4 transition-colors">
            <ArrowLeft className="w-4 h-4 mr-2" /> Back to Settings
          </Link>
          <div className="flex items-center gap-3 mb-2">
            <Sparkles className="w-8 h-8 text-pink-400" />
            <h1 className="text-4xl font-black tracking-tight">
              <span className="bg-gradient-to-r from-white via-pink-200 to-purple-200 bg-clip-text text-transparent">
                Resume & Documents
              </span>
            </h1>
          </div>
          <p className="text-gray-400 text-lg">Upload your master resume. Our AI will use this to tailor your applications.</p>
        </div>

        {/* Main Card */}
        <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 md:p-8">
          <div className="flex items-center gap-3 mb-6">
            <FileText className="w-5 h-5 text-pink-400" />
            <h2 className="text-xl font-bold text-white">Master Resume</h2>
          </div>

          <div className="space-y-6">
            
            {/* Current Resume Status */}
            {currentResume ? (
              <div className="bg-green-500/10 border border-green-500/20 rounded-2xl p-5 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
                <div className="flex items-center gap-4">
                  <div className="w-12 h-12 bg-green-500/20 rounded-xl flex items-center justify-center border border-green-500/30">
                    <FileText className="w-6 h-6 text-green-400" />
                  </div>
                  <div>
                    <p className="font-bold text-white text-lg">{resumeName}</p>
                    <p className="text-xs text-green-300/80 flex items-center gap-1.5 mt-1">
                      <CheckCircle className="w-3 h-3" />
                      Uploaded {lastUpdated ? new Date(lastUpdated.seconds * 1000).toLocaleDateString() : 'Just now'}
                    </p>
                  </div>
                </div>
                <Link href={currentResume} target="_blank">
                  <button className="px-4 py-2 bg-green-900/20 border border-green-500/30 text-green-300 hover:bg-green-500/20 hover:text-white rounded-xl font-medium transition-all">
                    View PDF
                  </button>
                </Link>
              </div>
            ) : (
              <div className="bg-gray-800/30 border border-dashed border-gray-700 rounded-2xl p-8 text-center hover:bg-gray-800/50 transition-colors">
                <div className="w-16 h-16 bg-gray-800 rounded-full flex items-center justify-center mx-auto mb-4 border border-gray-700">
                  <UploadCloud className="w-8 h-8 text-gray-400" /> {/* FIXED HERE */}
                </div>
                <p className="text-white font-semibold text-lg">No resume uploaded yet</p>
                <p className="text-sm text-gray-500 mt-1">Upload a PDF to get started with AI features</p>
              </div>
            )}

            {/* Upload Area */}
            <div className="pt-6 border-t border-gray-800">
              <label className="block text-sm font-medium text-gray-300 mb-3 uppercase tracking-wider">
                {currentResume ? 'Update Resume' : 'Upload New Resume'}
              </label>
              
              <div className="flex flex-col sm:flex-row gap-4">
                {/* Styled File Input */}
                <div className="relative flex-1">
                  <input 
                    type="file" 
                    accept=".pdf"
                    onChange={handleFileChange}
                    className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
                  />
                  <div className={`w-full h-12 bg-gray-800/50 border ${file ? 'border-pink-500/50 text-white' : 'border-gray-700 text-gray-400'} rounded-xl flex items-center px-4 transition-all`}>
                    {file ? (
                      <span className="flex items-center gap-2 truncate">
                        <FileText className="w-4 h-4 text-pink-400" />
                        {file.name}
                      </span>
                    ) : (
                      <span className="flex items-center gap-2">
                        <Upload className="w-4 h-4" />
                        Select PDF file...
                      </span>
                    )}
                  </div>
                </div>

                <button 
                  onClick={handleUpload} 
                  disabled={!file || uploading}
                  className="flex items-center justify-center gap-2 bg-pink-600 hover:bg-pink-500 text-white h-12 px-8 rounded-xl font-medium shadow-lg shadow-pink-900/20 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {uploading ? (
                    <>
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      Uploading...
                    </>
                  ) : (
                    <>
                      <Upload className="w-4 h-4" />
                      Upload
                    </>
                  )}
                </button>
              </div>
              <p className="text-xs text-gray-500 mt-2 ml-1">Supported format: PDF (Max 5MB)</p>
            </div>

          </div>
        </div>
      </div>
    </div>
  );
}
===== ./src/app/signup/page.tsx =====
import { redirect } from 'next/navigation';

export default function SignupPage() {
  redirect('/auth/signup');
}
===== ./src/components/AdminControls.tsx =====
// src/components/AdminControls.tsx - FIXED VERSION
'use client';

import { useState } from 'react';
import { triggerJobScraper, syncJobs } from '@/app/actions/admin-actions';

export function AdminControls() {
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  const handleTriggerScraper = async () => {
    try {
      setLoading(true);
      setError(null);
      setMessage(null);

      // ðŸ”’ SECURITY FIX: Use server action instead of client-side secret
      const result = await triggerJobScraper();

      if (result.success) {
        setMessage('âœ… Job scraper triggered successfully!');
      } else {
        setError(result.error || 'Failed to trigger scraper');
      }
    } catch (err: any) {
      setError(err.message || 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  const handleSyncJobs = async () => {
    try {
      setLoading(true);
      setError(null);
      setMessage(null);

      // ðŸ”’ SECURITY FIX: Use server action
      const result = await syncJobs();

      if (result.success) {
        setMessage('âœ… Jobs synced successfully!');
      } else {
        setError(result.error || 'Failed to sync jobs');
      }
    } catch (err: any) {
      setError(err.message || 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="p-4 bg-white rounded-lg shadow">
      <h2 className="text-xl font-bold mb-4">Admin Controls</h2>
      
      <div className="space-y-4">
        <div>
          <button
            onClick={handleTriggerScraper}
            disabled={loading}
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
          >
            {loading ? 'Triggering...' : 'Trigger Job Scraper'}
          </button>
        </div>

        <div>
          <button
            onClick={handleSyncJobs}
            disabled={loading}
            className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50"
          >
            {loading ? 'Syncing...' : 'Sync Jobs'}
          </button>
        </div>

        {message && (
          <div className="p-3 bg-green-100 text-green-800 rounded">
            {message}
          </div>
        )}

        {error && (
          <div className="p-3 bg-red-100 text-red-800 rounded">
            {error}
          </div>
        )}
      </div>
    </div>
  );
}
===== ./src/components/AnalyticsDashboard.tsx =====
// components/AnalyticsDashboard.tsx
'use client';

import React, { useEffect, useState } from 'react';
import { db } from '@/lib/firebase';
import { collection, query, orderBy, limit, getDocs } from 'firebase/firestore';
import { TrendingUp, DollarSign, MapPin, Users, Briefcase, Globe, Zap, ArrowUpRight } from 'lucide-react';
// NEW IMPORTS FOR CHARTS
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts';

interface AnalyticsData {
  id: string;
  timestamp: any;
  total_jobs_analyzed: number;
  remote_count: number;
  top_companies: Array<{
    company: string;
    total_jobs: number;
    avg_salary: number;
    remote_ratio: number;
  }>;
  top_roles: Array<{
    role: string;
    count: number;
    avg_salary: number;
    company_count: number;
  }>;
  top_locations: Array<{ location: string; count: number }>;
  salary_insights: {
    highest_paying_companies: Array<{ company: string; avg_salary: number }>;
    salary_distribution: Record<string, number>;
  };
}

// Chart Colors
const COLORS = ['#3B82F6', '#10B981', '#8B5CF6', '#F59E0B', '#EC4899', '#6366F1'];

export default function AnalyticsDashboard() {
  const [analytics, setAnalytics] = useState<AnalyticsData | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadAnalytics() {
      try {
        const q = query(
          collection(db, 'market_analytics'),
          orderBy('timestamp', 'desc'),
          limit(1)
        );
        
        const snapshot = await getDocs(q);
        if (!snapshot.empty) {
          const doc = snapshot.docs[0];
          setAnalytics({
            id: doc.id,
            ...doc.data()
          } as AnalyticsData);
        }
      } catch (error) {
        console.error('Error loading analytics:', error);
      } finally {
        setLoading(false);
      }
    }

    loadAnalytics();
  }, []);

  if (loading) {
    return (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 animate-pulse">
            {[...Array(4)].map((_, i) => (
                <div key={i} className="h-32 bg-gray-900/50 rounded-2xl border border-white/5" />
            ))}
        </div>
    );
  }

  if (!analytics) return null;

  // Prepare Data for Charts
  const roleData = analytics.top_roles.slice(0, 5).map(r => ({
      name: r.role,
      value: r.count
  }));

  return (
    <div className="space-y-8 animate-in fade-in slide-in-from-bottom-4 duration-700">
      
      {/* 1. HERO STATS (Bento Grid Style) */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {/* ... (Keep your existing Hero Stats cards here) ... */}
        {/* Total Jobs */}
        <div className="group relative overflow-hidden p-6 bg-[#0F0F10] rounded-3xl border border-white/5 hover:border-blue-500/30 transition-all duration-300">
          <div className="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
            <Briefcase className="w-24 h-24 text-blue-500 -mr-4 -mt-4 rotate-12" />
          </div>
          <div className="relative z-10">
            <div className="flex items-center gap-2 text-blue-400 mb-2">
              <Briefcase className="w-4 h-4" />
              <span className="text-xs font-bold uppercase tracking-wider">Market Depth</span>
            </div>
            <p className="text-4xl font-black text-white tracking-tight">
              {analytics.total_jobs_analyzed.toLocaleString()}
            </p>
            <p className="text-sm text-gray-500 mt-1">Active roles scanned</p>
          </div>
        </div>

        {/* Remote Ratio */}
        <div className="group relative overflow-hidden p-6 bg-[#0F0F10] rounded-3xl border border-white/5 hover:border-emerald-500/30 transition-all duration-300">
          <div className="absolute inset-0 bg-gradient-to-br from-emerald-500/5 to-transparent opacity-0 group-hover:opacity-100 transition-opacity" />
          <div className="relative z-10">
            <div className="flex items-center gap-2 text-emerald-400 mb-2">
              <Globe className="w-4 h-4" />
              <span className="text-xs font-bold uppercase tracking-wider">Remote Access</span>
            </div>
            <div className="flex items-baseline gap-2">
                <p className="text-4xl font-black text-white tracking-tight">
                {analytics.remote_count.toLocaleString()}
                </p>
                <span className="text-sm font-bold text-emerald-500 bg-emerald-500/10 px-2 py-0.5 rounded-full">
                    {((analytics.remote_count / analytics.total_jobs_analyzed) * 100).toFixed(0)}%
                </span>
            </div>
            <p className="text-sm text-gray-500 mt-1">Work from anywhere</p>
          </div>
        </div>

        {/* Avg Salary */}
        <div className="group relative overflow-hidden p-6 bg-[#0F0F10] rounded-3xl border border-white/5 hover:border-purple-500/30 transition-all duration-300">
           <div className="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
            <DollarSign className="w-24 h-24 text-purple-500 -mr-4 -mt-4 rotate-12" />
          </div>
          <div className="relative z-10">
            <div className="flex items-center gap-2 text-purple-400 mb-2">
              <DollarSign className="w-4 h-4" />
              <span className="text-xs font-bold uppercase tracking-wider">Market Rate</span>
            </div>
            <p className="text-4xl font-black text-white tracking-tight">
              ${(analytics.top_roles.reduce((sum, role) => sum + role.avg_salary, 0) / Math.max(analytics.top_roles.length, 1) / 1000).toFixed(0)}k
            </p>
            <p className="text-sm text-gray-500 mt-1">Average annual comp</p>
          </div>
        </div>

        {/* Companies Tracking */}
        <div className="group relative overflow-hidden p-6 bg-[#0F0F10] rounded-3xl border border-white/5 hover:border-amber-500/30 transition-all duration-300">
          <div className="absolute inset-0 bg-gradient-to-br from-amber-500/5 to-transparent opacity-0 group-hover:opacity-100 transition-opacity" />
          <div className="relative z-10">
            <div className="flex items-center gap-2 text-amber-400 mb-2">
              <TrendingUp className="w-4 h-4" />
              <span className="text-xs font-bold uppercase tracking-wider">Coverage</span>
            </div>
            <p className="text-4xl font-black text-white tracking-tight">
              {analytics.top_companies.length}+
            </p>
            <p className="text-sm text-gray-500 mt-1">Top tier tech companies</p>
          </div>
        </div>
      </div>

      {/* 2. LEADERBOARDS & PIE CHART */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        
        {/* Top Hiring (Takes up 1 column) */}
        <div className="lg:col-span-1 bg-[#0F0F10] border border-white/5 rounded-3xl p-6 relative overflow-hidden">
            <div className="flex items-center justify-between mb-6">
                <h3 className="text-lg font-bold text-white flex items-center gap-2">
                    <Users className="w-5 h-5 text-blue-500" />
                    Top Hiring
                </h3>
            </div>
            <div className="space-y-3">
                {analytics.top_companies.slice(0, 5).map((company, i) => (
                    <div key={company.company} className="flex items-center justify-between p-3 rounded-xl bg-white/5 hover:bg-white/10 transition-colors">
                        <div className="flex items-center gap-3">
                            <span className="text-xs font-bold text-gray-500">#{i + 1}</span>
                            <span className="font-bold text-gray-200">{company.company}</span>
                        </div>
                        <span className="text-sm font-bold text-blue-400">{company.total_jobs}</span>
                    </div>
                ))}
            </div>
        </div>

        {/* PIE CHART SECTION (New!) */}
        <div className="lg:col-span-2 bg-[#0F0F10] border border-white/5 rounded-3xl p-6 relative overflow-hidden">
            <div className="flex items-center justify-between mb-2">
                <h3 className="text-lg font-bold text-white flex items-center gap-2">
                    <Briefcase className="w-5 h-5 text-purple-500" />
                    Role Distribution
                </h3>
            </div>
            
            <div className="flex flex-col md:flex-row items-center h-64">
                {/* Chart */}
                <div className="w-full md:w-1/2 h-full">
                    <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                            <Pie
                                data={roleData}
                                cx="50%"
                                cy="50%"
                                innerRadius={60}
                                outerRadius={80}
                                paddingAngle={5}
                                dataKey="value"
                            >
                                {roleData.map((entry, index) => (
                                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                ))}
                            </Pie>
                            <Tooltip 
                                contentStyle={{ backgroundColor: '#1f2937', borderColor: '#374151', borderRadius: '8px' }}
                                itemStyle={{ color: '#fff' }}
                            />
                        </PieChart>
                    </ResponsiveContainer>
                </div>

                {/* Legend */}
                <div className="w-full md:w-1/2 grid grid-cols-2 gap-4 pl-4">
                    {roleData.map((entry, index) => (
                        <div key={entry.name} className="flex items-center gap-2">
                            <div className="w-3 h-3 rounded-full" style={{ backgroundColor: COLORS[index % COLORS.length] }} />
                            <div>
                                <p className="text-sm font-bold text-white capitalize">{entry.name}</p>
                                <p className="text-xs text-gray-500">{entry.value} jobs</p>
                            </div>
                        </div>
                    ))}
                </div>
            </div>
        </div>

      </div>

      {/* 3. ROLES & LOCATIONS */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
         {/* Highest Paying */}
         <div className="bg-[#0F0F10] border border-white/5 rounded-3xl p-6">
            <h3 className="text-lg font-bold text-white mb-6 flex items-center gap-2">
                <Zap className="w-5 h-5 text-yellow-500" /> Highest Paying
            </h3>
            <div className="space-y-3">
                {analytics.salary_insights.highest_paying_companies.slice(0, 5).map((company, i) => (
                    <div key={company.company} className="flex items-center justify-between p-3 rounded-xl bg-white/5">
                        <span className="font-bold text-gray-200">{company.company}</span>
                        <span className="text-sm font-bold text-green-400">${(company.avg_salary / 1000).toFixed(0)}k</span>
                    </div>
                ))}
            </div>
         </div>

         {/* Locations */}
         <div className="bg-[#0F0F10] border border-white/5 rounded-3xl p-6">
            <h3 className="text-lg font-bold text-white mb-6 flex items-center gap-2">
                <MapPin className="w-5 h-5 text-blue-500" /> Top Hubs
            </h3>
            <div className="flex flex-wrap gap-2">
                {analytics.top_locations.slice(0, 8).map((loc) => (
                    <div key={loc.location} className="px-3 py-1.5 rounded-lg bg-gray-900 border border-white/10 flex items-center gap-2">
                        <span className="text-sm font-medium text-gray-300 capitalize">{loc.location}</span>
                        <span className="text-xs font-bold text-blue-400 bg-blue-500/10 px-1.5 rounded">{loc.count}</span>
                    </div>
                ))}
            </div>
         </div>
      </div>
    </div>
  );
}
===== ./src/components/ApplicationStatusTracker.tsx =====
import React, { useState, useEffect } from 'react';
import { Loader2, CheckCircle, XCircle, AlertCircle, Clock, ExternalLink } from 'lucide-react';
import { doc, onSnapshot } from 'firebase/firestore';
import { db } from '@/lib/firebase';

interface ApplicationStatusTrackerProps {
  applicationId: string;
  onComplete?: (finalStatus: string) => void;
  showDetails?: boolean;
}

interface ApplicationStatus {
  status: 'queued' | 'processing' | 'review_required' | 'applied' | 'failed' | 'cancelled';
  progress: number;
  progressMessage: string;
  lastUpdated: Date;
  details?: string;
  applicationUrl?: string;
}

const ApplicationStatusTracker: React.FC<ApplicationStatusTrackerProps> = ({ 
  applicationId, 
  onComplete,
  showDetails = true
}) => {
  const [status, setStatus] = useState<ApplicationStatus>({
    status: 'queued',
    progress: 0,
    progressMessage: 'Application queued...',
    lastUpdated: new Date()
  });

  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!applicationId) {
      setIsLoading(false);
      setError('No application ID provided');
      return;
    }

    setIsLoading(true);

    // Real-time listener to Firestore
    const unsubscribe = onSnapshot(
      doc(db, 'applications', applicationId),
      (docSnapshot) => {
        setIsLoading(false);
        
        if (docSnapshot.exists()) {
          const data = docSnapshot.data();
          
          // Map Firestore data to local state
          const newStatus = data.status || 'queued';
          
          setStatus({
            status: newStatus,
            progress: data.progress || 0,
            progressMessage: data.progressMessage || 'Processing...',
            lastUpdated: data.lastUpdated?.toDate() || new Date(),
            details: data.notes || data.details, // Flexible mapping
            applicationUrl: data.jobUrl // Or data.applicationUrl if you save it specifically
          });

          // Trigger completion callback if finished
          if (newStatus === 'applied' || newStatus === 'failed') {
             // Small delay to allow the user to see the 100% state
             setTimeout(() => {
                onComplete?.(newStatus);
             }, 2000);
          }
        } else {
          setError('Application record not found');
        }
      },
      (err) => {
        console.error("Error fetching application status:", err);
        setError('Failed to sync with application service');
        setIsLoading(false);
      }
    );

    // Cleanup listener on unmount
    return () => unsubscribe();
  }, [applicationId, onComplete]);

  const getStatusIcon = () => {
    switch (status.status) {
      case 'processing':
        return <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />;
      case 'review_required':
        return <AlertCircle className="w-8 h-8 text-amber-600 animate-pulse" />;
      case 'applied':
        return <CheckCircle className="w-8 h-8 text-green-600" />;
      case 'failed':
        return <XCircle className="w-8 h-8 text-red-600" />;
      case 'cancelled':
        return <XCircle className="w-8 h-8 text-gray-400" />;
      default:
        return <Clock className="w-8 h-8 text-gray-400" />;
    }
  };

  const getStatusColor = () => {
    switch (status.status) {
      case 'processing':
        return 'bg-gradient-to-r from-blue-50 to-blue-100 border-blue-200';
      case 'review_required':
        return 'bg-gradient-to-r from-amber-50 to-amber-100 border-amber-200';
      case 'applied':
        return 'bg-gradient-to-r from-green-50 to-emerald-100 border-green-200';
      case 'failed':
        return 'bg-gradient-to-r from-red-50 to-red-100 border-red-200';
      case 'cancelled':
        return 'bg-gradient-to-r from-gray-50 to-gray-100 border-gray-200';
      default:
        return 'bg-gradient-to-r from-gray-50 to-blue-50 border-gray-200';
    }
  };

  const getStatusTitle = () => {
    switch (status.status) {
      case 'processing':
        return 'Auto-Apply in Progress';
      case 'review_required':
        return 'Manual Review Required';
      case 'applied':
        return 'Application Submitted!';
      case 'failed':
        return 'Application Failed';
      case 'cancelled':
        return 'Application Cancelled';
      default:
        return 'Queued for Processing';
    }
  };

  const getEstimatedTime = () => {
    if (status.status === 'applied') return 'Completed';
    if (status.status === 'failed' || status.status === 'cancelled') return 'N/A';
    
    // Simple estimation logic based on progress
    const remaining = 100 - status.progress;
    const estimatedMinutes = Math.ceil(remaining / 20); // Rough estimate (5 mins total)
    return estimatedMinutes < 1 ? '< 1 min remaining' : `~${estimatedMinutes} min remaining`;
  };

  if (isLoading) {
    return (
      <div className="bg-gradient-to-r from-gray-50 to-blue-50 border-2 border-gray-200 rounded-2xl p-8 shadow-sm">
        <div className="flex items-center justify-center gap-4">
          <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
          <div>
            <p className="text-lg font-semibold text-gray-900">Connecting to application service...</p>
            <p className="text-sm text-gray-600">Syncing status</p>
          </div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-gradient-to-r from-red-50 to-red-100 border-2 border-red-200 rounded-2xl p-8 shadow-sm">
        <div className="flex items-center gap-4">
          <XCircle className="w-8 h-8 text-red-600" />
          <div>
            <p className="text-lg font-semibold text-red-900">Error Loading Application</p>
            <p className="text-sm text-red-700">{error}</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`border-2 rounded-2xl p-8 shadow-lg transition-all duration-300 ${getStatusColor()}`}>
      <div className="flex flex-col md:flex-row items-start gap-6">
        <div className="flex-shrink-0">
          <div className="relative">
            {getStatusIcon()}
            {status.status === 'processing' && (
              <div className="absolute -top-1 -right-1 w-4 h-4 bg-blue-500 rounded-full animate-ping" />
            )}
          </div>
        </div>
        
        <div className="flex-1 min-w-0">
          <div className="flex flex-col md:flex-row md:items-center justify-between gap-4 mb-6">
            <div>
              <h3 className="text-2xl font-bold text-gray-900 mb-2">
                {getStatusTitle()}
              </h3>
              
              <p className="text-gray-700 text-lg font-medium mb-1">
                {status.progressMessage}
              </p>
              
              {status.details && showDetails && (
                <p className="text-gray-600 text-sm">
                  {status.details}
                </p>
              )}
            </div>
            
            <div className="text-right">
              <div className="text-sm font-medium text-gray-500 mb-1">Estimated Time</div>
              <div className="text-lg font-bold text-gray-900">{getEstimatedTime()}</div>
            </div>
          </div>
          
          {/* Progress Bar */}
          {(status.status === 'processing' || status.status === 'queued') && (
            <div className="mb-8">
              <div className="flex items-center justify-between text-sm font-medium text-gray-700 mb-3">
                <span>Auto-Apply Progress</span>
                <span className="font-bold text-blue-700">{Math.round(status.progress)}%</span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-4 overflow-hidden shadow-inner">
                <div
                  className="bg-gradient-to-r from-blue-500 to-blue-600 h-full transition-all duration-500 ease-out rounded-full relative"
                  style={{ width: `${status.progress}%` }}
                >
                  <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shimmer" />
                </div>
              </div>
              <div className="flex justify-between text-xs text-gray-500 mt-2">
                <span>Queued</span>
                <span>Processing</span>
                <span>Review</span>
                <span>Complete</span>
              </div>
            </div>
          )}
          
          {/* Status-specific content */}
          <div className="space-y-4">
            {status.status === 'review_required' && (
              <div className="bg-gradient-to-r from-amber-100 to-amber-50 border border-amber-300 rounded-xl p-5">
                <div className="flex items-start gap-3">
                  <AlertCircle className="w-6 h-6 text-amber-600 flex-shrink-0 mt-0.5" />
                  <div>
                    <h4 className="font-semibold text-amber-900 mb-2">Manual Review Required</h4>
                    <p className="text-amber-800 text-sm mb-3">
                      Your application has been prepared but requires your review before submission. 
                      Please check the automation window to verify details and submit manually.
                    </p>
                  </div>
                </div>
              </div>
            )}
            
            {status.status === 'applied' && (
              <div className="bg-gradient-to-r from-green-100 to-emerald-50 border border-green-300 rounded-xl p-5">
                <div className="flex items-start gap-3">
                  <CheckCircle className="w-6 h-6 text-green-600 flex-shrink-0 mt-0.5" />
                  <div>
                    <h4 className="font-semibold text-green-900 mb-2">Application Submitted Successfully!</h4>
                    <p className="text-green-800 text-sm mb-3">
                      Your application has been submitted to {status.applicationUrl ? 'the company portal' : 'the employer'}. 
                      You should receive a confirmation email shortly.
                    </p>
                    {status.applicationUrl && (
                      <button 
                        className="inline-flex items-center gap-2 px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-lg hover:bg-green-700 transition-colors"
                        onClick={() => window.open(status.applicationUrl, '_blank')}
                      >
                        <ExternalLink className="w-4 h-4" />
                        View Application Status
                      </button>
                    )}
                  </div>
                </div>
              </div>
            )}
            
            {status.status === 'failed' && (
              <div className="bg-gradient-to-r from-red-100 to-red-50 border border-red-300 rounded-xl p-5">
                <div className="flex items-start gap-3">
                  <XCircle className="w-6 h-6 text-red-600 flex-shrink-0 mt-0.5" />
                  <div>
                    <h4 className="font-semibold text-red-900 mb-2">Application Failed</h4>
                    <p className="text-red-800 text-sm mb-3">
                      {status.details || 'There was an error submitting your application.'}
                    </p>
                    <div className="flex gap-3">
                      <button 
                        className="px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-lg hover:bg-red-700 transition-colors"
                        onClick={() => window.location.reload()}
                      >
                        Try Again
                      </button>
                      <button 
                        className="px-4 py-2 bg-gray-600 text-white text-sm font-medium rounded-lg hover:bg-gray-700 transition-colors"
                        onClick={() => onComplete?.('failed')}
                      >
                        Apply Manually
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
          
          {/* Timeline / Last Updated */}
          <div className="mt-8 pt-6 border-t border-gray-200">
            <div className="flex items-center justify-between text-sm text-gray-500">
              <span className="flex items-center gap-2">
                <Clock className="w-4 h-4" />
                Last updated: {status.lastUpdated.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
              </span>
              <span className="font-medium">
                ID: <span className="font-mono text-gray-700">{applicationId.slice(0, 8)}...</span>
              </span>
            </div>
          </div>
        </div>
      </div>
      
      {/* CSS for shimmer animation */}
      <style jsx>{`
        @keyframes shimmer {
          0% { transform: translateX(-100%); }
          100% { transform: translateX(100%); }
        }
        .animate-shimmer {
          animation: shimmer 2s infinite;
        }
      `}</style>
    </div>
  );
};

export default ApplicationStatusTracker;
===== ./src/components/Navigation.tsx =====
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { useAuth } from '@/contexts/AuthContext';
import { Button } from '@/components/ui/button';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  Briefcase,
  Sparkles,
  Settings,
  LogOut,
  User,
  CreditCard,
  Home
} from 'lucide-react';

export function Navigation() {
  const { user, userProfile, signOut } = useAuth();
  const pathname = usePathname();

  const isPublicRoute = ['/', '/login', '/signup', '/pricing'].includes(pathname);
  const isHomePage = pathname === '/';

  // 1. PUBLIC VIEW (Logged Out) - THE NEW GLASS DESIGN
  if (isPublicRoute && !user) {
    return (
      <nav className={`fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${
        isHomePage 
          ? 'bg-transparent backdrop-blur-none border-b border-transparent pt-6' 
          : 'bg-black/80 backdrop-blur-xl border-b border-white/10'
      }`}>
        <div className="max-w-[1600px] mx-auto px-6 h-16 flex items-center justify-between">
          {/* Logo */}
          <Link href="/" className="flex items-center gap-2 group">
            <div className="h-8 w-8 bg-gradient-to-br from-blue-600 to-purple-600 rounded-lg flex items-center justify-center shadow-lg shadow-purple-500/20 group-hover:scale-110 transition-transform">
              <Sparkles className="h-5 w-5 text-white" />
            </div>
            <span className="font-bold text-xl tracking-tight text-white">JobHunt AI</span>
          </Link>

          {/* Links */}
          <div className="flex items-center gap-6">
            <Link href="/login" className="text-sm font-medium text-gray-400 hover:text-white transition-colors">
              Log in
            </Link>
            <Link href="/signup">
              <Button size="sm" className="bg-white text-black hover:bg-gray-200 rounded-full px-6 transition-transform hover:scale-105 active:scale-95">
                Get Started
              </Button>
            </Link>
          </div>
        </div>
      </nav>
    );
  }

  // 2. LOGGED IN VIEW - DASHBOARD NAVIGATION
  if (!user) return null;

  const navigation = [
    { name: 'Dashboard', href: '/dashboard', icon: Home },
    { name: 'Jobs', href: '/jobs', icon: Briefcase },
    { name: 'AI Assistant', href: '/assistant', icon: Sparkles },
  ];

  return (
    <nav className="border-b bg-white/50 backdrop-blur-xl sticky top-0 z-50">
      <div className="max-w-7xl mx-auto px-6 py-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-8">
            <Link href="/dashboard" className="flex items-center gap-2">
              <Sparkles className="h-8 w-8 text-blue-600" />
              <span className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                JobHunt AI
              </span>
            </Link>

            <div className="hidden md:flex items-center gap-1">
              {navigation.map((item) => {
                const Icon = item.icon;
                const isActive = pathname === item.href;

                return (
                  <Link key={item.name} href={item.href}>
                    <Button
                      variant={isActive ? 'secondary' : 'ghost'}
                      className="gap-2"
                    >
                      <Icon className="h-4 w-4" />
                      {item.name}
                    </Button>
                  </Link>
                );
              })}
            </div>
          </div>

          <div className="flex items-center gap-4">
            {userProfile?.tier === 'free' && (
              <Link href="/pricing">
                <Button size="sm" className="bg-gradient-to-r from-blue-600 to-purple-600">
                  Upgrade to Pro
                </Button>
              </Link>
            )}

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" className="relative h-10 w-10 rounded-full">
                  <Avatar>
                    <AvatarImage src={user.photoURL || undefined} alt={user.displayName || ''} />
                    <AvatarFallback className="bg-blue-100 text-blue-600">
                      {user.displayName?.charAt(0) || user.email?.charAt(0) || 'U'}
                    </AvatarFallback>
                  </Avatar>
                </Button>
              </DropdownMenuTrigger>

              <DropdownMenuContent className="w-56" align="end">
                <DropdownMenuLabel>
                  <div className="flex flex-col space-y-1">
                    <p className="text-sm font-medium">{user.displayName || 'User'}</p>
                    <p className="text-xs text-muted-foreground">{user.email}</p>
                    <p className="text-xs text-blue-600 font-medium uppercase">
                      {userProfile?.tier || 'Free'} Plan
                    </p>
                  </div>
                </DropdownMenuLabel>

                <DropdownMenuSeparator />

                <Link href="/dashboard">
                  <DropdownMenuItem className="cursor-pointer">
                    <Home className="mr-2 h-4 w-4" />
                    Dashboard
                  </DropdownMenuItem>
                </Link>

                <Link href="/settings">
                  <DropdownMenuItem className="cursor-pointer">
                    <Settings className="mr-2 h-4 w-4" />
                    Settings
                  </DropdownMenuItem>
                </Link>

                <Link href="/settings/billing">
                  <DropdownMenuItem className="cursor-pointer">
                    <CreditCard className="mr-2 h-4 w-4" />
                    Billing
                  </DropdownMenuItem>
                </Link>

                <DropdownMenuSeparator />

                <DropdownMenuItem
                  className="cursor-pointer text-red-600 focus:text-red-600"
                  onClick={() => signOut()}
                >
                  <LogOut className="mr-2 h-4 w-4" />
                  Log Out
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </div>
    </nav>
  );
}
===== ./src/components/PremiumDashboard2026.tsx =====
"use client";

import React, { useState, useMemo } from 'react';
import { Target, Briefcase, TrendingUp, Sparkles, ExternalLink, Building2, MapPin, Calendar, Zap, Filter, Search } from 'lucide-react';

export default function PremiumDashboard2026() {
  const [activeFilter, setActiveFilter] = useState('all');
  const [searchQuery, setSearchQuery] = useState('');
  
  const stats = {
    matches: 2199,
    applications: 34,
    interviews: 0,
    responseRate: 20
  };
  
  const jobs = [
    {
      id: 1,
      title: 'Staff Product Manager, Seller Experience',
      company: 'Stripe',
      location: 'San Francisco, Remote',
      score: 95,
      salary: '$200k - $280k',
      posted: '2d ago',
      tags: ['Product Strategy', 'B2B SaaS', 'Payments'],
      tier: 'S',
      type: 'new'
    },
    {
      id: 2,
      title: 'Senior Product Manager, AI Platform',
      company: 'Anthropic',
      location: 'Remote',
      score: 92,
      salary: '$180k - $260k',
      posted: '1d ago',
      tags: ['AI/ML', 'Platform', 'Enterprise'],
      tier: 'S',
      type: 'saved'
    },
    {
      id: 3,
      title: 'Principal Product Manager',
      company: 'Databricks',
      location: 'San Francisco, Hybrid',
      score: 88,
      salary: '$220k - $320k',
      posted: '3d ago',
      tags: ['Data Platform', 'Enterprise', 'Technical'],
      tier: 'A',
      type: 'new'
    }
  ];

  // Logic: Filter jobs based on Tab selection AND Search input
  const filteredJobs = useMemo(() => {
    return jobs.filter(job => {
      const matchesFilter = activeFilter === 'all' ? true : job.type === activeFilter;
      const matchesSearch = job.title.toLowerCase().includes(searchQuery.toLowerCase()) || 
                            job.company.toLowerCase().includes(searchQuery.toLowerCase());
      return matchesFilter && matchesSearch;
    });
  }, [activeFilter, searchQuery, jobs]);

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30">
      {/* Animated Background Gradients */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-blue-500/20 rounded-full blur-[120px] animate-pulse"></div>
        <div className="absolute top-1/3 right-1/4 w-96 h-96 bg-purple-500/20 rounded-full blur-[120px] animate-pulse animation-delay-2000"></div>
        <div className="absolute bottom-0 left-1/3 w-96 h-96 bg-pink-500/20 rounded-full blur-[120px] animate-pulse animation-delay-4000"></div>
        
        {/* Grid Pattern */}
        <div 
          className="absolute inset-0 opacity-10"
          style={{
            backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`,
            backgroundSize: '40px 40px'
          }}
        />
      </div>

      <div className="max-w-7xl mx-auto p-4 md:p-8 space-y-8">
        {/* Premium Header - Responsive Flex */}
        <div className="flex flex-col md:flex-row md:items-center justify-between gap-6">
          <div>
            <div className="flex items-center gap-3 mb-2">
              <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
              <span className="text-sm text-gray-400 font-mono">LIVE TRACKING</span>
            </div>
            <h1 className="text-4xl md:text-5xl font-black tracking-tight mb-2">
              <span className="bg-gradient-to-r from-white via-blue-200 to-purple-300 bg-clip-text text-transparent">
                Welcome back, Chandra
              </span>
            </h1>
            <p className="text-gray-400 text-lg">Your AI-powered job search command center</p>
          </div>
          
          <button className="group relative px-6 py-3 bg-gradient-to-r from-blue-600 to-purple-600 rounded-2xl font-semibold hover:scale-105 transition-transform duration-300 overflow-hidden w-full md:w-auto">
            <div className="absolute inset-0 bg-gradient-to-r from-blue-400 to-purple-400 opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
            <span className="relative flex items-center justify-center gap-2">
              <Sparkles className="w-5 h-5" />
              Upgrade to Pro
            </span>
          </button>
        </div>

        {/* Premium Stats Cards - Fixed Responsiveness */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {/* New Matches Card */}
          <div className="group relative cursor-pointer">
            <div className="absolute inset-0 bg-gradient-to-br from-blue-500/20 to-cyan-500/20 rounded-3xl blur-xl group-hover:blur-2xl transition-all duration-500"></div>
            <div className="relative bg-gradient-to-br from-blue-500/10 to-cyan-500/10 backdrop-blur-xl border border-blue-500/20 rounded-3xl p-8 hover:border-blue-400/40 transition-all duration-300 hover:scale-[1.02]">
              <div className="flex items-start justify-between mb-6">
                <div className="p-3 bg-blue-500/20 rounded-2xl">
                  <Target className="w-6 h-6 text-blue-400" />
                </div>
                <ExternalLink className="w-4 h-4 text-gray-500 opacity-0 group-hover:opacity-100 transition-opacity" />
              </div>
              
              <div className="space-y-2">
                <div className="text-sm text-gray-400 font-medium">New Matches</div>
                <div className="text-5xl font-black tracking-tight">{stats.matches}</div>
                <div className="flex items-center gap-2 text-sm">
                  <div className="px-2 py-1 bg-green-500/20 text-green-400 rounded-lg font-medium">
                    +20 this week
                  </div>
                </div>
              </div>
              
              <div className="mt-6 h-2 bg-gray-800 rounded-full overflow-hidden">
                <div className="h-full w-3/4 bg-gradient-to-r from-blue-500 to-cyan-400 rounded-full"></div>
              </div>
            </div>
          </div>

          {/* Applications Card */}
          <div className="group relative cursor-pointer">
            <div className="absolute inset-0 bg-gradient-to-br from-green-500/20 to-emerald-500/20 rounded-3xl blur-xl group-hover:blur-2xl transition-all duration-500"></div>
            <div className="relative bg-gradient-to-br from-green-500/10 to-emerald-500/10 backdrop-blur-xl border border-green-500/20 rounded-3xl p-8 hover:border-green-400/40 transition-all duration-300 hover:scale-[1.02]">
              <div className="flex items-start justify-between mb-6">
                <div className="p-3 bg-green-500/20 rounded-2xl">
                  <Briefcase className="w-6 h-6 text-green-400" />
                </div>
                <ExternalLink className="w-4 h-4 text-gray-500 opacity-0 group-hover:opacity-100 transition-opacity" />
              </div>
              
              <div className="space-y-2">
                <div className="text-sm text-gray-400 font-medium">Applications</div>
                <div className="text-5xl font-black tracking-tight">{stats.applications}</div>
                <div className="flex items-center gap-2 text-sm">
                  <div className="px-2 py-1 bg-blue-500/20 text-blue-400 rounded-lg font-medium">
                    {stats.responseRate}% response
                  </div>
                </div>
              </div>
              
              <div className="mt-6 h-2 bg-gray-800 rounded-full overflow-hidden">
                <div className="h-full w-1/2 bg-gradient-to-r from-green-500 to-emerald-400 rounded-full"></div>
              </div>
            </div>
          </div>

          {/* Interviews Card */}
          <div className="group relative cursor-pointer">
            <div className="absolute inset-0 bg-gradient-to-br from-purple-500/20 to-pink-500/20 rounded-3xl blur-xl group-hover:blur-2xl transition-all duration-500"></div>
            <div className="relative bg-gradient-to-br from-purple-500/10 to-pink-500/10 backdrop-blur-xl border border-purple-500/20 rounded-3xl p-8 hover:border-purple-400/40 transition-all duration-300 hover:scale-[1.02]">
              <div className="flex items-start justify-between mb-6">
                <div className="p-3 bg-purple-500/20 rounded-2xl">
                  <TrendingUp className="w-6 h-6 text-purple-400" />
                </div>
                <ExternalLink className="w-4 h-4 text-gray-500 opacity-0 group-hover:opacity-100 transition-opacity" />
              </div>
              
              <div className="space-y-2">
                <div className="text-sm text-gray-400 font-medium">Interviews</div>
                <div className="text-5xl font-black tracking-tight">{stats.interviews}</div>
                <div className="flex items-center gap-2 text-sm">
                  <div className="px-2 py-1 bg-orange-500/20 text-orange-400 rounded-lg font-medium">
                    2 scheduled
                  </div>
                </div>
              </div>
              
              <div className="mt-6 h-2 bg-gray-800 rounded-full overflow-hidden">
                <div className="h-full w-1/3 bg-gradient-to-r from-purple-500 to-pink-400 rounded-full"></div>
              </div>
            </div>
          </div>
        </div>

        {/* Premium Filters & Search - Wire up Search */}
        <div className="flex flex-col md:flex-row items-center gap-4">
          <div className="flex-1 relative w-full">
            <Search className="absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
            <input 
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              placeholder="Search jobs by title, company, or skills..."
              className="w-full bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-2xl pl-12 pr-4 py-4 text-white placeholder-gray-500 focus:outline-none focus:border-blue-500/50 transition-colors"
            />
          </div>
          
          <button className="p-4 bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-2xl hover:border-gray-700 transition-colors hidden md:block">
            <Filter className="w-5 h-5 text-gray-400" />
          </button>
        </div>

        {/* Premium Job Cards - Wire up Filtering */}
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h2 className="text-2xl font-bold">Top Matches</h2>
            <div className="flex items-center gap-2 bg-gray-900/50 p-1 rounded-xl border border-gray-800">
              {['all', 'new', 'saved'].map(filter => (
                <button
                  key={filter}
                  onClick={() => setActiveFilter(filter)}
                  className={`px-4 py-2 rounded-lg font-medium text-sm transition-all ${
                    activeFilter === filter
                      ? 'bg-gray-700 text-white shadow-lg'
                      : 'text-gray-400 hover:text-white'
                  }`}
                >
                  {filter.charAt(0).toUpperCase() + filter.slice(1)}
                </button>
              ))}
            </div>
          </div>

          <div className="space-y-4">
            {filteredJobs.length > 0 ? (
              filteredJobs.map(job => (
                <div key={job.id} className="group relative cursor-pointer">
                  <div className="absolute inset-0 bg-gradient-to-r from-blue-500/0 via-purple-500/5 to-pink-500/0 rounded-3xl opacity-0 group-hover:opacity-100 transition-opacity duration-500"></div>
                  <div className="relative bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-6 hover:border-gray-700 transition-all duration-300">
                    <div className="flex flex-col md:flex-row items-start justify-between gap-6">
                      <div className="flex-1">
                        <div className="flex items-center gap-3 mb-3">
                          <div className="p-3 bg-gradient-to-br from-blue-500/20 to-purple-500/20 rounded-2xl">
                            <Building2 className="w-6 h-6 text-blue-400" />
                          </div>
                          
                          <div className="flex-1">
                            <div className="flex flex-wrap items-center gap-2 mb-1">
                              <h3 className="text-lg md:text-xl font-bold">{job.title}</h3>
                              <span className={`px-2 py-0.5 rounded-md text-xs font-bold ${
                                job.tier === 'S' ? 'bg-yellow-500/20 text-yellow-400' : 'bg-blue-500/20 text-blue-400'
                              }`}>
                                Tier {job.tier}
                              </span>
                            </div>
                            
                            <div className="flex flex-wrap items-center gap-3 md:gap-4 text-sm text-gray-400">
                              <span className="font-medium text-white">{job.company}</span>
                              <span className="flex items-center gap-1">
                                <MapPin className="w-3 h-3" />
                                {job.location}
                              </span>
                              <span className="flex items-center gap-1">
                                <Calendar className="w-3 h-3" />
                                {job.posted}
                              </span>
                              <span className="font-semibold text-green-400">{job.salary}</span>
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex flex-wrap items-center gap-2 ml-0 md:ml-[60px]">
                          {job.tags.map(tag => (
                            <span key={tag} className="px-3 py-1 bg-gray-800 rounded-lg text-xs text-gray-300">
                              {tag}
                            </span>
                          ))}
                        </div>
                      </div>
                      
                      <div className="flex items-center gap-4 w-full md:w-auto justify-between md:justify-end">
                        <div className="text-left md:text-right">
                          <div className="text-3xl font-black bg-gradient-to-r from-green-400 to-emerald-400 bg-clip-text text-transparent">
                            {job.score}
                          </div>
                          <div className="text-xs text-gray-500 font-medium">MATCH</div>
                        </div>
                        
                        <button className="px-6 py-3 bg-gradient-to-r from-blue-600 to-purple-600 rounded-xl font-semibold hover:scale-105 transition-transform duration-300 flex items-center gap-2">
                          <Zap className="w-4 h-4" />
                          Quick Apply
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              ))
            ) : (
              <div className="text-center py-12 text-gray-500">
                No jobs found matching your filters.
              </div>
            )}
          </div>
        </div>
      </div>
      
      {/* Moved animations to standard style block */}
      <style>{`
        @keyframes pulse {
          0%, 100% { opacity: 0.6; transform: scale(1); }
          50% { opacity: 1; transform: scale(1.05); }
        }
        .animation-delay-2000 { animation-delay: 2s; }
        .animation-delay-4000 { animation-delay: 4s; }
      `}</style>
    </div>
  );
}
===== ./src/components/SpotlightCard.tsx =====
'use client';

import { useRef, useState } from 'react';
import { motion } from 'framer-motion';

export default function SpotlightCard({ 
  children, 
  className = "", 
  spotlightColor = "rgba(255, 255, 255, 0.25)" 
}: { 
  children: React.ReactNode; 
  className?: string;
  spotlightColor?: string;
}) {
  const divRef = useRef<HTMLDivElement>(null);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [opacity, setOpacity] = useState(0);

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!divRef.current) return;
    const rect = divRef.current.getBoundingClientRect();
    setPosition({ x: e.clientX - rect.left, y: e.clientY - rect.top });
  };

  const handleFocus = () => {
    setOpacity(1);
  };

  const handleBlur = () => {
    setOpacity(0);
  };

  const handleMouseEnter = () => {
    setOpacity(1);
  };

  const handleMouseLeave = () => {
    setOpacity(0);
  };

  return (
    <motion.div
      ref={divRef}
      onMouseMove={handleMouseMove}
      onFocus={handleFocus}
      onBlur={handleBlur}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      className={`relative overflow-hidden rounded-[2rem] border border-white/10 bg-[#0A0A0A] ${className}`}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5, ease: "easeOut" }}
    >
      <div
        className="pointer-events-none absolute -inset-px opacity-0 transition duration-300"
        style={{
          opacity,
          background: `radial-gradient(600px circle at ${position.x}px ${position.y}px, ${spotlightColor}, transparent 40%)`,
        }}
      />
      <div className="relative h-full">{children}</div>
    </motion.div>
  );
}
===== ./src/components/UserMenu.tsx =====
"use client";

import React, { useState, useRef, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { signOut } from 'firebase/auth';
import { auth } from '@/lib/firebase';
import Link from 'next/link';
import { LogOut, CreditCard, User, Settings, ChevronDown } from 'lucide-react';

export default function UserMenu() {
  const [isOpen, setIsOpen] = useState(false);
  const router = useRouter();
  const menuRef = useRef<HTMLDivElement>(null);

  // Close menu when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const handleLogout = async () => {
    try {
      await signOut(auth);
      router.push('/auth/signin'); // Redirect to login page after logout
    } catch (error) {
      console.error("Error signing out:", error);
    }
  };

  return (
    <div className="relative" ref={menuRef}>
      {/* Trigger Button (The Avatar) */}
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 hover:bg-slate-100 p-1.5 rounded-full transition-colors focus:outline-none"
      >
        <div className="w-9 h-9 bg-gradient-to-br from-blue-600 to-purple-600 rounded-full flex items-center justify-center text-white font-semibold shadow-sm">
          {/* You can replace 'C' with {user?.displayName?.[0] || 'U'} later */}
          C
        </div>
        <ChevronDown className={`w-4 h-4 text-slate-500 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {/* Dropdown Menu */}
      {isOpen && (
        <div className="absolute right-0 mt-2 w-56 bg-white rounded-xl shadow-lg border border-slate-100 py-2 z-50 animation-fade-in">
          <div className="px-4 py-3 border-b border-slate-100 mb-1">
            <p className="text-sm font-medium text-slate-900">Chandra</p>
            <p className="text-xs text-slate-500 truncate">user@example.com</p>
          </div>

          <Link 
            href="/dashboard" 
            onClick={() => setIsOpen(false)}
            className="flex items-center gap-2 px-4 py-2.5 text-sm text-slate-600 hover:bg-slate-50 hover:text-slate-900 transition-colors"
          >
            <User className="w-4 h-4" />
            Profile
          </Link>

          <Link 
            href="/settings/billing" 
            onClick={() => setIsOpen(false)}
            className="flex items-center gap-2 px-4 py-2.5 text-sm text-slate-600 hover:bg-slate-50 hover:text-slate-900 transition-colors"
          >
            <CreditCard className="w-4 h-4" />
            Billing
          </Link>

          <Link 
            href="/settings" 
            onClick={() => setIsOpen(false)}
            className="flex items-center gap-2 px-4 py-2.5 text-sm text-slate-600 hover:bg-slate-50 hover:text-slate-900 transition-colors"
          >
            <Settings className="w-4 h-4" />
            Settings
          </Link>

          <div className="border-t border-slate-100 my-1"></div>

          <button 
            onClick={handleLogout}
            className="w-full flex items-center gap-2 px-4 py-2.5 text-sm text-red-600 hover:bg-red-50 transition-colors text-left"
          >
            <LogOut className="w-4 h-4" />
            Log Out
          </button>
        </div>
      )}
    </div>
  );
}
===== ./src/components/auth_ui.tsx =====
"use client";

import React from 'react';
import Link from 'next/link';
import { 
  Loader2, 
  Mail, 
  Lock, 
  ArrowRight, 
  Sparkles, 
  CheckCircle,
  AlertCircle,
  User,
  Chrome
} from 'lucide-react';

interface AuthPagesProps {
  mode: 'signin' | 'signup';
  loading: boolean;
  error: string;
  success: string;
  formData: any;
  setFormData: (data: any) => void;
  onSubmit: (e: React.FormEvent) => void;
  onGoogleSignIn: () => void;
}

export default function AuthPages({
  mode,
  loading,
  error,
  success,
  formData,
  setFormData,
  onSubmit,
  onGoogleSignIn
}: AuthPagesProps) {
  
  const isSignIn = mode === 'signin';

  return (
    <div className="min-h-screen bg-[#0A0A0A] text-white relative overflow-hidden font-sans selection:bg-blue-500/30 flex items-center justify-center p-4">
      {/* --- Background Gradients --- */}
      <div className="fixed inset-0 -z-10 pointer-events-none">
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-blue-500/10 rounded-full blur-[120px] animate-pulse" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-purple-500/10 rounded-full blur-[120px] animate-pulse animation-delay-2000" />
        <div className="absolute inset-0 opacity-10" 
          style={{ backgroundImage: `linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px)`, backgroundSize: '40px 40px' }} 
        />
      </div>

      <div className="w-full max-w-md">
        
        {/* Logo/Header */}
        <div className="text-center mb-8">
          <div className="flex items-center justify-center gap-2 mb-3">
            <div className="p-2 bg-gradient-to-tr from-blue-600 to-purple-600 rounded-xl shadow-lg shadow-blue-900/20">
              <Sparkles className="w-6 h-6 text-white" />
            </div>
            <span className="text-2xl font-black tracking-tight bg-clip-text text-transparent bg-gradient-to-r from-white to-gray-400">
              JobHunt AI
            </span>
          </div>
          <h2 className="text-xl font-bold text-white">
            {isSignIn ? 'Welcome back' : 'Create your account'}
          </h2>
          <p className="text-gray-400 text-sm mt-1">
            {isSignIn ? 'Enter your credentials to access your account' : 'Start your AI-powered job search journey today'}
          </p>
        </div>

        {/* Auth Card */}
        <div className="bg-gray-900/50 backdrop-blur-xl border border-gray-800 rounded-3xl p-8 shadow-2xl">
          
          {/* Social Sign In */}
          <button 
            onClick={onGoogleSignIn}
            disabled={loading}
            className="w-full flex items-center justify-center gap-3 bg-white text-black hover:bg-gray-200 font-bold py-3 px-4 rounded-xl transition-all transform hover:scale-[1.02] mb-6"
          >
            {loading ? (
              <Loader2 className="w-5 h-5 animate-spin" />
            ) : (
              <>
                <Chrome className="w-5 h-5 text-blue-600" />
                <span>Continue with Google</span>
              </>
            )}
          </button>

          <div className="relative mb-6">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-800"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-3 bg-[#111111] text-gray-500 rounded-lg border border-gray-800">Or continue with email</span>
            </div>
          </div>

          {/* Form */}
          <form onSubmit={onSubmit} className="space-y-4">
            
            {/* Show Name field only on Sign Up */}
            {!isSignIn && (
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-300 ml-1">Full Name</label>
                <div className="relative">
                  <User className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
                  <input 
                    type="text" 
                    required={!isSignIn}
                    placeholder="John Doe"
                    className="w-full bg-gray-800/50 border border-gray-700 text-white rounded-xl py-3 pl-10 pr-4 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all placeholder:text-gray-600"
                    value={formData.name || ''}
                    onChange={(e) => setFormData({...formData, name: e.target.value})}
                  />
                </div>
              </div>
            )}

            <div className="space-y-2">
              <label className="text-sm font-medium text-gray-300 ml-1">Email</label>
              <div className="relative">
                <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
                <input 
                  type="email" 
                  required
                  placeholder="name@example.com"
                  className="w-full bg-gray-800/50 border border-gray-700 text-white rounded-xl py-3 pl-10 pr-4 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all placeholder:text-gray-600"
                  value={formData.email}
                  onChange={(e) => setFormData({...formData, email: e.target.value})}
                />
              </div>
            </div>

            <div className="space-y-2">
              <div className="flex items-center justify-between ml-1">
                <label className="text-sm font-medium text-gray-300">Password</label>
                {isSignIn && (
                  <Link 
                    href="/forgot-password" 
                    className="text-xs text-blue-400 hover:text-blue-300 transition-colors"
                  >
                    Forgot password?
                  </Link>
                )}
              </div>
              <div className="relative">
                <Lock className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-500" />
                <input 
                  type="password" 
                  required
                  placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
                  className="w-full bg-gray-800/50 border border-gray-700 text-white rounded-xl py-3 pl-10 pr-4 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all placeholder:text-gray-600"
                  value={formData.password}
                  onChange={(e) => setFormData({...formData, password: e.target.value})}
                />
              </div>
            </div>

            {error && (
              <div className="p-3 bg-red-500/10 border border-red-500/20 rounded-xl flex items-center gap-2 text-sm text-red-400 animate-in fade-in slide-in-from-top-1">
                <AlertCircle className="w-4 h-4" /> {error}
              </div>
            )}

            {success && (
              <div className="p-3 bg-green-500/10 border border-green-500/20 rounded-xl flex items-center gap-2 text-sm text-green-400 animate-in fade-in slide-in-from-top-1">
                <CheckCircle className="w-4 h-4" /> {success}
              </div>
            )}

            <button 
              type="submit" 
              disabled={loading}
              className="w-full bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white font-bold py-3 rounded-xl shadow-lg shadow-blue-900/20 transition-all flex items-center justify-center gap-2 mt-2"
            >
              {loading ? (
                <>
                  <Loader2 className="w-5 h-5 animate-spin" />
                  {isSignIn ? 'Signing in...' : 'Creating account...'}
                </>
              ) : (
                <>
                  {isSignIn ? 'Sign In' : 'Create Account'}
                  <ArrowRight className="w-5 h-5" />
                </>
              )}
            </button>

          </form>
        </div>

        {/* Footer Link */}
        <p className="text-center text-gray-500 text-sm mt-8">
          {isSignIn ? "Don't have an account? " : "Already have an account? "}
          <Link 
            href={isSignIn ? '/signup' : '/auth/signin'} 
            className="text-blue-400 hover:text-blue-300 font-medium transition-colors"
          >
            {isSignIn ? 'Sign up' : 'Sign in'}
          </Link>
        </p>

      </div>
    </div>
  );
}
===== ./src/components/providers/AuthProvider.tsx =====
'use client';

import { createContext, useContext } from 'react';
import { useAuth } from '@/contexts/AuthContext';

const AuthContext = createContext<ReturnType<typeof useAuth> | null>(null);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const auth = useAuth();

  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;
}

export function useAuthContext() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuthContext must be used within AuthProvider');
  }
  return context;
}
===== ./src/components/ui/alert.tsx =====
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

===== ./src/components/ui/avatar.tsx =====
import * as React from 'react';
import * as AvatarPrimitive from '@radix-ui/react-avatar';
import { cn } from '@/lib/utils';

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      'relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full',
      className
    )}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn('aspect-square h-full w-full', className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      'flex h-full w-full items-center justify-center rounded-full bg-muted',
      className
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };
===== ./src/components/ui/badge.tsx =====
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

===== ./src/components/ui/button.tsx =====
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive:
          'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline:
          'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? React.Fragment : 'button';
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = 'Button';

export { Button, buttonVariants };
===== ./src/components/ui/card.tsx =====
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

===== ./src/components/ui/dropdown-menu.tsx =====
import * as React from 'react';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { cn } from '@/lib/utils';

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold', className)}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuRadioGroup,
};
===== ./src/components/ui/input.tsx =====
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

===== ./src/components/ui/label.tsx =====
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

===== ./src/components/ui/progress.tsx =====
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-primary/20",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

===== ./src/components/ui/select.tsx =====
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

===== ./src/components/ui/slider.tsx =====
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

===== ./src/components/ui/table.tsx =====
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

===== ./src/components/ui/tabs.tsx =====
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

===== ./src/components/ui/textarea.tsx =====
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

===== ./src/components/ui/toaster.tsx =====
'use client';

import { ToastProvider, ToastViewport } from '@radix-ui/react-toast';

export function Toaster() {
  return (
    <ToastProvider>
      <ToastViewport
        className="fixed bottom-0 right-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]"
        hotkey={['F8']}
      />
    </ToastProvider>
  );
}
===== ./src/contexts/AuthContext.tsx =====
// src/contexts/AuthContext.tsx
'use client';
import { useRouter } from 'next/navigation';
import React, { createContext, useContext, useEffect, useState } from 'react';
import {
  User,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut as firebaseSignOut,
  onAuthStateChanged,
  GoogleAuthProvider,
  signInWithPopup,
  sendPasswordResetEmail,
  updateProfile,
} from 'firebase/auth';
import { doc, getDoc, setDoc, serverTimestamp } from 'firebase/firestore';
import { auth, db } from '@/lib/firebase';

interface UserProfile {
  uid: string;
  email: string;
  displayName: string | null;
  photoURL: string | null;
  tier: 'free' | 'pro' | 'premium';
  onboarding_completed: boolean;
  profile_completed: boolean;
  active: boolean;
  skills?: string[];
  experience_level?: 'entry' | 'mid' | 'senior' | 'staff';
  years_of_experience?: number;
  preferred_roles?: string[];
  stats?: {                          // â† ADD THIS
    jobsFound: number;               // â† ADD THIS
    jobsApplied: number;             // â† ADD THIS
    interviews: number;              // â† ADD THIS
  };                                 // â† ADD THIS
  notifications?: {
    email: boolean;
    sms: boolean;
    push: boolean;
    in_app: boolean;
  };
}

interface AuthContextType {
  user: User | null;
  userProfile: UserProfile | null;
  loading: boolean;
  signUp: (email: string, password: string, displayName: string) => Promise<void>;
  signIn: (email: string, password: string) => Promise<void>;
  signInWithGoogle: () => Promise<void>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
  updateUserProfile: (data: Partial<UserProfile>) => Promise<void>;
  refreshUserProfile: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [loading, setLoading] = useState(true);

  // Fetch user profile from Firestore
  const fetchUserProfile = async (uid: string): Promise<UserProfile | null> => {
    try {
      const userDoc = await getDoc(doc(db, 'users', uid));
      if (userDoc.exists()) {
        return userDoc.data() as UserProfile;
      }
      return null;
    } catch (error) {
      console.error('Error fetching user profile:', error);
      return null;
    }
  };

  const createUserProfile = async (user: User, displayName?: string) => {
  const userRef = doc(db, 'users', user.uid);
  const profile: UserProfile = {
    uid: user.uid,
    email: user.email!,
    displayName: displayName || user.displayName || null,
    photoURL: user.photoURL || null,
    tier: 'free',
    onboarding_completed: false,
    profile_completed: false,
    active: true,
    stats: {                         // â† ADD THIS
      jobsFound: 0,                  // â† ADD THIS
      jobsApplied: 0,                // â† ADD THIS
      interviews: 0,                 // â† ADD THIS
    },                               // â† ADD THIS
    notifications: {
      email: true,
      sms: false,
      push: true,
      in_app: true,
    },
  };
  // ... rest of function

    await setDoc(userRef, {
      ...profile,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    });

    return profile;
  };

  // Listen to auth state changes
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      setUser(firebaseUser);

      if (firebaseUser) {
        let profile = await fetchUserProfile(firebaseUser.uid);
        
        // Create profile if it doesn't exist
        if (!profile) {
          profile = await createUserProfile(firebaseUser);
        }
        
        setUserProfile(profile);
      } else {
        setUserProfile(null);
      }

      setLoading(false);
    });

    return unsubscribe;
  }, []);

  // Sign up with email/password
  const signUp = async (email: string, password: string, displayName: string) => {
    try {
      const { user } = await createUserWithEmailAndPassword(auth, email, password);
      
      // Update Firebase Auth profile
      await updateProfile(user, { displayName });
      
      // Create Firestore profile
      await createUserProfile(user, displayName);
    } catch (error: any) {
      console.error('Sign up error:', error);
      throw new Error(error.message || 'Failed to create account');
    }
  };

  // Sign in with email/password
  const signIn = async (email: string, password: string) => {
    try {
      await signInWithEmailAndPassword(auth, email, password);
    } catch (error: any) {
      console.error('Sign in error:', error);
      throw new Error(error.message || 'Failed to sign in');
    }
  };

  // Sign in with Google
  const signInWithGoogle = async () => {
    try {
      const provider = new GoogleAuthProvider();
      const { user } = await signInWithPopup(auth, provider);
      
      // Check if user profile exists
      const profile = await fetchUserProfile(user.uid);
      if (!profile) {
        await createUserProfile(user);
      }
    } catch (error: any) {
      console.error('Google sign in error:', error);
      throw new Error(error.message || 'Failed to sign in with Google');
    }
  };

  // Sign out
  const signOut = async () => {
    try {
      await firebaseSignOut(auth);
    } catch (error: any) {
      console.error('Sign out error:', error);
      throw new Error(error.message || 'Failed to sign out');
    }
  };

  // Reset password
  const resetPassword = async (email: string) => {
    try {
      await sendPasswordResetEmail(auth, email);
    } catch (error: any) {
      console.error('Password reset error:', error);
      throw new Error(error.message || 'Failed to send reset email');
    }
  };

  // Update user profile in Firestore
  const updateUserProfile = async (data: Partial<UserProfile>) => {
    if (!user) throw new Error('No user logged in');

    try {
      const userRef = doc(db, 'users', user.uid);
      await setDoc(userRef, {
        ...data,
        updatedAt: serverTimestamp(),
      }, { merge: true });

      // Refresh profile
      await refreshUserProfile();
    } catch (error: any) {
      console.error('Update profile error:', error);
      throw new Error(error.message || 'Failed to update profile');
    }
  };

  // Manually refresh user profile
  const refreshUserProfile = async () => {
    if (!user) return;
    const profile = await fetchUserProfile(user.uid);
    setUserProfile(profile);
  };

  const value = {
    user,
    userProfile,
    loading,
    signUp,
    signIn,
    signInWithGoogle,
    signOut,
    resetPassword,
    updateUserProfile,
    refreshUserProfile,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// Custom hook to use auth context
export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Protected route wrapper
export function withAuth<P extends object>(
  Component: React.ComponentType<P>
): React.FC<P> {
  return function ProtectedRoute(props: P) {
    const { user, loading } = useAuth();
    const router = useRouter();

    useEffect(() => {
      if (!loading && !user) {
        router.push('/auth/signin');
      }
    }, [user, loading, router]);

    if (loading) {
      return (
        <div className="min-h-screen flex items-center justify-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600" />
        </div>
      );
    }

    if (!user) return null;

    return <Component {...props} />;
  };
}
===== ./src/lib/api-client.ts =====
// src/lib/api-client.ts - Helper for making authenticated API calls

import { auth } from '@/lib/firebase';

/**
 * Make an authenticated API call
 * Automatically adds Firebase ID token to Authorization header
 */
export async function authenticatedFetch(
  url: string, 
  options: RequestInit = {}
): Promise<Response> {
  // Get current user's ID token
  const user = auth.currentUser;
  
  if (!user) {
    throw new Error('User not authenticated');
  }

  const token = await user.getIdToken();

  // Merge headers with Authorization
  const headers = {
    ...options.headers,
    'Authorization': `Bearer ${token}`,
  };

  // Make the request
  return fetch(url, {
    ...options,
    headers,
  });
}

/**
 * POST helper with authentication and JSON
 */
export async function authenticatedPost(
  url: string,
  data: any
): Promise<Response> {
  return authenticatedFetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(data),
  });
}

/**
 * Example usage in your components:
 * 
 * // Old way (INSECURE - sends userId in body):
 * const response = await fetch('/api/tailor', {
 *   method: 'POST',
 *   body: JSON.stringify({ userId: user.uid, jobId })
 * });
 * 
 * // New way (SECURE - sends token in header):
 * const response = await authenticatedPost('/api/tailor', { 
 *   jobId 
 * });
 * 
 * // Or with custom options:
 * const response = await authenticatedFetch('/api/custom', {
 *   method: 'GET',
 *   // token is added automatically
 * });
 */
===== ./src/lib/auth-middleware.ts =====
// src/lib/auth-middleware.ts - CORRECTED VERSION
import { adminAuth } from '@/lib/firebase-admin';
import { NextResponse } from 'next/server';

/**
 * Verify Firebase ID token from Authorization header
 * Returns the authenticated user's UID
 * Throws error if token is missing or invalid
 */
export async function verifyAuth(request: Request): Promise<string> {
  try {
    const authHeader = request.headers.get('Authorization');
    
    if (!authHeader) {
      throw new Error('Missing Authorization header');
    }

    // Extract token from "Bearer <token>" format
    const token = authHeader.replace('Bearer ', '').trim();
    
    if (!token) {
      throw new Error('Missing token');
    }

    // Verify the Firebase ID token
    const decodedToken = await adminAuth.verifyIdToken(token);
    
    return decodedToken.uid;
  } catch (error: any) {
    console.error('Auth verification failed:', error.message);
    throw new Error('Unauthorized');
  }
}

/**
 * Wrapper function for protected API routes
 * Automatically verifies auth and handles errors
 */
export async function withAuth(
  request: Request,
  handler: (userId: string, request: Request) => Promise<NextResponse>
): Promise<NextResponse> {
  try {
    const userId = await verifyAuth(request);
    return await handler(userId, request);
  } catch (error: any) {
    if (error.message === 'Unauthorized') {
      return NextResponse.json(
        { error: 'Unauthorized. Please sign in.' },
        { status: 401 }
      );
    }
    
    console.error('Auth middleware error:', error);
    return NextResponse.json(
      { error: 'Authentication failed' },
      { status: 500 }
    );
  }
}
===== ./src/lib/deepseek.ts =====
import axios from 'axios';

const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY;
const DEEPSEEK_BASE_URL = process.env.DEEPSEEK_BASE_URL || 'https://api.deepseek.com';

interface DeepSeekMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface DeepSeekResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message: {
      role: string;
      content: string;
    };
    finish_reason: string;
  }>;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

class DeepSeekClient {
  private apiKey: string;
  private baseURL: string;
  private lastCallTime: number = 0;
  private minDelay: number = 1000; // 1 second between calls
  private rateLimitQueue: Array<() => Promise<any>> = [];
  private processingQueue: boolean = false;

  constructor() {
    // Only check for key when actually instantiating
    if (!DEEPSEEK_API_KEY) {
      throw new Error('DEEPSEEK_API_KEY is not configured');
    }
    this.apiKey = DEEPSEEK_API_KEY;
    this.baseURL = DEEPSEEK_BASE_URL;
  }

  private async enforceRateLimit(): Promise<void> {
    const now = Date.now();
    const timeSinceLastCall = now - this.lastCallTime;
    
    if (timeSinceLastCall < this.minDelay) {
      const delay = this.minDelay - timeSinceLastCall;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    this.lastCallTime = Date.now();
  }

  private async processQueue(): Promise<void> {
    if (this.processingQueue || this.rateLimitQueue.length === 0) return;
    
    this.processingQueue = true;
    
    while (this.rateLimitQueue.length > 0) {
      const task = this.rateLimitQueue.shift();
      if (task) {
        await this.enforceRateLimit();
        try {
          await task();
        } catch (error) {
          console.error('Error in rate-limited task:', error);
        }
      }
    }
    
    this.processingQueue = false;
  }

  private queueRequest<T>(task: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.rateLimitQueue.push(async () => {
        try {
          const result = await task();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });
      
      if (!this.processingQueue) {
        this.processQueue();
      }
    });
  }

  async chat(messages: DeepSeekMessage[], options: {
    model?: string;
    temperature?: number;
    max_tokens?: number;
    stream?: boolean;
  } = {}): Promise<string> {
    return this.queueRequest(async () => {
      try {
        const response = await axios.post<DeepSeekResponse>(
          `${this.baseURL}/v1/chat/completions`,
          {
            model: options.model || 'deepseek-chat',
            messages,
            temperature: options.temperature ?? 0.7,
            max_tokens: options.max_tokens || 2000,
            stream: options.stream || false,
          },
          {
            headers: {
              'Authorization': `Bearer ${this.apiKey}`,
              'Content-Type': 'application/json',
            },
            timeout: 30000, // 30 second timeout
          }
        );

        if (!response.data.choices || response.data.choices.length === 0) {
          throw new Error('No response from AI');
        }

        return response.data.choices[0].message.content;
      } catch (error: any) {
        console.error('DeepSeek API Error:', {
          message: error.message,
          status: error.response?.status,
          data: error.response?.data,
        });
        
        if (error.response?.status === 429) {
          // Rate limited, increase delay and retry
          this.minDelay = Math.min(this.minDelay * 2, 10000); // Max 10 seconds
          throw new Error('Rate limited. Please try again in a moment.');
        } else if (error.response?.status === 401) {
          throw new Error('Invalid API key');
        } else if (error.code === 'ECONNABORTED') {
          throw new Error('Request timeout. Please try again.');
        }
        
        throw new Error('Failed to get AI response');
      }
    });
  }

  // Analyze resume and extract structured data
  async analyzeResume(resumeText: string): Promise<{
    skills: string[];
    experience_level: 'entry' | 'mid' | 'senior' | 'staff' | 'executive';
    industries: string[];
    preferred_roles: string[];
    key_achievements: string[];
    years_of_experience: number;
    education?: string[];
    certifications?: string[];
  }> {
    const prompt = `Analyze this resume and extract structured information. Return ONLY valid JSON, no markdown or code blocks.

Resume:
${resumeText.substring(0, 5000)}  // Limit text length

Instructions:
1. Extract technical and soft skills
2. Determine experience level: entry (0-3 years), mid (3-7 years), senior (7-10 years), staff (10-15 years), executive (15+ years)
3. Identify industries (tech, finance, healthcare, etc.)
4. Identify preferred roles based on experience
5. Extract key achievements with metrics
6. Calculate total years of professional experience
7. Extract education degrees
8. Extract certifications if any

Return JSON with this exact structure:
{
  "skills": ["skill1", "skill2"],
  "experience_level": "entry|mid|senior|staff|executive",
  "industries": ["industry1", "industry2"],
  "preferred_roles": ["role1", "role2"],
  "key_achievements": ["achievement1", "achievement2"],
  "years_of_experience": number,
  "education": ["degree1", "degree2"],
  "certifications": ["cert1", "cert2"]
}`;

    const response = await this.chat([
      {
        role: 'system',
        content: 'You are an expert resume analyzer. Extract accurate, structured data. Always respond with valid JSON only, no additional text.',
      },
      {
        role: 'user',
        content: prompt,
      },
    ], { temperature: 0.3 }); 

    try {
      const cleaned = response.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      const parsed = JSON.parse(cleaned);
      
      if (!Array.isArray(parsed.skills) || !parsed.experience_level || typeof parsed.years_of_experience !== 'number') {
        throw new Error('Invalid response structure');
      }
      
      return parsed;
    } catch (error) {
      console.error('Failed to parse resume analysis:', error, 'Response:', response);
      throw new Error('Failed to parse AI response. Please try again.');
    }
  }

  // Calculate job match score
  async calculateMatchScore(userProfile: any, job: any): Promise<{
    score: number;
    reasons: string[];
    weaknesses: string[];
    suggestions: string[];
  }> {
    const prompt = `Calculate a job match score (0-100) for this candidate and job. Return ONLY valid JSON.

Candidate Profile:
- Skills: ${JSON.stringify(userProfile.skills || [])}
- Experience Level: ${userProfile.experience_level}
- Years of Experience: ${userProfile.years_of_experience || 0}
- Preferred Roles: ${JSON.stringify(userProfile.preferred_roles || [])}
- Industries: ${JSON.stringify(userProfile.industries || [])}

Job:
- Title: ${job.title}
- Company: ${job.company}
- Requirements: ${JSON.stringify(job.requirements || [])}
- Skills Required: ${JSON.stringify(job.skills || [])}
- Experience Required: ${job.experience_required || 'Not specified'}

Scoring Weights:
1. Skills overlap (40%)
2. Experience match (30%)
3. Industry relevance (15%)
4. Role alignment (15%)

Return JSON:
{
  "score": number (0-100),
  "reasons": ["reason1", "reason2", "reason3"],
  "weaknesses": ["weakness1", "weakness2"],
  "suggestions": ["suggestion1", "suggestion2"]
}`;

    const response = await this.chat([
      {
        role: 'system',
        content: 'You are an expert job matching AI. Calculate accurate scores and provide actionable feedback. Always respond with valid JSON only.',
      },
      {
        role: 'user',
        content: prompt,
      },
    ], { temperature: 0.2 });

    try {
      const cleaned = response.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      const parsed = JSON.parse(cleaned);
      
      if (parsed.score < 0 || parsed.score > 100) {
        parsed.score = Math.max(0, Math.min(100, parsed.score));
      }
      
      return parsed;
    } catch (error) {
      console.error('Failed to parse match score:', error, 'Response:', response);
      throw new Error('Failed to calculate match score');
    }
  }

  // Generate personalized cover letter
  async generateCoverLetter(
    userProfile: any,
    job: any,
    tone: 'professional' | 'casual' | 'enthusiastic' = 'professional'
  ): Promise<string> {
    const toneDescriptions = {
      professional: 'formal, polished, and business-like',
      casual: 'friendly, approachable, yet professional',
      enthusiastic: 'energetic, passionate, and excited',
    };

    const prompt = `Write a compelling cover letter for this job application.

Job Details:
- Title: ${job.title}
- Company: ${job.company}
- Requirements: ${JSON.stringify(job.requirements || [])}
- Description: ${job.description?.substring(0, 300) || 'Not provided'}

Candidate Background:
- Name: ${userProfile.name || 'Candidate'}
- Skills: ${JSON.stringify(userProfile.skills || [])}
- Experience Level: ${userProfile.experience_level}
- Years of Experience: ${userProfile.years_of_experience || 0}
- Key Achievements: ${JSON.stringify(userProfile.key_achievements || []).substring(0, 300)}

Tone: ${toneDescriptions[tone]}
Length: 250-300 words

Structure:
1. Personalized opening - mention the company/role specifically
2. 2-3 most relevant achievements with metrics
3. Skills that directly match job requirements
4. Enthusiasm for the role and company
5. Professional closing with call to action

Write a complete, ready-to-use cover letter with proper formatting.`;

    const response = await this.chat([
      {
        role: 'system',
        content: 'You are an expert career coach who writes compelling, personalized cover letters that get interviews. Generate professional, well-formatted letters.',
      },
      {
        role: 'user',
        content: prompt,
      },
    ], { temperature: 0.8, max_tokens: 1000 });

    return response.trim();
  }

  // Tailor resume for specific job
  async tailorResume(resumeText: string, jobDescription: string): Promise<{
    suggestions: string[];
    keywords_to_add: string[];
    sections_to_emphasize: string[];
    sample_bullet_points: string[];
  }> {
    const prompt = `Analyze how to optimize this resume for the target job. Return ONLY valid JSON.

Current Resume (first 2000 chars):
${resumeText.substring(0, 2000)}

Target Job Description (first 1000 chars):
${jobDescription.substring(0, 1000)}

Provide actionable suggestions to improve match. Focus on:
1. Adding missing keywords from job description
2. Emphasizing relevant sections
3. Rewriting bullet points to match job requirements
4. Quantifying achievements

Return JSON:
{
  "suggestions": ["suggestion1", "suggestion2"],
  "keywords_to_add": ["keyword1", "keyword2"],
  "sections_to_emphasize": ["section1", "section2"],
  "sample_bullet_points": ["bullet1", "bullet2"]
}`;

    const response = await this.chat([
      {
        role: 'system',
        content: 'You are an expert resume optimization advisor. Provide specific, actionable advice. Always respond with valid JSON only.',
      },
      {
        role: 'user',
        content: prompt,
      },
    ], { temperature: 0.5 });

    try {
      const cleaned = response.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      return JSON.parse(cleaned);
    } catch (error) {
      console.error('Failed to parse resume suggestions:', error, 'Response:', response);
      throw new Error('Failed to parse AI response');
    }
  }

  // Generate interview prep questions
  async generateInterviewQuestions(job: any, userProfile: any): Promise<{
    technical: string[];
    behavioral: string[];
    company_specific: string[];
    salary_negotiation: string[];
  }> {
    const prompt = `Generate interview preparation questions for this job. Return ONLY valid JSON.

Job:
- Title: ${job.title}
- Company: ${job.company}
- Requirements: ${JSON.stringify(job.requirements || [])}
- Skills Required: ${JSON.stringify(job.skills || [])}

Candidate Level: ${userProfile.experience_level}
Candidate Skills: ${JSON.stringify(userProfile.skills || [])}

Generate 3-5 questions in each category:
1. Technical questions specific to the role and skills
2. Behavioral questions based on experience level
3. Company-specific questions (culture, products, industry)
4. Salary negotiation questions

Return JSON:
{
  "technical": ["question1", "question2"],
  "behavioral": ["question1", "question2"],
  "company_specific": ["question1", "question2"],
  "salary_negotiation": ["question1", "question2"]
}`;

    const response = await this.chat([
      {
        role: 'system',
        content: 'You are an expert interview coach. Generate relevant, challenging questions. Always respond with valid JSON only.',
      },
      {
        role: 'user',
        content: prompt,
      },
    ]);

    try {
      const cleaned = response.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      return JSON.parse(cleaned);
    } catch (error) {
      console.error('Failed to parse interview questions:', error, 'Response:', response);
      throw new Error('Failed to parse AI response');
    }
  }

  // Generate follow-up email after interview
  async generateFollowUpEmail(
    interviewDetails: any,
    userProfile: any,
    tone: 'professional' | 'grateful' | 'enthusiastic' = 'professional'
  ): Promise<string> {
    const prompt = `Write a follow-up email after a job interview.

Interview Details:
- Position: ${interviewDetails.position}
- Company: ${interviewDetails.company}
- Interviewers: ${interviewDetails.interviewers?.join(', ') || 'The interview team'}
- Key Discussion Points: ${interviewDetails.discussionPoints?.join('; ') || 'Various role-related topics'}
- Date: ${interviewDetails.date || 'Recently'}

Candidate:
- Name: ${userProfile.name || 'Candidate'}

Tone: ${tone}
Length: 150-200 words

Include:
1. Thank the interviewer(s)
2. Mention something specific from the conversation
3. Reiterate enthusiasm for the role
4. Professional closing

Write a complete, ready-to-use email with subject line.`;

    return await this.chat([
      {
        role: 'system',
        content: 'You are an expert at writing professional follow-up emails that leave a positive impression.',
      },
      {
        role: 'user',
        content: prompt,
      },
    ], { temperature: 0.7, max_tokens: 500 });
  }
}

// Singleton Pattern for Lazy Loading
class DeepSeekClientSingleton {
  private static instance: DeepSeekClient | null = null;
  
  static getInstance(): DeepSeekClient {
    if (!DeepSeekClientSingleton.instance) {
      DeepSeekClientSingleton.instance = new DeepSeekClient();
    }
    return DeepSeekClientSingleton.instance;
  }
}

export const deepseek = DeepSeekClientSingleton.getInstance();
export default deepseek;
===== ./src/lib/firebase-admin.ts =====
import { initializeApp, getApps, cert, ServiceAccount, getApp } from 'firebase-admin/app';
import { getFirestore } from 'firebase-admin/firestore';
import { getAuth } from 'firebase-admin/auth';
import { getStorage } from 'firebase-admin/storage';

// 1. Setup Service Account with Fallbacks
// We check for the specific ADMIN ID, but fall back to the public one if missing.
const serviceAccount: ServiceAccount = {
  projectId: process.env.FIREBASE_ADMIN_PROJECT_ID || process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  clientEmail: process.env.FIREBASE_ADMIN_CLIENT_EMAIL,
  privateKey: process.env.FIREBASE_ADMIN_PRIVATE_KEY?.replace(/\\n/g, '\n'),
};

// 2. Safe Initialization
// We only try to initialize if we actually have the keys. 
// This prevents build-time crashes when secrets aren't available.
let adminApp;

if (!getApps().length) {
  if (serviceAccount.projectId && serviceAccount.clientEmail && serviceAccount.privateKey) {
    try {
      adminApp = initializeApp({
        credential: cert(serviceAccount),
        storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
      });
    } catch (error) {
      console.error('Firebase Admin initialization error:', error);
    }
  } else {
    console.warn('Firebase Admin: Missing service account credentials. Skipping initialization.');
  }
} else {
  adminApp = getApp();
}

// 3. Export Services safely
// If init failed, these might be undefined, but it prevents the build from crashing immediately.
export const adminDb = adminApp ? getFirestore(adminApp) : {} as any;
export const adminAuth = adminApp ? getAuth(adminApp) : {} as any;
export const adminStorage = adminApp ? getStorage(adminApp) : {} as any;

export default adminApp;

// Helper functions (Safe wrappers)
export async function getUserByEmail(email: string) {
  if (!adminAuth.getUserByEmail) return null;
  try {
    return await adminAuth.getUserByEmail(email);
  } catch (error) {
    console.error('Error fetching user by email:', error);
    return null;
  }
}

export async function setCustomUserClaims(uid: string, claims: object) {
  if (!adminAuth.setCustomUserClaims) return false;
  try {
    await adminAuth.setCustomUserClaims(uid, claims);
    return true;
  } catch (error) {
    console.error('Error setting custom claims:', error);
    return false;
  }
}

export async function deleteUser(uid: string) {
  if (!adminAuth.deleteUser) return false;
  try {
    await adminAuth.deleteUser(uid);
    // Also delete user data
    await adminDb.collection('users').doc(uid).delete();
    return true;
  } catch (error) {
    console.error('Error deleting user:', error);
    return false;
  }
}
===== ./src/lib/firebase.ts =====
import { initializeApp, getApps } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getStorage } from 'firebase/storage';

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};


// Initialize Firebase
const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];

export const auth = getAuth(app);
export const db = getFirestore(app);
export const storage = getStorage(app);

export default app;
===== ./src/lib/jobs/matcher.ts =====
// lib/jobs/matcher.ts

import { adminDb } from '@/lib/firebase-admin';
import { deepseek } from '@/lib/deepseek';
import { NotificationService } from '@/lib/notifications';

export class JobMatchingEngine {
  async matchJobsWithUsers(jobIds: string[]): Promise<void> {
    // Get all active users
    const usersSnapshot = await adminDb
      .collection('users')
      .where('active', '==', true)
      .get();

    const matchBatch = adminDb.batch();
    let matchCount = 0;

    for (const userDoc of usersSnapshot.docs) {
      const userProfile = userDoc.data();

      // Fetch job details
      const jobsSnapshot = await adminDb
        .collection('jobs')
        .where('__name__', 'in', jobIds.slice(0, 10)) // Firestore limit
        .get();

      for (const jobDoc of jobsSnapshot.docs) {
        const job = jobDoc.data();

        // Quick filter before AI scoring
        if (!this.quickMatch(userProfile, job)) continue;

        // AI-powered match scoring
        const matchResult = await deepseek.calculateMatchScore(
          userProfile, 
          job
        );

        // Only save high-quality matches (70+)
        if (matchResult.score >= 70) {
          const matchRef = adminDb.collection('user_job_matches').doc();
          matchBatch.set(matchRef, {
            userId: userDoc.id,
            jobId: jobDoc.id,
            matchScore: matchResult.score,
            matchReasons: matchResult.reasons,
            weaknesses: matchResult.weaknesses,
            notifiedAt: new Date(),
            viewed: false,
            applied: false,
          });

          matchCount++;

          // Send notification for 85+ matches
          if (matchResult.score >= 85 && userProfile.notifications?.email) {
            await this.sendMatchNotification(
              userProfile, 
              job, 
              matchResult
            );
          }
        }
      }
    }

    await matchBatch.commit();
    console.log(`Created ${matchCount} job matches`);
  }

  private quickMatch(profile: any, job: any): boolean {
    // Fast pre-filtering before expensive AI call
    const titleLower = job.title.toLowerCase();
    const keywords = profile.keywords || [];
    
    // Must match at least one keyword
    const hasKeyword = keywords.some((kw: string) => 
      titleLower.includes(kw.toLowerCase())
    );

    // Exclude unwanted terms
    const excludeTerms = ['intern', 'internship', 'entry-level'];
    const hasExcluded = excludeTerms.some((term: string) => 
      titleLower.includes(term)
    );

    return hasKeyword && !hasExcluded;
  }

  private async sendMatchNotification(
    user: any, 
    job: any, 
    matchResult: any
  ): Promise<void> {
    const notificationService = new NotificationService();
    await notificationService.send({
      userId: user.id,
      type: 'job_match',
      title: `New ${matchResult.score}% Match: ${job.title}`,
      body: `${job.company} is hiring!`,
      data: { job, matchScore: matchResult.score, reasons: matchResult.reasons },
      channels: ['email', 'in_app', 'push'],
    });
  }
}
===== ./src/lib/jobs/scraper.ts =====
// lib/jobs/scraper.ts
// Serverless job scraping and matching engine

import { adminDb } from '@/lib/firebase-admin';
import { deepseek } from '@/lib/deepseek';
import axios from 'axios';
import { QueryDocumentSnapshot } from 'firebase-admin/firestore';

interface JobListing {
  title: string;
  company: string;
  location: string;
  description: string;
  requirements: string[];
  url: string;
  salary?: string;
  remote: boolean;
  postedAt: Date;
  source: string;
}

/**
 * Multi-source job scraper
 * Fetches jobs from various APIs and websites
 */
export class JobScraper {
  private sources = [
    { name: 'GitHub Jobs', url: 'https://jobs.github.com/positions.json' },
    { name: 'RemoteOK', url: 'https://remoteok.com/api' },
    { name: 'Adzuna', url: 'https://api.adzuna.com/v1/api/jobs' },
  ];

  async scrapeAllSources(): Promise<JobListing[]> {
    const jobs: JobListing[] = [];

    for (const source of this.sources) {
      try {
        const sourceJobs = await this.scrapeSource(source);
        jobs.push(...sourceJobs);
      } catch (error) {
        console.error(`Failed to scrape ${source.name}:`, error);
      }
    }

    return this.deduplicateJobs(jobs);
  }

  private async scrapeSource(source: { name: string; url: string }): Promise<JobListing[]> {
    // Implementation varies by source
    // This is a template - you'd customize for each API
    
    if (source.name === 'RemoteOK') {
      return this.scrapeRemoteOK();
    }
    
    // Add more sources here
    return [];
  }

  private async scrapeRemoteOK(): Promise<JobListing[]> {
    try {
      const response = await axios.get('https://remoteok.com/api', {
        headers: { 'User-Agent': 'JobHuntAI/1.0' }
      });

      const jobs = response.data.slice(1); // First item is metadata

      return jobs
        .filter((job: any) => job.position && job.company)
        .map((job: any) => ({
          title: job.position,
          company: job.company,
          location: job.location || 'Remote',
          description: job.description || '',
          requirements: this.extractRequirements(job.description),
          url: `https://remoteok.com/remote-jobs/${job.slug}`,
          salary: job.salary_min ? `$${job.salary_min}-$${job.salary_max}` : undefined,
          remote: true,
          postedAt: new Date(job.date),
          source: 'RemoteOK',
        }));
    } catch (error) {
      console.error('RemoteOK scraping failed:', error);
      return [];
    }
  }

  private extractRequirements(description: string): string[] {
    // Use AI to extract requirements
    const keywords = [
      'JavaScript', 'TypeScript', 'React', 'Node.js', 'Python',
      'AWS', 'Docker', 'Kubernetes', 'SQL', 'MongoDB',
      'REST API', 'GraphQL', 'CI/CD', 'Agile', 'Git'
    ];

    return keywords.filter(keyword => 
      description.toLowerCase().includes(keyword.toLowerCase())
    );
  }

  private deduplicateJobs(jobs: JobListing[]): JobListing[] {
    const seen = new Set<string>();
    return jobs.filter(job => {
      const key = `${job.company}-${job.title}`.toLowerCase();
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }
}

/**
 * AI-powered job matching engine
 * Matches users with jobs based on their profile
 */
export class JobMatchingEngine {
  async processNewJobs(jobs: JobListing[]): Promise<void> {
    // 1. Save jobs to Firestore
    const batch = adminDb.batch();
    const savedJobs: { id: string; data: JobListing }[] = [];

    for (const job of jobs) {
      const jobRef = adminDb.collection('jobs').doc();
      batch.set(jobRef, {
        ...job,
        createdAt: new Date(),
        indexed: false,
      });
      savedJobs.push({ id: jobRef.id, data: job });
    }

    await batch.commit();

    // 2. Match with all active users
    await this.matchJobsWithUsers(savedJobs);
  }

  public async matchJobsWithUsers(jobs: { id: string; data: JobListing }[]): Promise<void> {
    // Get all active users
    const usersSnapshot = await adminDb
      .collection('users')
      .where('active', '==', true)
      .get();

    const matchBatch = adminDb.batch();
    let matchCount = 0;

    for (const userDoc of usersSnapshot.docs) {
      const userProfile = userDoc.data();

      for (const job of jobs) {
        // Calculate match score using AI
        const matchResult = await deepseek.calculateMatchScore(userProfile, job.data);

        // Only save high-quality matches (70+)
        if (matchResult.score >= 70) {
          const matchRef = adminDb.collection('user_job_matches').doc();
          matchBatch.set(matchRef, {
            userId: userDoc.id,
            jobId: job.id,
            matchScore: matchResult.score,
            matchReasons: matchResult.reasons,
            weaknesses: matchResult.weaknesses,
            notifiedAt: new Date(),
            viewed: false,
            applied: false,
          });

          matchCount++;

          // Send notification if user has email notifications enabled
          if (userProfile.notifications?.email && matchResult.score >= 85) {
            await this.sendMatchNotification(userProfile.email, job.data, matchResult.score);
          }
        }
      }
    }

    await matchBatch.commit();
    console.log(`Created ${matchCount} job matches`);
  }

  private async sendMatchNotification(email: string, job: JobListing, score: number): Promise<void> {
    // Integrate with email service (SendGrid, Resend, etc.)
    console.log(`Sending notification to ${email} for ${job.title} at ${job.company} (${score}% match)`);
  }

  async updateUserMatchScores(userId: string): Promise<void> {
    // Recalculate all match scores when user updates profile
    const userDoc = await adminDb.collection('users').doc(userId).get();
    const userProfile = userDoc.data();

    const jobsSnapshot = await adminDb
      .collection('jobs')
      .where('postedAt', '>', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)) // Last 30 days
      .limit(500)
      .get();

    const batch = adminDb.batch();

    for (const jobDoc of jobsSnapshot.docs) {
      const job = jobDoc.data();
      const matchResult = await deepseek.calculateMatchScore(userProfile, job);

      if (matchResult.score >= 70) {
        const matchRef = adminDb.collection('user_job_matches').doc();
        batch.set(matchRef, {
          userId,
          jobId: jobDoc.id,
          matchScore: matchResult.score,
          matchReasons: matchResult.reasons,
          weaknesses: matchResult.weaknesses,
          notifiedAt: new Date(),
          viewed: false,
          applied: false,
        });
      }
    }

    await batch.commit();
  }
}

/**
 * Cron job handler - Run this every 6 hours
 */
export async function runJobScrapingCron(): Promise<void> {
  console.log('Starting job scraping cron...');

  const scraper = new JobScraper();
  const matcher = new JobMatchingEngine();

  // 1. Scrape new jobs
  const jobs = await scraper.scrapeAllSources();
  console.log(`Scraped ${jobs.length} jobs`);

  // 2. Match with users
  await matcher.processNewJobs(jobs);

  // 3. Clean up old jobs (90+ days)
  await cleanupOldJobs();

  console.log('Job scraping cron completed');
}

async function cleanupOldJobs(): Promise<void> {
  const cutoffDate = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
  const oldJobsSnapshot = await adminDb
    .collection('jobs')
    .where('postedAt', '<', cutoffDate)
    .limit(500)
    .get();

  const batch = adminDb.batch();
  
  // FIX: Explicitly type 'doc' to QueryDocumentSnapshot to avoid "implicit any" error
  oldJobsSnapshot.docs.forEach((doc: QueryDocumentSnapshot) => batch.delete(doc.ref));
  
  await batch.commit();

  console.log(`Deleted ${oldJobsSnapshot.size} old jobs`);
}

// API Route: /api/cron/scrape-jobs
export async function POST(request: Request) {
  try {
    // Verify cron secret for security
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return new Response('Unauthorized', { status: 401 });
    }

    await runJobScrapingCron();

    return Response.json({ success: true });
  } catch (error) {
    console.error('Cron job failed:', error);
    return Response.json({ error: 'Cron job failed' }, { status: 500 });
  }
}
===== ./src/lib/notifications/index.ts =====
// lib/notifications/index.ts
// Real-time notification system with multiple channels

import { adminDb } from '@/lib/firebase-admin';
import nodemailer from 'nodemailer';
import twilio from 'twilio';

interface NotificationPayload {
  userId: string;
  type: 'job_match' | 'application_update' | 'interview_scheduled' | 'message';
  title: string;
  body: string;
  data?: Record<string, any>;
  channels?: ('email' | 'sms' | 'push' | 'in_app')[];
}

export class NotificationService {
  private emailTransporter: nodemailer.Transporter;
  private twilioClient: twilio.Twilio;

  constructor() {
    // Email setup (using Gmail SMTP as example)
    this.emailTransporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST || 'smtp.gmail.com',
      port: 587,
      secure: false,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    });

    // SMS setup (Twilio)
    this.twilioClient = twilio(
      process.env.TWILIO_ACCOUNT_SID,
      process.env.TWILIO_AUTH_TOKEN
    );
  }

  async send(notification: NotificationPayload): Promise<void> {
    // Get user preferences
    const userDoc = await adminDb.collection('users').doc(notification.userId).get();
    const user = userDoc.data();

    if (!user) {
      console.error(`User ${notification.userId} not found`);
      return;
    }

    const channels = notification.channels || this.getDefaultChannels(notification.type);

    // Send to each enabled channel
    const promises = channels.map(channel => {
      if (!user.notifications?.[channel]) return Promise.resolve();

      switch (channel) {
        case 'email':
          return this.sendEmail(user.email, notification);
        case 'sms':
          return user.phone ? this.sendSMS(user.phone, notification) : Promise.resolve();
        case 'push':
          return this.sendPushNotification(user, notification);
        case 'in_app':
          return this.saveInAppNotification(notification);
        default:
          return Promise.resolve();
      }
    });

    await Promise.allSettled(promises);
  }

  private async sendEmail(to: string, notification: NotificationPayload): Promise<void> {
    const template = this.getEmailTemplate(notification);

    await this.emailTransporter.sendMail({
      from: '"JobHunt AI" <notifications@jobhunt.ai>',
      to,
      subject: notification.title,
      html: template,
    });
  }

  private async sendSMS(to: string, notification: NotificationPayload): Promise<void> {
    await this.twilioClient.messages.create({
      body: `${notification.title}: ${notification.body}`,
      from: process.env.TWILIO_PHONE_NUMBER,
      to,
    });
  }

  private async sendPushNotification(user: any, notification: NotificationPayload): Promise<void> {
    // Implement web push notifications using Firebase Cloud Messaging
    // or OneSignal, Pusher, etc.
    console.log(`Sending push notification to ${user.email}`);
  }

  private async saveInAppNotification(notification: NotificationPayload): Promise<void> {
    await adminDb.collection('notifications').add({
      ...notification,
      read: false,
      createdAt: new Date(),
    });
  }

  private getEmailTemplate(notification: NotificationPayload): string {
    const templates = {
      job_match: `
        <!DOCTYPE html>
        <html>
        <head>
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
            .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
            .job-card { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
            .match-score { font-size: 48px; font-weight: bold; color: #667eea; text-align: center; }
            .button { display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px; margin: 10px 0; }
            .footer { text-align: center; padding: 20px; color: #666; font-size: 12px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>ðŸŽ¯ New Job Match!</h1>
            </div>
            <div class="content">
              <div class="job-card">
                <h2>${notification.data?.job?.title || 'Job Title'}</h2>
                <p><strong>${notification.data?.job?.company || 'Company'}</strong></p>
                <p>ðŸ“ ${notification.data?.job?.location || 'Location'}</p>
                <div class="match-score">${notification.data?.matchScore || 0}%</div>
                <p style="text-align: center; color: #666;">Match Score</p>
                <p><strong>Why you're a great fit:</strong></p>
                <ul>
                  ${(notification.data?.reasons || []).map((r: string) => `<li>${r}</li>`).join('')}
                </ul>
                <div style="text-align: center;">
                  <a href="${notification.data?.job?.url || '#'}" class="button">View Job Details</a>
                </div>
              </div>
            </div>
            <div class="footer">
              <p>You're receiving this because you have email notifications enabled.</p>
              <p><a href="${process.env.NEXT_PUBLIC_APP_URL}/settings">Update notification preferences</a></p>
            </div>
          </div>
        </body>
        </html>
      `,
      application_update: `
        <!DOCTYPE html>
        <html>
        <body style="font-family: Arial, sans-serif;">
          <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
            <h2>ðŸ“¬ ${notification.title}</h2>
            <p>${notification.body}</p>
            <a href="${process.env.NEXT_PUBLIC_APP_URL}/applications" style="display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px; margin: 10px 0;">View Application</a>
          </div>
        </body>
        </html>
      `,
      interview_scheduled: `
        <!DOCTYPE html>
        <html>
        <body style="font-family: Arial, sans-serif;">
          <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
            <h2>ðŸŽ‰ ${notification.title}</h2>
            <p>${notification.body}</p>
            <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; margin: 20px 0;">
              <h3>Interview Details:</h3>
              <p><strong>Date:</strong> ${notification.data?.date || 'TBD'}</p>
              <p><strong>Time:</strong> ${notification.data?.time || 'TBD'}</p>
              <p><strong>Format:</strong> ${notification.data?.format || 'TBD'}</p>
            </div>
            <a href="${process.env.NEXT_PUBLIC_APP_URL}/interviews/${notification.data?.interviewId}" style="display: inline-block; background: #667eea; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px;">Prepare for Interview</a>
          </div>
        </body>
        </html>
      `,
    };
    return templates[notification.type as keyof typeof templates] || templates.application_update;
  }

  private getDefaultChannels(type: NotificationPayload['type']): ('email' | 'sms' | 'push' | 'in_app')[] {
    const channelMap: Record<NotificationPayload['type'], ('email' | 'sms' | 'push' | 'in_app')[]> = {
      job_match: ['email', 'in_app', 'push'],
      application_update: ['email', 'in_app'],
      interview_scheduled: ['email', 'sms', 'in_app', 'push'],
      message: ['in_app', 'push'],
    };

    return channelMap[type] || ['in_app'];
  }
}  // â† ADDED THE MISSING CLOSING BRACE HERE

// Notification templates for common events
export const NotificationTemplates = {
  newJobMatch: (job: any, matchScore: number, reasons: string[]) => ({
    type: 'job_match' as const,
    title: `New ${matchScore}% Match: ${job.title}`,
    body: `${job.company} is hiring for a role that matches your profile!`,
    data: { job, matchScore, reasons },
  }),

  applicationStatusChanged: (application: any) => ({
    type: 'application_update' as const,
    title: `Application Update: ${application.job.title}`,
    body: `Your application status changed to: ${application.status}`,
    data: { application },
  }),

  interviewScheduled: (interview: any) => ({
    type: 'interview_scheduled' as const,
    title: `Interview Scheduled with ${interview.company}!`,
    body: `You have an interview scheduled for ${interview.date}`,
    data: interview,
  }),
};

// Bulk notification sender
export async function sendBulkNotifications(
  userIds: string[],
  notification: Omit<NotificationPayload, 'userId'>
): Promise<void> {
  const service = new NotificationService();
  const promises = userIds.map(userId =>
    service.send({ ...notification, userId })
  );

  await Promise.allSettled(promises);
}

// API Route: /api/notifications/send
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { userId, type, title, body: message, data } = body;

    const service = new NotificationService();
    await service.send({
      userId,
      type,
      title,
      body: message,
      data,
    });

    return Response.json({ success: true });
  } catch (error) {
    console.error('Failed to send notification:', error);
    return Response.json({ error: 'Failed to send notification' }, { status: 500 });
  }
}
===== ./src/lib/rate-limit.ts =====
// lib/rate-limit.ts
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

export const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, "1 h"),
});
===== ./src/lib/stripe.ts =====
import Stripe from 'stripe';

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('STRIPE_SECRET_KEY is not set');
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: '2023-10-16',
  typescript: true,
});

export const PRICE_IDS = {
  pro: process.env.STRIPE_PRICE_PRO_MONTHLY || '',
  premium: process.env.STRIPE_PRICE_PREMIUM_MONTHLY || '',
  enterprise: process.env.STRIPE_PRICE_ENTERPRISE_MONTHLY || '',
} as const;

export type PriceTier = keyof typeof PRICE_IDS;

export interface StripeCustomer {
  id: string;
  email: string;
  name?: string;
}

export interface CreateCheckoutSessionParams {
  userId: string;
  userEmail: string;
  tier: PriceTier;
  successUrl: string;
  cancelUrl: string;
}

export async function createCheckoutSession({
  userId,
  userEmail,
  tier,
  successUrl,
  cancelUrl,
}: CreateCheckoutSessionParams): Promise<Stripe.Checkout.Session> {
  const priceId = PRICE_IDS[tier];

  if (!priceId) {
    throw new Error(`Invalid tier: ${tier}`);
  }

  const session = await stripe.checkout.sessions.create({
    customer_email: userEmail,
    line_items: [
      {
        price: priceId,
        quantity: 1,
      },
    ],
    mode: 'subscription',
    success_url: successUrl,
    cancel_url: cancelUrl,
    metadata: {
      userId,
      tier,
    },
    subscription_data: {
      metadata: {
        userId,
        tier,
      },
    },
    allow_promotion_codes: true,
    billing_address_collection: 'required',
  });

  return session;
}

export async function createCustomerPortalSession(
  customerId: string,
  returnUrl: string
): Promise<Stripe.BillingPortal.Session> {
  const session = await stripe.billingPortal.sessions.create({
    customer: customerId,
    return_url: returnUrl,
  });

  return session;
}

export async function getCustomerByEmail(email: string): Promise<StripeCustomer | null> {
  const customers = await stripe.customers.list({
    email,
    limit: 1,
  });

  if (customers.data.length === 0) {
    return null;
  }

  const customer = customers.data[0];
  return {
    id: customer.id,
    email: customer.email || email,
    name: customer.name || undefined,
  };
}

export async function getSubscription(subscriptionId: string): Promise<Stripe.Subscription | null> {
  try {
    return await stripe.subscriptions.retrieve(subscriptionId);
  } catch (error) {
    console.error('Error fetching subscription:', error);
    return null;
  }
}

export async function cancelSubscription(subscriptionId: string): Promise<Stripe.Subscription> {
  return await stripe.subscriptions.cancel(subscriptionId);
}

export async function updateSubscription(
  subscriptionId: string,
  newPriceId: string
): Promise<Stripe.Subscription> {
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);

  return await stripe.subscriptions.update(subscriptionId, {
    items: [
      {
        id: subscription.items.data[0].id,
        price: newPriceId,
      },
    ],
    proration_behavior: 'always_invoice',
  });
}

export async function constructWebhookEvent(
  body: string | Buffer,
  signature: string
): Promise<Stripe.Event> {
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  if (!webhookSecret) {
    throw new Error('STRIPE_WEBHOOK_SECRET is not set');
  }

  return stripe.webhooks.constructEvent(body, signature, webhookSecret);
}

// Helper to determine subscription tier from price ID
export function getTierFromPriceId(priceId: string): PriceTier | null {
  const entries = Object.entries(PRICE_IDS) as [PriceTier, string][];
  const found = entries.find(([_, id]) => id === priceId);
  return found ? found[0] : null;
}

// Helper to check if subscription is active
export function isSubscriptionActive(status: Stripe.Subscription.Status): boolean {
  return ['active', 'trialing'].includes(status);
}

// Helper to format amount for display
export function formatAmount(amount: number, currency: string = 'usd'): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency.toUpperCase(),
  }).format(amount / 100);
}
===== ./src/lib/types.ts =====
// lib/types.ts
export interface UserProfile {
  // Basic Info
  email: string;
  displayName: string;
  phone?: string;
  location?: string;
  
  // Professional Info
  currentTitle?: string;
  yearsOfExperience?: number;
  linkedinUrl?: string;
  portfolioUrl?: string;
  githubUrl?: string;
  
  // Job Search Preferences
  searchKeywords: string[];
  seniorityLevels: string[];
  preferredLocations: string[];
  minMatchScore: number;
  
  // Auto-Apply Data
  resumeUrl?: string;
  resumeName?: string;
  coverLetterTemplate?: string;
  
  // Work History (for forms)
  workHistory?: {
    company: string;
    title: string;
    startDate: string;
    endDate: string;
    current: boolean;
    description: string;
  }[];
  
  // Education
  education?: {
    school: string;
    degree: string;
    field: string;
    graduationYear: string;
  }[];
  
  // Additional Info
  eligibleToWorkInUS?: boolean;
  requiresSponsorship?: boolean;
  veteranStatus?: string;
  ethnicity?: string;
  gender?: string;
  disability?: string;
}
===== ./src/lib/utils.ts =====
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

===== ./tailwind.config.ts =====
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: [
    './src/pages/**/*.{ts,tsx}',
    './src/components/**/*.{ts,tsx}',
    './src/app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [require('tailwindcss-animate')],
};

export default config;
